---
phase: 08-interest-notification-system
plan: 02
type: execute
wave: 2
depends_on: [08-01]
files_modified: [bot/handlers/vip/callbacks.py, bot/handlers/free/callbacks.py, bot/services/message/user_menu.py]
autonomous: true

must_haves:
  truths:
    - "Usuario marca 'Me interesa' y admin recibe notificaci√≥n privada en Telegram"
    - "Notificaci√≥n incluye: nombre de usuario, link al perfil, timestamp, detalles del paquete"
    - "Notificaci√≥n usa voz de Lucien con botones inline para acciones"
    - "Deduplicaci√≥n funciona: segundo clic dentro de 5 min no genera notificaci√≥n"
    - "Ambos handlers (VIP y Free) usan InterestService en lugar de l√≥gica duplicada"
  artifacts:
    - path: "bot/handlers/vip/callbacks.py"
      provides: "Enhanced interest callback handler with Telegram admin notifications"
      contains: "handle_package_interest uses InterestService and sends admin notifications"
    - path: "bot/handlers/free/callbacks.py"
      provides: "Enhanced interest callback handler with Telegram admin notifications"
      contains: "handle_package_interest uses InterestService and sends admin notifications"
  key_links:
    - from: "vip/free callback handlers"
      to: "InterestService"
      via: "ServiceContainer.interest.register_interest"
      pattern: "await container\\.interest\\.register_interest"
    - from: "vip/free callback handlers"
      to: "Admin users"
      via: "bot.send_message to admin user_ids"
      pattern: "await bot\\.send_message"
---

<objective>
Refactor VIP and Free "Me interesa" callback handlers to use InterestService from plan 08-01 and implement real-time Telegram admin notifications with user info, package details, Lucien's voice, and inline action buttons.

Purpose: Replace current console-only logging with actual Telegram messages sent to all configured admins, following CONTEXT.md decision for instant broadcast notifications with per-user deduplication. Use InterestService to prevent spam while allowing genuine re-interest expression after debounce window.
Output: Enhanced handle_package_interest in both VIP and Free callback handlers with admin notification sending, using InterestService for deduplication.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/08-interest-notification-system/08-CONTEXT.md

@bot/handlers/vip/callbacks.py (handle_package_interest, lines 150-223)
@bot/handlers/free/callbacks.py (handle_package_interest, lines 209-293)
@bot/services/interest.py (plan 08-01)
@bot/services/message/user_menu.py
@bot/database/models.py (User model, Config.get_admins)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Refactor VIP interest handler to use InterestService with admin notifications</name>
  <files>bot/handlers/vip/callbacks.py</files>
  <action>
Update bot/handlers/vip/callbacks.py handle_package_interest handler:

1. Replace existing implementation (lines 150-223) with InterestService integration:

```python
@vip_callbacks_router.callback_query(lambda c: c.data and c.data.startswith("interest:package:"))
async def handle_package_interest(callback: CallbackQuery, **kwargs):
    """
    Registra inter√©s de usuario en paquete y notifica a admins.

    Callback data format: "interest:package:{package_id}"

    Flujo:
    1. Extraer package_id del callback
    2. Registrar inter√©s usando InterestService (con deduplicaci√≥n de 5 min)
    3. Si success=True (nuevo o re-inter√©s despu√©s de ventana):
       - Enviar notificaci√≥n privada a todos los admins
       - Notificaci√≥n incluye: usuario, link al perfil, paquete, timestamp
       - Botones inline: Ver todos, Marcar atendido, Mensaje usuario, Bloquear
    4. Si success=False (debounce):
       - No enviar notificaci√≥n
       - Mostrar feedback sutil al usuario

    Args:
        callback: CallbackQuery de Telegram
        **kwargs: Data del handler (container, session, etc.)
    """
    data = kwargs.get("data", {})
    container = data.get("container")
    user = callback.from_user

    if not container:
        await callback.answer("‚ö†Ô∏è Error: servicio no disponible", show_alert=True)
        return

    try:
        # Extract package ID from callback data
        package_id_str = callback.data.split(":")[-1]
        package_id = int(package_id_str)

        # Register interest using InterestService (with deduplication)
        success, status, interest = await container.interest.register_interest(
            user_id=user.id,
            package_id=package_id
        )

        if success:
            # New interest or re-interest after debounce window
            logger.info(
                f"‚úÖ Usuario VIP {user.id} ({user.first_name}) interesado en paquete {package_id} "
                f"(status: {status})"
            )

            # Send admin notification (INTEREST-03, INTEREST-04 requirements)
            await _send_admin_interest_notification(
                bot=callback.bot,
                container=container,
                user=user,
                package=interest.package,
                interest=interest,
                user_role="VIP"
            )

            # Show success feedback to user
            await callback.answer(
                "‚úÖ Tu inter√©s ha sido registrado. Diana ser√° notificada.",
                show_alert=True
            )
        else:
            # Debounce window active - no notification
            if status == "debounce":
                logger.debug(
                    f"‚è±Ô∏è Inter√©s de usuario VIP {user.id} en paquete {package_id} "
                    f"ignorado (ventana de debounce activa)"
                )
                # Show subtle feedback (no alert, just toast)
                await callback.answer("‚úÖ Inter√©s registrado previamente")
            else:
                # Error occurred
                logger.error(
                    f"‚ùå Error registrando inter√©s para usuario VIP {user.id}: {status}"
                )
                await callback.answer(
                    "‚ö†Ô∏è Error registrando inter√©s",
                    show_alert=True
                )

    except (ValueError, IndexError) as e:
        logger.error(f"Error parsing package ID from callback {callback.data}: {e}")
        await callback.answer("‚ö†Ô∏è Error: ID de paquete inv√°lido", show_alert=True)
    except Exception as e:
        logger.error(f"Error registrando inter√©s para {user.id}: {e}", exc_info=True)
        await callback.answer("‚ö†Ô∏è Error registrando inter√©s", show_alert=True)


async def _send_admin_interest_notification(
    bot,
    container,
    user,
    package,
    interest,
    user_role: str
):
    """
    Env√≠a notificaci√≥n privada a todos los admins sobre nuevo inter√©s.

    Args:
        bot: Instancia del bot
        container: ServiceContainer
        user: Usuario de Telegram (callback.from_user)
        package: Objeto ContentPackage
        interest: Objeto UserInterest
        user_role: "VIP" o "Free"
    """
    try:
        # Get all admin user IDs from config
        from bot.database.models import Config
        from sqlalchemy import select

        stmt = select(Config).where(Config.id == 1)
        result = await container.session.execute(stmt)
        config = result.scalar_one_or_none()

        if not config or not config.admins:
            logger.warning("‚ö†Ô∏è No admins configured for interest notifications")
            return

        admin_ids = [admin.user_id for admin in config.admins]

        # Format user info
        username = f"@{user.username}" if user.username else f"usuario {user.id}"
        user_link = f"tg://user?id={user.id}"

        # Format package info
        package_type_emoji = {
            "VIP_PREMIUM": "üíé",
            "VIP_CONTENT": "üëë",
            "FREE_CONTENT": "üå∏"
        }.get(package.category.value if hasattr(package.category, 'value') else str(package.category), "üì¶")

        # Build notification message in Lucien's voice
        notification_text = (
            f"üé© <b>Lucien:</b> <i>Nueva expresi√≥n de inter√©s detectada...</i>\n\n"
            f"<b>üë§ Visitante:</b> {username} ({user_role})\n"
            f"<b>üì¶ Tesoro de inter√©s:</b> {package_type_emoji} {package.name}\n"
            f"<b>üìù Descripci√≥n:</b> {package.description or 'Sin descripci√≥n'}\n"
            f"<b>üí∞ Precio:</b> ${package.price:.2f}" if package.price else "<b>üí∞ Precio:</b> Gratuito"
        )

        if package.category:
            type_text = {
                "VIP_PREMIUM": "Premium Exclusivo",
                "VIP_CONTENT": "Contenido VIP",
                "FREE_CONTENT": "Contenido Gratuito"
            }.get(package.category.value, str(package.category))
            notification_text += f"\n<b>üè∑Ô∏è Tipo:</b> {type_text}"

        notification_text += (
            f"\n\n<b>‚è∞ Momento:</b> {interest.created_at.strftime('%Y-%m-%d %H:%M')}\n"
            f"<i>Diana, un miembro del c√≠rculo ha mostrado inter√©s en uno de sus tesoros...</i>"
        )

        # Create inline keyboard with action buttons
        from aiogram.types import InlineKeyboardMarkup, InlineKeyboardButton

        keyboard = InlineKeyboardMarkup(inline_keyboard=[
            [
                InlineKeyboardButton(
                    text="üìã Ver Todos los Intereses",
                    callback_data=f"admin:interests:list:pending"
                )
            ],
            [
                InlineKeyboardButton(
                    text="‚úÖ Marcar como Atendido",
                    callback_data=f"admin:interest:attend:{interest.id}"
                )
            ],
            [
                InlineKeyboardButton(
                    text="üí¨ Mensaje al Usuario",
                    url=user_link
                ),
                InlineKeyboardButton(
                    text="üö´ Bloquear Contacto",
                    callback_data=f"admin:user:block_contact:{user.id}"
                )
            ]
        ])

        # Send notification to all admins
        sent_count = 0
        failed_admins = []

        for admin_id in admin_ids:
            try:
                await bot.send_message(
                    chat_id=admin_id,
                    text=notification_text,
                    parse_mode="HTML",
                    reply_markup=keyboard
                )
                sent_count += 1
                logger.debug(f"üì§ Interest notification sent to admin {admin_id}")
            except Exception as e:
                logger.error(
                    f"‚ùå Failed to send interest notification to admin {admin_id}: {e}"
                )
                failed_admins.append(admin_id)

        logger.info(
            f"üì¢ Interest notification sent to {sent_count}/{len(admin_ids)} admins "
            f"(user: {user.id}, package: {package.id}, role: {user_role})"
        )

        if failed_admins:
            logger.warning(
                f"‚ö†Ô∏è Failed to send to admins: {failed_admins} "
                f"(may have blocked the bot or deleted chat)"
            )

    except Exception as e:
        logger.error(f"Error sending admin interest notification: {e}", exc_info=True)
```

2. Update imports at top of file to include needed modules:
```python
from datetime import datetime
from aiogram.types import InlineKeyboardMarkup, InlineKeyboardButton
```

DO NOT:
- Remove existing callback handler registration
- Change callback data pattern "interest:package:{id}"
- Remove error handling (ValueError, IndexError, Exception)
- Forget to call callback.answer() in all code paths
- Use hardcoded admin IDs (always get from Config.admins)
  </action>
  <verify>
1. handle_package_interest handler exists with callback pattern "interest:package:*"
2. Uses container.interest.register_interest(user_id, package_id)
3. Checks success status before sending notification
4. Calls _send_admin_interest_notification when success=True
5. Shows different feedback for success, debounce, and error cases
6. _send_admin_interest_notification function exists
7. Gets admin IDs from Config.admins (not hardcoded)
8. Notification includes: username, user_role, package name, description, price, type, timestamp
9. Notification has inline keyboard with 4 action buttons
10. Sends to all admins with error handling per admin
11. Logs sent/failed counts
12. All paths call callback.answer()
  </verify>
  <done>
VIP interest handler refactored to use InterestService with admin notifications including user info, package details, inline actions, and proper debouncing.
  </done>
</task>

<task type="auto">
  <name>Task 2: Refactor Free interest handler to use InterestService with admin notifications</name>
  <files>bot/handlers/free/callbacks.py</files>
  <action>
Update bot/handlers/free/callbacks.py handle_package_interest handler:

1. Replace existing implementation (lines 209-293) with InterestService integration:

```python
@free_callbacks_router.callback_query(lambda c: c.data and c.data.startswith("interest:package:"))
async def handle_package_interest(callback: CallbackQuery, **kwargs):
    """
    Registra inter√©s de usuario en paquete FREE_CONTENT y notifica a admins.

    Reutiliza l√≥gica de VIP callbacks para consistencia.

    Callback data format: "interest:package:{package_id}"

    Flujo:
    1. Extraer package_id del callback
    2. Registrar inter√©s usando InterestService (con deduplicaci√≥n de 5 min)
    3. Si success=True (nuevo o re-inter√©s despu√©s de ventana):
       - Enviar notificaci√≥n privada a todos los admins
       - Notificaci√≥n incluye: usuario, link al perfil, paquete, timestamp
       - Botones inline: Ver todos, Marcar atendido, Mensaje usuario, Bloquear
    4. Si success=False (debounce):
       - No enviar notificaci√≥n
       - Mostrar feedback sutil al usuario

    Args:
        callback: CallbackQuery de Telegram
        **kwargs: Data del handler (container, session, etc.)
    """
    data = kwargs.get("data", {})
    container = data.get("container")
    user = callback.from_user

    if not container:
        await callback.answer("‚ö†Ô∏è Error: servicio no disponible", show_alert=True)
        return

    try:
        # Extract package ID from callback data
        package_id_str = callback.data.split(":")[-1]
        package_id = int(package_id_str)

        # Register interest using InterestService (with deduplication)
        success, status, interest = await container.interest.register_interest(
            user_id=user.id,
            package_id=package_id
        )

        if success:
            # New interest or re-interest after debounce window
            logger.info(
                f"‚úÖ Usuario Free {user.id} ({user.first_name}) interesado en paquete {package_id} "
                f"(status: {status})"
            )

            # Send admin notification
            await _send_admin_interest_notification(
                bot=callback.bot,
                container=container,
                user=user,
                package=interest.package,
                interest=interest,
                user_role="Free"
            )

            # Show success feedback to user
            await callback.answer(
                "‚úÖ Tu inter√©s ha sido registrado. Diana ser√° notificada.",
                show_alert=True
            )
        else:
            # Debounce window active - no notification
            if status == "debounce":
                logger.debug(
                    f"‚è±Ô∏è Inter√©s de usuario Free {user.id} en paquete {package_id} "
                    f"ignorado (ventana de debounce activa)"
                )
                # Show subtle feedback (no alert, just toast)
                await callback.answer("‚úÖ Inter√©s registrado previamente")
            else:
                # Error occurred
                logger.error(
                    f"‚ùå Error registrando inter√©s para usuario Free {user.id}: {status}"
                )
                await callback.answer(
                    "‚ö†Ô∏è Error registrando inter√©s",
                    show_alert=True
                )

    except (ValueError, IndexError) as e:
        logger.error(f"Error parsing package ID from callback {callback.data}: {e}")
        await callback.answer("‚ö†Ô∏è Error: ID de paquete inv√°lido", show_alert=True)
    except Exception as e:
        logger.error(f"Error registrando inter√©s para {user.id}: {e}", exc_info=True)
        await callback.answer("‚ö†Ô∏è Error registrando inter√©s", show_alert=True)


async def _send_admin_interest_notification(
    bot,
    container,
    user,
    package,
    interest,
    user_role: str
):
    """
    Env√≠a notificaci√≥n privada a todos los admins sobre nuevo inter√©s.

    Nota: Esta funci√≥n es id√©ntica a la versi√≥n VIP para consistencia.
    En el futuro podr√≠a extraerse a un m√≥dulo compartido.

    Args:
        bot: Instancia del bot
        container: ServiceContainer
        user: Usuario de Telegram (callback.from_user)
        package: Objeto ContentPackage
        interest: Objeto UserInterest
        user_role: "VIP" o "Free"
    """
    try:
        # Get all admin user IDs from config
        from bot.database.models import Config
        from sqlalchemy import select

        stmt = select(Config).where(Config.id == 1)
        result = await container.session.execute(stmt)
        config = result.scalar_one_or_none()

        if not config or not config.admins:
            logger.warning("‚ö†Ô∏è No admins configured for interest notifications")
            return

        admin_ids = [admin.user_id for admin in config.admins]

        # Format user info
        username = f"@{user.username}" if user.username else f"usuario {user.id}"
        user_link = f"tg://user?id={user.id}"

        # Format package info
        package_type_emoji = {
            "VIP_PREMIUM": "üíé",
            "VIP_CONTENT": "üëë",
            "FREE_CONTENT": "üå∏"
        }.get(package.category.value if hasattr(package.category, 'value') else str(package.category), "üì¶")

        # Build notification message in Lucien's voice
        notification_text = (
            f"üé© <b>Lucien:</b> <i>Nueva expresi√≥n de inter√©s detectada...</i>\n\n"
            f"<b>üë§ Visitante:</b> {username} ({user_role})\n"
            f"<b>üì¶ Tesoro de inter√©s:</b> {package_type_emoji} {package.name}\n"
            f"<b>üìù Descripci√≥n:</b> {package.description or 'Sin descripci√≥n'}\n"
        )

        if package.price is not None:
            notification_text += f"<b>üí∞ Precio:</b> ${package.price:.2f}"
        else:
            notification_text += "<b>üí∞ Precio:</b> Gratuito"

        if package.category:
            type_text = {
                "VIP_PREMIUM": "Premium Exclusivo",
                "VIP_CONTENT": "Contenido VIP",
                "FREE_CONTENT": "Contenido Gratuito"
            }.get(package.category.value, str(package.category))
            notification_text += f"\n<b>üè∑Ô∏è Tipo:</b> {type_text}"

        notification_text += (
            f"\n\n<b>‚è∞ Momento:</b> {interest.created_at.strftime('%Y-%m-%d %H:%M')}\n"
            f"<i>Diana, un visitante del jard√≠n ha mostrado inter√©s en uno de sus tesoros...</i>"
        )

        # Create inline keyboard with action buttons
        from aiogram.types import InlineKeyboardMarkup, InlineKeyboardButton

        keyboard = InlineKeyboardMarkup(inline_keyboard=[
            [
                InlineKeyboardButton(
                    text="üìã Ver Todos los Intereses",
                    callback_data=f"admin:interests:list:pending"
                )
            ],
            [
                InlineKeyboardButton(
                    text="‚úÖ Marcar como Atendido",
                    callback_data=f"admin:interest:attend:{interest.id}"
                )
            ],
            [
                InlineKeyboardButton(
                    text="üí¨ Mensaje al Usuario",
                    url=user_link
                ),
                InlineKeyboardButton(
                    text="üö´ Bloquear Contacto",
                    callback_data=f"admin:user:block_contact:{user.id}"
                )
            ]
        ])

        # Send notification to all admins
        sent_count = 0
        failed_admins = []

        for admin_id in admin_ids:
            try:
                await bot.send_message(
                    chat_id=admin_id,
                    text=notification_text,
                    parse_mode="HTML",
                    reply_markup=keyboard
                )
                sent_count += 1
                logger.debug(f"üì§ Interest notification sent to admin {admin_id}")
            except Exception as e:
                logger.error(
                    f"‚ùå Failed to send interest notification to admin {admin_id}: {e}"
                )
                failed_admins.append(admin_id)

        logger.info(
            f"üì¢ Interest notification sent to {sent_count}/{len(admin_ids)} admins "
            f"(user: {user.id}, package: {package.id}, role: {user_role})"
        )

        if failed_admins:
            logger.warning(
                f"‚ö†Ô∏è Failed to send to admins: {failed_admins} "
                f"(may have blocked the bot or deleted chat)"
            )

    except Exception as e:
        logger.error(f"Error sending admin interest notification: {e}", exc_info=True)
```

2. Update imports at top of file to include needed modules:
```python
from datetime import datetime
from aiogram.types import InlineKeyboardMarkup, InlineKeyboardButton
```

DO NOT:
- Remove existing callback handler registration
- Change callback data pattern "interest:package:{id}"
- Remove error handling
- Modify notification content differently from VIP (consistency required)
  </action>
  <verify>
1. handle_package_interest handler exists in Free callbacks
2. Uses container.interest.register_interest(user_id, package_id)
3. Calls _send_admin_interest_notification when success=True
4. Notification content is IDENTICAL to VIP version (consistency)
5. Shows same feedback for success, debounce, and error cases
6. Gets admin IDs from Config.admins
7. Notification includes all required fields (username, role, package, timestamp)
8. Inline keyboard has same 4 action buttons
9. Sends to all admins with error handling
10. Logs sent/failed counts
11. All paths call callback.answer()
  </verify>
  <done>
Free interest handler refactored to use InterestService with admin notifications, identical to VIP for consistency, with proper debouncing.
  </done>
</task>

</tasks>

<verification>
Overall phase verification:
1. VIP handle_package_interest uses InterestService instead of direct DB queries
2. Free handle_package_interest uses InterestService instead of direct DB queries
3. Both handlers call _send_admin_interest_notification on success=True
4. Both handlers show different feedback for debounce case (no notification)
5. _send_admin_interest_notification gets admin IDs from Config.admins
6. Notification includes all required fields: username, role, package name/description/price/type, timestamp
7. Notification uses Lucien's voice ("üé© <b>Lucien:</b>", "visitante", "tesoro")
8. Notification has inline keyboard with 4 buttons: Ver Todos, Marcar Atendido, Mensaje Usuario, Bloquear Contacto
9. Notification sent to ALL admins with individual error handling
10. Logs sent_count/failed_count for monitoring
11. All code paths call callback.answer()
12. No hardcoded admin IDs
</verification>

<success_criteria>
1. User clicks "Me interesa" button on any package
2. InterestService.register_interest called with user_id and package_id
3. If first click or after 5-minute window: admin receives private Telegram message
4. If within 5-minute window: no admin notification (debounce), user sees subtle feedback
5. Admin notification includes:
   - Username (@username or "usuario {id}")
   - User role (VIP or Free)
   - Package name with emoji based on type
   - Package description
   - Package price or "Gratuito"
   - Package type (Premium Exclusivo, Contenido VIP, Contenido Gratuito)
   - Timestamp in format "YYYY-MM-DD HH:MM"
   - Lucien's voice narrative
6. Admin notification has 4 inline buttons with correct callback_data
7. All configured admins receive notification (not just first admin)
8. Logs show: "üì¢ Interest notification sent to X/Y admins"
</success_criteria>

<output>
After completion, create `.planning/phases/08-interest-notification-system/08-02-SUMMARY.md`
</output>

---
phase: 08-interest-notification-system
plan: 01
type: execute
wave: 1
depends_on: [07-04]
files_modified: [bot/services/interest.py, bot/services/__init__.py, bot/services/container.py]
autonomous: true

must_haves:
  truths:
    - "InterestService existe con método para registrar interés con deduplicación"
    - "InterestService tiene método para listar intereses con filtros y paginación"
    - "InterestService integrado en ServiceContainer con lazy loading"
    - "Deduplicación por user_id + package_id con ventana de 5 minutos"
  artifacts:
    - path: "bot/services/interest.py"
      provides: "InterestService with interest registration, listing, filtering, and management"
      min_lines: 300
      exports: ["register_interest", "get_interests", "mark_as_attended", "get_interest_stats", "is_within_debounce_window"]
  key_links:
    - from: "bot/handlers/vip/callbacks.py, bot/handlers/free/callbacks.py"
      to: "bot/services/interest.py"
      via: "ServiceContainer.interest"
      pattern: "await container\\.interest\\."
    - from: "ServiceContainer"
      to: "InterestService"
      via: "lazy loading property"
      pattern: "@property\\s+def interest"
---

<objective>
Create InterestService with deduplication logic, interest listing with filters/pagination, and management methods (mark as attended, stats) following established service pattern (SubscriptionService, ContentService).

Purpose: Provide centralized service layer for UserInterest management with 5-minute debounce window per user+package, preventing notification spam while allowing re-expression of interest after window expires. Enable admin interface for viewing and managing interests.
Output: InterestService class with 8+ async methods, registered in ServiceContainer for lazy loading.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/08-interest-notification-system/08-CONTEXT.md

@bot/services/subscription.py
@bot/services/content.py
@bot/services/container.py
@bot/database/models.py (UserInterest model)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create InterestService class with core methods</name>
  <files>bot/services/interest.py</files>
  <action>
Create bot/services/interest.py with InterestService class:

1. File structure:
```python
"""
Interest Service - Gestión de intereses de usuarios en paquetes.

Servicio para registrar, consultar y gestionar intereses expresados por usuarios
en paquetes de contenido. Implementa deduplicación con ventana de tiempo para
evitar spam en notificaciones a administradores.
"""
import logging
from datetime import datetime, timedelta
from typing import List, Optional, Tuple, Dict, Any
from sqlalchemy import select, and_, or_, desc
from sqlalchemy.ext.asyncio import AsyncSession

from bot.database.models import UserInterest, ContentPackage, User
from bot.database.enums import PackageType

logger = logging.getLogger(__name__)


class InterestService:
    """
    Servicio para gestión de intereses de usuarios.

    Responsabilidades:
    - Registrar intereses con deduplicación (ventana de 5 minutos)
    - Listar intereses con filtros (pendientes, atendidos, por tipo)
    - Marcar intereses como atendidos
    - Obtener estadísticas de intereses
    - Verificar ventana de debounce para re-expresión de interés

    Patrón de deduplicación:
    - Un usuario puede expresar interés en el mismo paquete múltiples veces
    - Solo se crea notificación si ha pasado > 5 minutos desde el último interés
    - Se actualiza created_at para mantener el registro "fresco"
    """

    DEBOUNCE_WINDOW_MINUTES = 5

    def __init__(self, session: AsyncSession, bot):
        """
        Inicializar InterestService.

        Args:
            session: Sesión de base de datos SQLAlchemy async
            bot: Instancia del bot de Telegram
        """
        self.session = session
        self.bot = bot
```

2. Required methods:

**a. register_interest(user_id, package_id) -> Tuple[bool, str, Optional[UserInterest]]:**
```python
async def register_interest(
    self,
    user_id: int,
    package_id: int
) -> Tuple[bool, str, Optional[UserInterest]]:
    """
    Registra interés de usuario en paquete con deduplicación.

    Lógica:
    1. Busca interés existente para (user_id, package_id)
    2. Si existe:
       - Verifica si está dentro de ventana de debounce (5 min)
       - Si está dentro: retorna (False, "debounce", existing_interest)
       - Si pasó ventana: actualiza created_at, retorna (True, "updated", interest)
    3. Si no existe:
       - Crea nuevo registro con is_attended=False
       - Retorna (True, "created", new_interest)

    Args:
        user_id: ID del usuario de Telegram
        package_id: ID del paquete de contenido

    Returns:
        Tupla (success, status, interest):
        - success: True si se debe notificar admin, False si es debounce
        - status: "created", "updated", "debounce", "error"
        - interest: Objeto UserInterest o None si error

    Raises:
        ValueError: Si package_id no existe
    """
    try:
        # Verify package exists
        package_stmt = select(ContentPackage).where(ContentPackage.id == package_id)
        package_result = await self.session.execute(package_stmt)
        package = package_result.scalar_one_or_none()

        if not package:
            logger.error(f"Package {package_id} not found for interest registration")
            return (False, "error", None)

        # Check existing interest
        existing_stmt = select(UserInterest).where(
            and_(
                UserInterest.user_id == user_id,
                UserInterest.package_id == package_id
            )
        )
        existing_result = await self.session.execute(existing_stmt)
        existing_interest = existing_result.scalar_one_or_none()

        if existing_interest:
            # Check debounce window
            if self._is_within_debounce_window(existing_interest.created_at):
                logger.debug(
                    f"Interest for user {user_id}, package {package_id} "
                    f"within debounce window (ignoring)"
                )
                return (False, "debounce", existing_interest)
            else:
                # Update timestamp (re-interest after window)
                existing_interest.created_at = datetime.utcnow()
                logger.info(
                    f"Updated interest timestamp for user {user_id}, "
                    f"package {package_id} (debounce window expired)"
                )
                return (True, "updated", existing_interest)
        else:
            # Create new interest
            new_interest = UserInterest(
                user_id=user_id,
                package_id=package_id,
                is_attended=False,
                attended_at=None,
                created_at=datetime.utcnow()
            )
            self.session.add(new_interest)
            logger.info(
                f"Registered new interest for user {user_id}, package {package_id}"
            )
            return (True, "created", new_interest)

    except Exception as e:
        logger.error(
            f"Error registering interest for user {user_id}, "
            f"package {package_id}: {e}",
            exc_info=True
        )
        return (False, "error", None)
```

**b. get_interests(filters, pagination) -> List[UserInterest]:**
```python
async def get_interests(
    self,
    is_attended: Optional[bool] = None,
    package_type: Optional[PackageType] = None,
    user_id: Optional[int] = None,
    limit: int = 20,
    offset: int = 0,
    sort_newest_first: bool = True
) -> Tuple[List[UserInterest], int]:
    """
    Obtiene lista de intereses con filtros y paginación.

    Args:
        is_attended: Filtrar por estado de atención (None = todos)
        package_type: Filtrar por tipo de paquete (None = todos)
        user_id: Filtrar por usuario específico (None = todos)
        limit: Máximo de registros a retornar
        offset: Registro inicial (para paginación)
        sort_newest_first: True para más recientes primero, False para más antiguos

    Returns:
        Tupla (interests, total_count):
        - interests: Lista de objetos UserInterest
        - total_count: Total de registros (sin paginar)

    Examples:
        >>> # Get all pending interests, newest first
        >>> interests, total = await service.get_interests(is_attended=False)

        >>> # Get attended VIP interests, paginated
        >>> interests, total = await service.get_interests(
        ...     is_attended=True,
        ...     package_type=PackageType.VIP_CONTENT,
        ...     limit=10,
        ...     offset=0
        ... )
    """
    try:
        # Build base query with joins
        stmt = select(UserInterest).join(ContentPackage)

        # Apply filters
        conditions = []
        if is_attended is not None:
            conditions.append(UserInterest.is_attended == is_attended)
        if package_type is not None:
            conditions.append(ContentPackage.category == package_type)
        if user_id is not None:
            conditions.append(UserInterest.user_id == user_id)

        if conditions:
            stmt = stmt.where(and_(*conditions))

        # Count total
        count_stmt = select(UserInterest.__table__.c.id)
        if conditions:
            count_stmt = count_stmt.where(and_(*conditions))
        count_result = await self.session.execute(count_stmt)
        total_count = len(count_result.all())

        # Apply sorting
        if sort_newest_first:
            stmt = stmt.order_by(desc(UserInterest.created_at))
        else:
            stmt = stmt.order_by(UserInterest.created_at)

        # Apply pagination
        stmt = stmt.limit(limit).offset(offset)

        # Execute
        result = await self.session.execute(stmt)
        interests = result.scalars().all()

        logger.debug(
            f"Retrieved {len(interests)} interests (total: {total_count}, "
            f"filters: attended={is_attended}, type={package_type}, user={user_id})"
        )

        return (interests, total_count)

    except Exception as e:
        logger.error(f"Error getting interests: {e}", exc_info=True)
        return ([], 0)
```

**c. mark_as_attended(interest_id) -> Tuple[bool, str]:**
```python
async def mark_as_attended(self, interest_id: int) -> Tuple[bool, str]:
    """
    Marca un interés como atendido.

    Args:
        interest_id: ID del registro UserInterest

    Returns:
        Tupla (success, message):
        - success: True si se marcó correctamente
        - message: Mensaje de éxito o error

    Examples:
        >>> success, msg = await service.mark_as_attended(123)
        >>> if success:
        ...     print("Interés marcado como atendido")
    """
    try:
        stmt = select(UserInterest).where(UserInterest.id == interest_id)
        result = await self.session.execute(stmt)
        interest = result.scalar_one_or_none()

        if not interest:
            return (False, "Interés no encontrado")

        if interest.is_attended:
            return (True, "El interés ya estaba marcado como atendido")

        interest.is_attended = True
        interest.attended_at = datetime.utcnow()

        logger.info(f"Marked interest {interest_id} as attended")
        return (True, "Interés marcado como atendido")

    except Exception as e:
        logger.error(f"Error marking interest {interest_id} as attended: {e}", exc_info=True)
        return (False, f"Error al marcar interés: {str(e)}")
```

**d. get_interest_by_id(interest_id) -> Optional[UserInterest]:**
```python
async def get_interest_by_id(self, interest_id: int) -> Optional[UserInterest]:
    """
    Obtiene un interés por su ID.

    Args:
        interest_id: ID del registro UserInterest

    Returns:
        Objeto UserInterest o None si no existe
    """
    try:
        stmt = select(UserInterest).where(UserInterest.id == interest_id)
        result = await self.session.execute(stmt)
        return result.scalar_one_or_none()
    except Exception as e:
        logger.error(f"Error getting interest {interest_id}: {e}", exc_info=True)
        return None
```

**e. get_interest_stats() -> Dict[str, Any]:**
```python
async def get_interest_stats(self) -> Dict[str, Any]:
    """
    Obtiene estadísticas de intereses.

    Returns:
        Diccionario con:
        - total_pending: Total de intereses pendientes
        - total_attended: Total de intereses atendidos
        - by_package_type: Dict con conteo por tipo de paquete
        - recent_interests: Lista de últimos 5 intereses (todos)

    Examples:
        >>> stats = await service.get_interest_stats()
        >>> print(f"Pendientes: {stats['total_pending']}")
    """
    try:
        # Total pending
        pending_stmt = select(UserInterest).where(UserInterest.is_attended == False)
        pending_result = await self.session.execute(pending_stmt)
        total_pending = len(pending_result.all())

        # Total attended
        attended_stmt = select(UserInterest).where(UserInterest.is_attended == True)
        attended_result = await self.session.execute(attended_stmt)
        total_attended = len(attended_result.all())

        # By package type
        stmt = select(UserInterest).join(ContentPackage)
        result = await self.session.execute(stmt)
        all_interests = result.scalars().all()

        by_package_type = {}
        for interest in all_interests:
            pkg_type = interest.package.category.value if interest.package else "unknown"
            by_package_type[pkg_type] = by_package_type.get(pkg_type, 0) + 1

        # Recent interests (last 5)
        recent_stmt = select(UserInterest).order_by(
            desc(UserInterest.created_at)
        ).limit(5)
        recent_result = await self.session.execute(recent_stmt)
        recent_interests = recent_result.scalars().all()

        return {
            "total_pending": total_pending,
            "total_attended": total_attended,
            "by_package_type": by_package_type,
            "recent_interests": recent_interests
        }

    except Exception as e:
        logger.error(f"Error getting interest stats: {e}", exc_info=True)
        return {
            "total_pending": 0,
            "total_attended": 0,
            "by_package_type": {},
            "recent_interests": []
        }
```

**f. Helper method _is_within_debounce_window(created_at):**
```python
def _is_within_debounce_window(self, created_at: datetime) -> bool:
    """
    Verifica si un interés está dentro de la ventana de debounce.

    Args:
        created_at: Fecha de creación del interés

    Returns:
        True si está dentro de la ventana (menos de 5 minutos)
    """
    window_expiry = created_at + timedelta(minutes=self.DEBOUNCE_WINDOW_MINUTES)
    return datetime.utcnow() < window_expiry
```

**g. get_user_interests(user_id, limit) -> List[UserInterest]:**
```python
async def get_user_interests(
    self,
    user_id: int,
    limit: int = 10
) -> List[UserInterest]:
    """
    Obtiene intereses de un usuario específico.

    Args:
        user_id: ID del usuario
        limit: Máximo de registros a retornar

    Returns:
        Lista de UserInterest ordenados por fecha (más reciente primero)
    """
    try:
        stmt = select(UserInterest).where(
            UserInterest.user_id == user_id
        ).order_by(
            desc(UserInterest.created_at)
        ).limit(limit)

        result = await self.session.execute(stmt)
        return result.scalars().all()

    except Exception as e:
        logger.error(f"Error getting interests for user {user_id}: {e}", exc_info=True)
        return []
```

**h. cleanup_old_attended(days_old) -> int:**
```python
async def cleanup_old_attended(self, days_old: int = 30) -> int:
    """
    Limpia intereses atendidos antiguos (background task).

    Args:
        days_old: Días de antigüedad para eliminar

    Returns:
        Número de registros eliminados

    Note:
        Este método es para tasks programados en background.
        No eliminar intereses pendientes (is_attended=False).
    """
    try:
        cutoff_date = datetime.utcnow() - timedelta(days=days_old)

        # Find old attended interests
        stmt = select(UserInterest).where(
            and_(
                UserInterest.is_attended == True,
                UserInterest.attended_at < cutoff_date
            )
        )
        result = await self.session.execute(stmt)
        old_interests = result.scalars().all()

        count = len(old_interests)
        for interest in old_interests:
            await self.session.delete(interest)

        logger.info(f"Cleaned up {count} attended interests older than {days_old} days")
        return count

    except Exception as e:
        logger.error(f"Error cleaning up old interests: {e}", exc_info=True)
        return 0
```

3. Add docstrings to class with full examples and patterns reference.

DO NOT:
- Send Telegram messages (service layer is business logic only)
- Create FSM states (handlers manage state)
- Use InlineKeyboardBuilder (message providers handle keyboards)
- Call session.commit() (SessionContextManager handles it)
  </action>
  <verify>
1. File created: bot/services/interest.py
2. InterestService class exists with __init__(session, bot)
3. Has 8+ methods: register_interest, get_interests, mark_as_attended, get_interest_by_id, get_interest_stats, get_user_interests, cleanup_old_attended, _is_within_debounce_window
4. DEBOUNCE_WINDOW_MINUTES = 5 constant defined
5. All methods are async (except _is_within_debounce_window)
6. All methods return tuples or appropriate types
7. No session.commit() calls
8. No Telegram message sending
9. Proper error handling with try/except
10. Logging at appropriate levels
  </verify>
  <done>
InterestService created with deduplication logic (5-minute window), filtering, pagination, and management methods, following established service pattern.
  </done>
</task>

<task type="auto">
  <name>Task 2: Register InterestService in ServiceContainer</name>
  <files>bot/services/__init__.py, bot/services/container.py</files>
  <action>
Update bot/services/__init__.py and bot/services/container.py to register InterestService:

1. In bot/services/__init__.py:
   - Add import: from bot.services.interest import InterestService
   - Add to __all__: "InterestService"

2. In bot/services/container.py:
   - Add import at top: from bot.services.interest import InterestService

3. In ServiceContainer class, add lazy loading property:
```python
@property
def interest(self) -> InterestService:
    """Interest service for managing user interests."""
    if "interest" not in self._services:
        self._services["interest"] = InterestService(self.session, self.bot)
        logger.debug(f"InterestService loaded (total services: {len(self._services)})")
    return self._services["interest"]
```

4. Update get_loaded_services() to include "interest" in the list if loaded.

Pattern reference: Follow existing pattern for content, stats, role_change services.

DO NOT:
- Modify other service properties
- Change ServiceContainer constructor signature
- Add eager loading (use lazy loading pattern)
  </action>
  <verify>
1. InterestService imported in __init__.py
2. InterestService in __all__ list
3. ServiceContainer has @property interest method
4. Uses lazy loading pattern (if "interest" not in self._services)
5. Logs when service is loaded
6. get_loaded_services() includes "interest" when loaded
7. Follows existing service pattern (content, stats)
  </verify>
  <done>
InterestService registered in ServiceContainer with lazy loading, accessible via container.interest.
  </done>
</task>

</tasks>

<verification>
Overall phase verification:
1. bot/services/interest.py exists with InterestService class
2. InterestService has 8+ async methods for interest management
3. 5-minute debounce window implemented (DEBOUNCE_WINDOW_MINUTES = 5)
4. register_interest returns (success, status, interest) with "debounce" detection
5. get_interests supports filters (is_attended, package_type, user_id) and pagination
6. mark_as_attended updates is_attended and attended_at
7. get_interest_stats returns pending/attended counts and breakdown by type
8. ServiceContainer.interest property exists with lazy loading
9. InterestService exported in __init__.py
10. No session.commit() calls or Telegram message sending
</verification>

<success_criteria>
1. InterestService can be imported: from bot.services.interest import InterestService
2. ServiceContainer can access: container.interest.register_interest(user_id, package_id)
3. register_interest returns (False, "debounce", interest) for clicks within 5 minutes
4. register_interest returns (True, "created", interest) for new interests
5. get_interests(is_attended=False) returns only pending interests
6. get_interests supports pagination (limit, offset) and sorting
7. mark_as_attended sets is_attended=True and attended_at=datetime
8. get_interest_stats returns dict with total_pending, total_attended, by_package_type
9. ServiceContainer lazy loads InterestService only when accessed
</success_criteria>

<output>
After completion, create `.planning/phases/08-interest-notification-system/08-01-SUMMARY.md`
</output>

---
phase: 08-interest-notification-system
plan: 03
type: execute
wave: 3
depends_on: [08-01, 08-02]
files_modified: [bot/services/message/admin_interest.py, bot/services/message/__init__.py, bot/services/message/admin_main.py]
autonomous: true

must_haves:
  truths:
    - "AdminMainMessages tiene mensaje de menÃº de intereses con filtros"
    - "AdminInterestMessages provider existe con mensajes para lista, detalle, filtros"
    - "BotÃ³n 'Intereses' aparece en menÃº principal de admin"
    - "Mensajes usan voz de Lucien con terminologÃ­a consistente"
  artifacts:
    - path: "bot/services/message/admin_interest.py"
      provides: "AdminInterestMessages provider with interest list, filters, detail, and empty state messages"
      min_lines: 200
      exports: ["interests_menu", "interests_list", "interests_empty", "interest_detail", "interest_filters", "interests_stats"]
  key_links:
    - from: "bot/handlers/admin/interests.py (plan 08-04)"
      to: "AdminInterestMessages"
      via: "ServiceContainer.message.admin.interest"
      pattern: "container\\.message\\.admin\\.interest\\."
    - from: "AdminMainMessages"
      to: "admin:interests callback"
      via: "main menu keyboard button"
      pattern: "admin:interests"
---

<objective>
Create AdminInterestMessages message provider with Lucien's voice for admin interest management UI (menu, list with filters, detail view, empty states, filter options, stats display).

Purpose: Centralize all interest admin messages following established message provider pattern (AdminMainMessages, AdminContentMessages) to ensure consistency with Lucien's sophisticated butler voice across the interest management interface.
Output: AdminInterestMessages class with 8+ message methods returning (text, keyboard) tuples in HTML format.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/08-interest-notification-system/08-CONTEXT.md

@bot/services/message/admin_main.py
@bot/services/message/admin_content.py
@bot/services/message/base.py
@bot/services/interest.py (InterestService from plan 08-01)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create AdminInterestMessages provider class</name>
  <files>bot/services/message/admin_interest.py</files>
  <action>
Create AdminInterestMessages class extending BaseMessageProvider following admin_main.py and admin_content.py pattern:

1. File structure:
```python
"""
Admin Interest Messages Provider - Interest management UI messages.

Provides messages for viewing and managing user interests in content packages.
All messages maintain Lucien's sophisticated mayordomo voice from docs/guia-estilo.md.
"""
import logging
from typing import Tuple, List, Optional, Dict, Any
from datetime import datetime

from aiogram.types import InlineKeyboardMarkup

from bot.services.message.base import BaseMessageProvider
from bot.utils.keyboards import create_inline_keyboard

logger = logging.getLogger(__name__)


class AdminInterestMessages(BaseMessageProvider):
    """
    Admin interest management messages provider.

    Voice Characteristics:
    - Admin = "custodio" or "guardiÃ¡n"
    - Interests = "expresiones de interÃ©s" or "manifestaciones de curiosidad"
    - Users = "visitantes" (Free) or "miembros del cÃ­rculo" (VIP)
    - Packages = "tesoros" or "colecciones"
    - Uses "usted", never "tÃº"
    - Emoji ğŸ”” always present for interest-related messages

    Stateless Design:
    - No session or bot stored as instance variables
    - All context passed as method parameters
    - Returns (text, keyboard) tuples for complete UI

    Interest List Pattern:
    - Default: Newest first (most recent at top)
    - Filters: Pending only, Attended only, By package type
    - Pagination: 10 items per page
    - Empty state: Friendly message with "No hay intereses pendientes"

    Examples:
        >>> provider = AdminInterestMessages()
        >>> text, kb = provider.interests_menu(
        ...     pending_count=5,
        ...     total_count=23
        ... )
        >>> 'ğŸ””' in text and 'pendientes' in text.lower()
        True
    """
```

2. Required methods:

**a. interests_menu(pending_count, total_count) -> main interests submenu:**
```python
def interests_menu(
    self,
    pending_count: int = 0,
    total_count: int = 0,
    user_id: Optional[int] = None,
    session_history: Optional["SessionMessageHistory"] = None
) -> Tuple[str, InlineKeyboardMarkup]:
    """
    Generate main interests management menu.

    Args:
        pending_count: Number of pending interests
        total_count: Total number of interests
        user_id: Optional user ID for session-aware selection
        session_history: Optional session history for context

    Returns:
        Tuple of (text, keyboard) for interests menu

    Voice Rationale:
        "Manifestaciones de interÃ©s" sounds elegant for "interests".
        "Pendientes de atenciÃ³n" for pending interests.
        References "tesoros" for packages to maintain narrative.

    Examples:
        >>> text, kb = provider.interests_menu(pending_count=5, total_count=23)
        >>> 'ğŸ””' in text and '5' in text and 'pendientes' in text.lower()
        True
    """
    # Weighted greeting variations
    greetings = [
        ("Los registros de curiosidad de los visitantes...", 0.5),
        ("Las manifestaciones de interÃ©s en el reino...", 0.3),
        ("El registro de interacciones con nuestros tesoros...", 0.2),
    ]

    greeting = self._choose_variant(
        [g[0] for g in greetings],
        weights=[g[1] for g in greetings],
        user_id=user_id,
        method_name="interests_menu",
        session_history=session_history
    )

    header = f"ğŸ© <b>Lucien:</b> <i>{greeting}</i>"

    # Conditional body based on counts
    if pending_count > 0:
        body = (
            f"<b>ğŸ”” GestiÃ³n de Intereses</b>\n\n"
            f"â³ <b>Pendientes de atenciÃ³n:</b> {pending_count}\n"
            f"ğŸ“Š <b>Total registrado:</b> {total_count}\n\n"
            f"<i>Varios visitantes han mostrado curiosidad por los tesoros de Diana. "
            f"Â¿Desea revisar las manifestaciones pendientes, custodio?</i>"
        )
    else:
        body = (
            f"<b>ğŸ”” GestiÃ³n de Intereses</b>\n\n"
            f"âœ… <b>Todo estÃ¡ atendido:</b> No hay intereses pendientes\n"
            f"ğŸ“Š <b>Total histÃ³rico:</b> {total_count}\n\n"
            f"<i>El reino estÃ¡ en orden. Puede revisar el histÃ³rico si lo desea.</i>"
        )

    text = self._compose(header, body)
    keyboard = self._interests_menu_keyboard(pending_count > 0)
    return text, keyboard
```

**b. interests_list(interests, page, total_pages, filter_type) -> paginated list:**
```python
def interests_list(
    self,
    interests: List[Any],
    page: int = 1,
    total_pages: int = 1,
    filter_type: str = "all",
    user_id: Optional[int] = None
) -> Tuple[str, InlineKeyboardMarkup]:
    """
    Generate paginated interests list.

    Args:
        interests: List of UserInterest objects
        page: Current page number (1-indexed)
        total_pages: Total number of pages
        filter_type: Current filter (all, pending, attended, vip_premium, vip_content, free_content)

    Returns:
        Tuple of (text, keyboard) with interest list

    Voice Rationale:
        "Registro de manifestaciones" for interest list.
        Filter names in Spanish: "Pendientes", "Atendidos", "Todos".
        User role: "Miembro VIP" or "Visitante Free".

    Examples:
        >>> text, kb = provider.interests_list(
        ...     interests=[interest1, interest2],
        ...     page=1,
        ...     total_pages=2
        ... )
        >>> 'PÃ¡gina 1/2' in text
        True
    """
    # Header based on filter
    filter_titles = {
        "all": "ğŸ“‹ Todos los Intereses",
        "pending": "â³ Intereses Pendientes",
        "attended": "âœ… Intereses Atendidos",
        "vip_premium": "ğŸ’ Premium Exclusivo",
        "vip_content": "ğŸ‘‘ Contenido VIP",
        "free_content": "ğŸŒ¸ Contenido Gratuito"
    }

    title = filter_titles.get(filter_type, "ğŸ“‹ Intereses")

    # Build interest list
    if not interests:
        body = self._interests_empty_message(filter_type)
    else:
        items = []
        for idx, interest in enumerate(interests, start=(page - 1) * 10 + 1):
            user = interest.user
            package = interest.package

            # Format user
            username = f"@{user.username}" if user.username else f"Usuario {user.id}"
            user_role = "ğŸ‘‘ VIP" if hasattr(user, 'role') and user.role.value == "VIP" else "ğŸŒ¸ Free"

            # Format package
            pkg_emoji = {
                "VIP_PREMIUM": "ğŸ’",
                "VIP_CONTENT": "ğŸ‘‘",
                "FREE_CONTENT": "ğŸŒ¸"
            }.get(package.category.value if hasattr(package.category, 'value') else str(package.category), "ğŸ“¦")

            # Format status
            status_icon = "â³" if not interest.is_attended else "âœ…"
            time_str = interest.created_at.strftime("%d/%m %H:%M")

            item_text = (
                f"{status_icon} <b>#{idx}</b> {username} ({user_role})\n"
                f"    {pkg_emoji} {package.name}\n"
                f"    ğŸ•’ {time_str}"
            )

            items.append(item_text)

        body = (
            f"{title}\n\n"
            f"{chr(10).join(items)}\n\n"
            f"<i>PÃ¡gina {page}/{total_pages}</i>"
        )

    text = f"ğŸ© <b>Lucien:</b>\n\n{body}"
    keyboard = self._interests_list_keyboard(page, total_pages, filter_type)
    return text, keyboard
```

**c. interests_empty(filter_type) -> empty state message:**
```python
def interests_empty(self, filter_type: str = "all") -> Tuple[str, InlineKeyboardMarkup]:
    """
    Generate empty state message when no interests match filter.

    Args:
        filter_type: Current filter (affects message content)

    Returns:
        Tuple of (text, keyboard) with friendly empty state

    Examples:
        >>> text, kb = provider.interests_empty("pending")
        >>> 'vacÃ­o' in text.lower() or 'sin intereses' in text.lower()
        True
    """
    filter_messages = {
        "pending": "No hay intereses pendientes de atenciÃ³n en este momento.",
        "attended": "No hay intereses atendidos con este filtro aÃºn.",
        "vip_premium": "Nadie ha mostrado interÃ©s en los tesoros Premium aÃºn.",
        "vip_content": "No hay intereses registrados en contenido VIP.",
        "free_content": "No hay intereses en contenido gratuito."
    }

    message = filter_messages.get(
        filter_type,
        "No se encontraron intereses con los filtros seleccionados."
    )

    body = (
        f"<b>ğŸ”” Registro VacÃ­o</b>\n\n"
        f"<i>{message}</i>\n\n"
        f"<i>Â¿Desea revisar otras categorÃ­as, custodio?</i>"
    )

    text = f"ğŸ© <b>Lucien:</b>\n\n{body}"
    keyboard = self._interests_empty_keyboard()
    return text, keyboard
```

**d. interest_detail(interest) -> single interest details:**
```python
def interest_detail(self, interest: Any) -> Tuple[str, InlineKeyboardMarkup]:
    """
    Generate detailed view of single interest.

    Args:
        interest: UserInterest object with loaded user and package relationships

    Returns:
        Tuple of (text, keyboard) with full interest details

    Examples:
        >>> text, kb = provider.interest_detail(interest)
        >>> 'Detalles' in text or 'InformaciÃ³n' in text
        True
    """
    user = interest.user
    package = interest.package

    # Format user info
    username_display = f"@{user.username}" if user.username else "Sin username"
    full_name = f"{user.first_name or ''} {user.last_name or ''}".strip() or "Sin nombre"
    user_role = "ğŸ‘‘ Miembro VIP" if hasattr(user, 'role') and user.role.value == "VIP" else "ğŸŒ¸ Visitante Free"

    # Format package info
    pkg_type_emoji = {
        "VIP_PREMIUM": "ğŸ’ Premium Exclusivo",
        "VIP_CONTENT": "ğŸ‘‘ Contenido VIP",
        "FREE_CONTENT": "ğŸŒ¸ Contenido Gratuito"
    }.get(package.category.value if hasattr(package.category, 'value') else str(package.category), "ğŸ“¦")

    # Format status
    if interest.is_attended:
        status = f"âœ… <b>Atendido</b> el {interest.attended_at.strftime('%d/%m/%Y %H:%M')}"
    else:
        status = "â³ <b>Pendiente de atenciÃ³n</b>"

    # Build detail text
    body = (
        f"<b>ğŸ”” Detalles del InterÃ©s</b>\n\n"
        f"<b>ğŸ‘¤ Usuario:</b>\n"
        f"   {full_name} ({username_display})\n"
        f"   ID: {user.id}\n"
        f"   {user_role}\n\n"
        f"<b>ğŸ“¦ Paquete de InterÃ©s:</b>\n"
        f"   {pkg_type_emoji}\n"
        f"   <b>{package.name}</b>\n"
    )

    if package.description:
        body += f"   ğŸ“ {package.description}\n"

    if package.price is not None:
        body += f"   ğŸ’° ${package.price:.2f}\n"

    body += (
        f"\n<b>ğŸ“Š Estado:</b> {status}\n"
        f"<b>ğŸ•’ Registrado:</b> {interest.created_at.strftime('%d/%m/%Y %H:%M')}\n\n"
        f"<i>ID de registro: #{interest.id}</i>"
    )

    text = f"ğŸ© <b>Lucien:</b>\n\n{body}"
    keyboard = self._interest_detail_keyboard(interest.id, interest.is_attended)
    return text, keyboard
```

**e. interests_filters(current_filter) -> filter selection keyboard:**
```python
def interests_filters(self, current_filter: str = "all") -> Tuple[str, InlineKeyboardMarkup]:
    """
    Generate filter selection message.

    Args:
        current_filter: Currently active filter

    Returns:
        Tuple of (text, keyboard) with filter options

    Examples:
        >>> text, kb = provider.interests_filters("pending")
        >>> 'filtro' in text.lower() or 'filtrar' in text.lower()
        True
    """
    body = (
        f"<b>ğŸ” Filtros de Intereses</b>\n\n"
        f"<i>Seleccione un criterio para filtrar el registro de manifestaciones...</i>\n\n"
    )

    filter_descriptions = {
        "all": "ğŸ“‹ <b>Todos</b> - Muestra todos los intereses",
        "pending": "â³ <b>Pendientes</b> - Solo intereses sin atender",
        "attended": "âœ… <b>Atendidos</b> - Solo intereses ya atendidos",
        "vip_premium": "ğŸ’ <b>Premium</b> - Solo tesoros Premium Exclusivo",
        "vip_content": "ğŸ‘‘ <b>VIP</b> - Solo contenido para miembros",
        "free_content": "ğŸŒ¸ <b>Gratuito</b> - Solo contenido del jardÃ­n pÃºblico"
    }

    for filter_key, description in filter_descriptions.items():
        icon = "âœ…" if filter_key == current_filter else "âšª"
        body += f"{icon} {description}\n"

    body += f"\n<i>Filtro actual: <b>{current_filter.upper()}</b></i>"

    text = f"ğŸ© <b>Lucien:</b>\n\n{body}"
    keyboard = self._interests_filters_keyboard()
    return text, keyboard
```

**f. interests_stats(stats) -> statistics display:**
```python
def interests_stats(self, stats: Dict[str, Any]) -> Tuple[str, InlineKeyboardMarkup]:
    """
    Generate interests statistics display.

    Args:
        stats: Dict from InterestService.get_interest_stats() with:
            - total_pending: int
            - total_attended: int
            - by_package_type: Dict[str, int]
            - recent_interests: List[UserInterest]

    Returns:
        Tuple of (text, keyboard) with statistics

    Examples:
        >>> stats = await service.get_interest_stats()
        >>> text, kb = provider.interests_stats(stats)
        >>> 'EstadÃ­sticas' in text or 'Resumen' in text
        True
    """
    pending = stats.get("total_pending", 0)
    attended = stats.get("total_attended", 0)
    total = pending + attended
    by_type = stats.get("by_package_type", {})
    recent = stats.get("recent_interests", [])

    body = (
        f"<b>ğŸ“Š EstadÃ­sticas de Intereses</b>\n\n"
        f"ğŸ“ˆ <b>Total Registrado:</b> {total}\n"
        f"â³ <b>Pendientes:</b> {pending}\n"
        f"âœ… <b>Atendidos:</b> {attended}\n\n"
    )

    # By package type
    if by_type:
        body += "<b>ğŸ·ï¸ Por Tipo de Paquete:</b>\n"
        type_names = {
            "VIP_PREMIUM": "ğŸ’ Premium",
            "VIP_CONTENT": "ğŸ‘‘ VIP",
            "FREE_CONTENT": "ğŸŒ¸ Gratuito"
        }
        for pkg_type, count in by_type.items():
            name = type_names.get(pkg_type, pkg_type)
            body += f"   {name}: {count}\n"
        body += "\n"

    # Recent interests
    if recent:
        body += "<b>ğŸ•’ Manifestaciones Recientes:</b>\n"
        for idx, interest in enumerate(recent[:5], 1):
            username = f"@{interest.user.username}" if interest.user.username else f"User {interest.user.id}"
            time_str = interest.created_at.strftime("%d/%m %H:%M")
            body += f"   {idx}. {username} - {interest.package.name} ({time_str})\n"

    text = f"ğŸ© <b>Lucien:</b>\n\n{body}"
    keyboard = self._interests_stats_keyboard()
    return text, keyboard
```

**g. mark_attended_confirm(interest) -> confirmation dialog:**
```python
def mark_attended_confirm(self, interest: Any) -> Tuple[str, InlineKeyboardMarkup]:
    """
    Generate confirmation dialog for marking interest as attended.

    Args:
        interest: UserInterest object

    Returns:
        Tuple of (text, keyboard) with confirmation

    Examples:
        >>> text, kb = provider.mark_attended_confirm(interest)
        >>> 'Â¿marcar' in text.lower() or 'confirmar' in text.lower()
        True
    """
    username = f"@{interest.user.username}" if interest.user.username else f"Usuario {interest.user.id}"
    package_name = interest.package.name

    body = (
        f"<b>âœ… Marcar como Atendido</b>\n\n"
        f"<i>Â¿Confirma que desea marcar esta manifestaciÃ³n como atendida?</i>\n\n"
        f"<b>Usuario:</b> {username}\n"
        f"<b>Paquete:</b> {package_name}\n\n"
        f"<i>El interÃ©s serÃ¡ archivado y removido de la lista principal.</i>"
    )

    text = f"ğŸ© <b>Lucien:</b>\n\n{body}"
    keyboard = self._mark_attended_confirm_keyboard(interest.id)
    return text, keyboard
```

**h. mark_attended_success(interest) -> success message:**
```python
def mark_attended_success(self, interest: Any) -> Tuple[str, InlineKeyboardMarkup]:
    """
    Generate success message after marking as attended.

    Args:
        interest: UserInterest object (now attended)

    Returns:
        Tuple of (text, keyboard) with success confirmation

    Examples:
        >>> text, kb = provider.mark_attended_success(interest)
        >>> 'âœ…' in text or 'atendido' in text.lower()
        True
    """
    username = f"@{interest.user.username}" if interest.user.username else f"Usuario {interest.user.id}"
    package_name = interest.package.name
    time_str = interest.attended_at.strftime("%H:%M") if interest.attended_at else "ahora"

    body = (
        f"<b>âœ… InterÃ©s Marcado como Atendido</b>\n\n"
        f"<i>La manifestaciÃ³n de curiosidad ha sido registrada como atendida.</i>\n\n"
        f"<b>Usuario:</b> {username}\n"
        f"<b>Paquete:</b> {package_name}\n"
        f"<b>Hora de atenciÃ³n:</b> {time_str}\n\n"
        f"<i>El registro ha sido archivado correctamente.</i>"
    )

    text = f"ğŸ© <b>Lucien:</b>\n\n{body}"
    keyboard = self._mark_attended_success_keyboard()
    return text, keyboard
```

3. Add keyboard helper methods:
```python
def _interests_menu_keyboard(self, has_pending: bool) -> InlineKeyboardMarkup:
    """Generate keyboard for interests menu."""
    buttons = [
        [{"text": "â³ Ver Pendientes", "callback_data": "admin:interests:list:pending"}],
        [{"text": "ğŸ“Š Ver EstadÃ­sticas", "callback_data": "admin:interests:stats"}],
        [{"text": "ğŸ” Cambiar Filtro", "callback_data": "admin:interests:filters"}],
        [{"text": "ğŸ”™ Volver al MenÃº Principal", "callback_data": "admin:main"}]
    ]
    return create_inline_keyboard(buttons)

def _interests_list_keyboard(self, page: int, total_pages: int, filter_type: str) -> InlineKeyboardMarkup:
    """Generate keyboard for paginated interests list."""
    buttons = []

    # Filter row
    buttons.append([{"text": "ğŸ” Filtros", "callback_data": f"admin:interests:filters:{filter_type}"}])

    # Pagination row
    nav_buttons = []
    if page > 1:
        nav_buttons.append({"text": "â¬…ï¸ Anterior", "callback_data": f"admin:interests:page:{page-1}:{filter_type}"})
    if page < total_pages:
        nav_buttons.append({"text": "â¡ï¸ Siguiente", "callback_data": f"admin:interests:page:{page+1}:{filter_type}"})
    if nav_buttons:
        buttons.append(nav_buttons)

    # Navigation
    buttons.extend([
        [{"text": "ğŸ“Š EstadÃ­sticas", "callback_data": "admin:interests:stats"}],
        [{"text": "ğŸ”™ Volver al MenÃº", "callback_data": "admin:interests"}]
    ])

    return create_inline_keyboard(buttons)

def _interest_detail_keyboard(self, interest_id: int, is_attended: bool) -> InlineKeyboardMarkup:
    """Generate keyboard for interest detail view."""
    buttons = []

    if not is_attended:
        buttons.append([
            {"text": "âœ… Marcar como Atendido", "callback_data": f"admin:interest:attend:{interest_id}"}
        ])

    buttons.extend([
        [{"text": "ğŸ‘¤ Ver Usuario", "callback_data": f"admin:user:view:{interest_id}"}],
        [{"text": "ğŸ”™ Volver a la Lista", "callback_data": "admin:interests:list:all"}]
    ])

    return create_inline_keyboard(buttons)

# Add other helper methods as needed...
```

DO NOT:
- Add database queries in message provider (stateless - data passed as parameters)
- Create FSM states (handlers manage state)
- Use hardcoded InlineKeyboardBuilder (use create_inline_keyboard helper)
- Add session/bot to __init__ (follow BaseMessageProvider stateless pattern)
  </action>
  <verify>
1. File created: bot/services/message/admin_interest.py
2. Class AdminInterestMessages extends BaseMessageProvider
3. Has 8+ message methods: interests_menu, interests_list, interests_empty, interest_detail, interests_filters, interests_stats, mark_attended_confirm, mark_attended_success
4. All methods return (text, keyboard) tuples
5. Uses create_inline_keyboard() for all keyboard creation
6. No database queries or session injection
7. Lucien's Spanish terminology used throughout
8. Emoji ğŸ”” present in all messages
9. Filter types: all, pending, attended, vip_premium, vip_content, free_content
10. Pagination support (page, total_pages parameters)
  </verify>
  <done>
AdminInterestMessages class created with all interest UI messages, following BaseMessageProvider pattern, ready for handler integration.
  </done>
</task>

<task type="auto">
  <name>Task 2: Register AdminInterestMessages in ServiceContainer</name>
  <files>bot/services/message/__init__.py</files>
  <action>
Update bot/services/message/__init__.py to register AdminInterestMessages:

1. Import AdminInterestMessages:
```python
from bot.services.message.admin_interest import AdminInterestMessages
```

2. In MessageProviderFactory._create_admin_providers() method:
   - Add instantiation: admin_interest = AdminInterestMessages()
   - Return in providers dict with key "admin_interest"

3. In MessageProviderFactory property (admin.interest):
   - Add @property lazy loading method following admin.content pattern
```python
@property
def interest(self) -> AdminInterestMessages:
    """Admin interest management messages."""
    return self._providers["admin"]["admin_interest"]
```

DO NOT:
- Modify other providers (admin_main, admin_content, admin_vip, admin_free)
- Add database queries or state to AdminInterestMessages instantiation
- Change MessageProviderFactory constructor signature
  </action>
  <verify>
1. AdminInterestMessages imported in __init__.py
2. Registered in _create_admin_providers()
3. ServiceContainer.message.admin.interest property exists
4. Returns AdminInterestMessages instance
5. Follows existing admin provider pattern
  </verify>
  <done>
AdminInterestMessages registered in ServiceContainer, accessible via container.message.admin.interest, ready for handler usage.
  </done>
</task>

<task type="auto">
  <name>Task 3: Add Interests button to admin main menu</name>
  <files>bot/services/message/admin_main.py</files>
  <action>
Update admin_main.py to include "Intereses" button in main menu:

1. In _admin_main_menu_keyboard() method, add button:
```python
[{"text": "ğŸ”” Intereses", "callback_data": "admin:interests"}]
```

2. Button placement: After "ğŸ“¦ Paquetes de Contenido" and before "âš™ï¸ CalibraciÃ³n del Reino"

3. Verify button order is logical (grouped with management features)

DO NOT:
- Remove or modify existing menu buttons
- Change the callback pattern format
- Add duplicate buttons
  </action>
  <verify>
1. "ğŸ”” Intereses" button appears in _admin_main_menu_keyboard()
2. Button uses callback_data "admin:interests"
3. Button placement is logical (after content, before config)
4. Existing menu buttons unchanged
5. Button appears in both configured and unconfigured states
  </verify>
  <done>
Interests menu button added to admin main menu, enabling navigation to interest management interface.
  </done>
</task>

</tasks>

<verification>
Overall phase verification:
1. AdminInterestMessages class exists with 8+ message methods
2. Registered in ServiceContainer.message.admin.interest
3. "ğŸ”” Intereses" button appears in admin main menu
4. All messages use Lucien's Spanish terminology and voice
5. All keyboards follow admin:interests:* callback pattern
6. No database queries in message provider (stateless)
7. Follows BaseMessageProvider pattern consistently
8. Supports filters: all, pending, attended, vip_premium, vip_content, free_content
9. Supports pagination with page and total_pages parameters
10. Empty state messages provided for all filter types
</verification>

<success_criteria>
1. Admin can open /admin and see "ğŸ”” Intereses" button
2. Clicking button navigates to interests menu (callback handler to be added in plan 08-04)
3. All message methods return valid (text, keyboard) tuples
4. ServiceContainer can access message provider via container.message.admin.interest
5. Messages use consistent Lucien voice (formal butler, Spanish terminology)
6. Filter system supports 6 filter types
7. Pagination parameters (page, total_pages) supported in interests_list
</success_criteria>

<output>
After completion, create `.planning/phases/08-interest-notification-system/08-03-SUMMARY.md`
</output>

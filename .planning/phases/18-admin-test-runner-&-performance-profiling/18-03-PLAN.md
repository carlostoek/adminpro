---
wave: 2
depends_on: 18-01
files_modified:
  - scripts/profile_handler.py
  - bot/handlers/admin/profile.py
  - bot/handlers/admin/__init__.py
  - bot/utils/profiler.py
  - requirements.txt
autonomous: true
---

# Plan 18-03: Performance Profiling with pyinstrument Integration

## Objective

Integrate pyinstrument for performance profiling of bot handlers and services, allowing administrators to identify bottlenecks and optimize slow code paths through both CLI scripts and Telegram commands.

## Context

As the bot grows in complexity with more handlers, services, and database queries, performance bottlenecks can emerge. Currently, there's no systematic way to identify slow handlers or N+1 query problems. This plan adds profiling capabilities that integrate seamlessly with the existing codebase.

**Current State:**
- Handlers in `bot/handlers/` with varying complexity
- Services in `bot/services/` with database operations
- No performance monitoring or profiling tools
- SQLAlchemy queries not logged or analyzed

**Why This Matters:**
- Identifies slow handlers before users complain
- Detects N+1 query problems that waste database resources
- Provides data-driven optimization decisions
- Allows benchmarking before/after optimizations

## Success Criteria

1. `python scripts/profile_handler.py <handler_path>` profiles any handler
2. `/profile <handler_name>` command runs profiling from Telegram
3. Profiler shows top N slowest functions with call stack
4. Profiling results include database query count and time
5. Async handlers profiled correctly without blocking

## Tasks

### Task 1: Add pyinstrument to Requirements

**File:** `requirements.txt`

Add the profiling library:

```
# Performance Profiling
pyinstrument==4.6.2
```

### Task 2: Create Profiler Utility Module

**File:** `bot/utils/profiler.py`

Create a wrapper for pyinstrument with async support:

```python
"""
Performance Profiler Utilities

Wrapper para pyinstrument con soporte async, integracion con
SQLAlchemy para conteo de queries, y formateo de resultados.
"""

import asyncio
import functools
import logging
from contextlib import contextmanager
from dataclasses import dataclass, field
from typing import Any, Callable, Dict, List, Optional, TypeVar

from pyinstrument import Profiler
from sqlalchemy import event
from sqlalchemy.ext.asyncio import AsyncSession

logger = logging.getLogger(__name__)

F = TypeVar("F", bound=Callable[..., Any])


@dataclass
class ProfileResult:
    """Resultado de una sesion de profiling."""
    duration_ms: float
    query_count: int
    query_time_ms: float
    top_functions: List[Dict[str, Any]]
    html_output: Optional[str] = None
    text_output: Optional[str] = None

    def summary(self, limit: int = 5) -> str:
        """Resumen en texto plano."""
        lines = [
            f"Duration: {self.duration_ms:.2f}ms",
            f"Queries: {self.query_count} ({self.query_time_ms:.2f}ms)",
            "",
            "Top Functions:"
        ]
        for func in self.top_functions[:limit]:
            lines.append(f"  {func['name']}: {func['time_ms']:.2f}ms")
        return "\n".join(lines)


class AsyncProfiler:
    """
    Profiler con soporte para funciones async.

    Envuelve pyinstrument para manejar correctamente
    el profiling de codigo asincrono.
    """

    def __init__(self):
        self._profiler = Profiler()
        self._query_stats = {"count": 0, "time_ms": 0.0}

    def _attach_query_monitor(self, session: Optional[AsyncSession] = None):
        """Attach SQLAlchemy event listeners para contar queries."""
        @event.listens_for(AsyncSession, "do_orm_execute")
        def on_orm_execute(execute_state):
            self._query_stats["count"] += 1

    async def profile_async(
        self,
        coro: Callable,
        *args,
        session: Optional[AsyncSession] = None,
        **kwargs
    ) -> ProfileResult:
        """
        Profile una corrutina.

        Args:
            coro: Funcion async a profilear
            args: Argumentos posicionales
            session: Sesion SQLAlchemy para monitoreo
            kwargs: Argumentos nombrados

        Returns:
            ProfileResult con estadisticas
        """
        if session:
            self._attach_query_monitor(session)

        self._profiler.start()
        start_time = asyncio.get_event_loop().time()

        try:
            result = await coro(*args, **kwargs)
        finally:
            self._profiler.stop()
            duration = (asyncio.get_event_loop().time() - start_time) * 1000

        # Parse results
        session = self._profiler.last_session

        return ProfileResult(
            duration_ms=duration,
            query_count=self._query_stats["count"],
            query_time_ms=self._query_stats["time_ms"],
            top_functions=self._extract_top_functions(session),
            html_output=self._profiler.output_html(),
            text_output=self._profiler.output_text()
        )

    def _extract_top_functions(self, session) -> List[Dict[str, Any]]:
        """Extrae las funciones mas lentas de la sesion."""
        functions = []
        for frame in session.root_frame().self_and_descendants():
            if frame.time() > 0.001:  # Only functions > 1ms
                functions.append({
                    "name": frame.function,
                    "file": frame.file_path,
                    "line": frame.line_no,
                    "time_ms": frame.time() * 1000,
                    "calls": frame.call_count
                })
        return sorted(functions, key=lambda x: x["time_ms"], reverse=True)[:10]


@contextmanager
def profile_block(name: str = "block"):
    """
    Context manager para profilear un bloque de codigo.

    Uso:
        with profile_block("database_query"):
            result = await session.execute(query)
    """
    profiler = Profiler()
    profiler.start()
    try:
        yield profiler
    finally:
        profiler.stop()
        logger.debug(f"Profile [{name}]: {profiler.last_session.duration * 1000:.2f}ms")


def profile_handler(func: F) -> F:
    """
    Decorator para profilear handlers automaticamente.

    Solo activa profiling si la variable de entorno
    PROFILE_HANDLERS esta configurada.

    Uso:
        @profile_handler
        async def cmd_admin(message: Message, session: AsyncSession):
            ...
    """
    @functools.wraps(func)
    async def wrapper(*args, **kwargs):
        import os
        if not os.getenv("PROFILE_HANDLERS"):
            return await func(*args, **kwargs)

        profiler = AsyncProfiler()
        session = kwargs.get("session")

        result = await profiler.profile_async(
            func, *args, session=session, **kwargs
        )

        logger.info(f"Profile [{func.__name__}]: {result.summary()}")
        return result

    return wrapper


class HandlerProfiler:
    """
    Profiling especifico para handlers de aiogram.

    Mide tiempo total, tiempo de DB, y numero de queries.
    """

    def __init__(self):
        self.stats: Dict[str, List[float]] = {}

    async def profile_handler_execution(
        self,
        handler: Callable,
        event,
        session: AsyncSession
    ) -> tuple[Any, ProfileResult]:
        """
        Ejecuta un handler y recolecta estadisticas.

        Returns:
            Tuple de (handler_result, profile_result)
        """
        profiler = AsyncProfiler()

        result = await profiler.profile_async(
            handler,
            event,
            session=session
        )

        # Store stats
        handler_name = handler.__name__
        if handler_name not in self.stats:
            self.stats[handler_name] = []
        self.stats[handler_name].append(result.duration_ms)

        return result, profiler

    def get_slowest_handlers(self, limit: int = 5) -> List[Dict[str, Any]]:
        """Retorna los handlers mas lentos en promedio."""
        averages = [
            {
                "name": name,
                "avg_ms": sum(times) / len(times),
                "max_ms": max(times),
                "calls": len(times)
            }
            for name, times in self.stats.items()
        ]
        return sorted(averages, key=lambda x: x["avg_ms"], reverse=True)[:limit]
```

### Task 3: Create CLI Profiling Script

**File:** `scripts/profile_handler.py`

Create a command-line tool for profiling specific handlers:

```python
#!/usr/bin/env python3
"""
CLI Handler Profiler

Profilea handlers especificos del bot para identificar
bottlenecks de rendimiento.

Uso:
    python scripts/profile_handler.py bot.handlers.admin.main.cmd_admin
    python scripts/profile_handler.py bot.handlers.user.start.cmd_start --iterations=5
    python scripts/profile_handler.py --list
"""

import argparse
import asyncio
import importlib
import sys
from pathlib import Path

# Add project root to path
sys.path.insert(0, str(Path(__file__).parent.parent))

from bot.utils.profiler import AsyncProfiler, ProfileResult


def import_handler(handler_path: str):
    """Importa un handler por su path completo."""
    module_path, func_name = handler_path.rsplit(".", 1)
    module = importlib.import_module(module_path)
    return getattr(module, func_name)


def list_available_handlers():
    """Lista handlers disponibles para profiling."""
    handlers = [
        "bot.handlers.admin.main.cmd_admin",
        "bot.handlers.admin.vip.cmd_vip_panel",
        "bot.handlers.admin.free.cmd_free_panel",
        "bot.handlers.admin.users.cmd_users",
        "bot.handlers.user.start.cmd_start",
        "bot.handlers.user.vip_entry.cmd_vip",
        "bot.handlers.user.free_flow.cmd_free",
    ]
    print("Handlers disponibles:")
    for h in handlers:
        print(f"  - {h}")


async def profile_handler(
    handler_path: str,
    iterations: int = 1,
    output_format: str = "text"
) -> ProfileResult:
    """
    Profilea un handler especifico.

    Args:
        handler_path: Path completo al handler (module.submodule.func)
        iterations: Numero de veces a ejecutar
        output_format: 'text', 'html', o 'json'

    Returns:
        ProfileResult con estadisticas agregadas
    """
    handler = import_handler(handler_path)
    profiler = AsyncProfiler()

    # Mock objects for handler
    from unittest.mock import AsyncMock, MagicMock

    mock_message = MagicMock()
    mock_message.from_user.id = 123456
    mock_message.from_user.username = "test_user"
    mock_message.answer = AsyncMock()
    mock_message.bot = AsyncMock()

    mock_session = MagicMock()

    print(f"Profileando {handler_path} ({iterations} iteraciones)...")

    results = []
    for i in range(iterations):
        print(f"  Iteracion {i + 1}/{iterations}...")

        # Create fresh mocks for each iteration
        mock_message.answer.reset_mock()

        result = await profiler.profile_async(
            handler,
            mock_message,
            session=mock_session
        )
        results.append(result)

    # Aggregate results
    aggregated = ProfileResult(
        duration_ms=sum(r.duration_ms for r in results) / len(results),
        query_count=max(r.query_count for r in results),
        query_time_ms=sum(r.query_time_ms for r in results) / len(results),
        top_functions=results[0].top_functions,  # Use first iteration's functions
        text_output=results[0].text_output,
        html_output=results[0].html_output
    )

    return aggregated


def print_results(result: ProfileResult, format_type: str):
    """Imprime resultados en el formato solicitado."""
    if format_type == "text":
        print("\n" + "=" * 60)
        print("RESULTADOS DEL PROFILING")
        print("=" * 60)
        print(result.summary(limit=10))

        if result.text_output:
            print("\n" + "-" * 60)
            print("DETALLE COMPLETO:")
            print("-" * 60)
            # Print first 50 lines
            lines = result.text_output.split("\n")[:50]
            print("\n".join(lines))

    elif format_type == "html":
        output_file = "profile_report.html"
        if result.html_output:
            Path(output_file).write_text(result.html_output)
            print(f"Reporte HTML guardado: {output_file}")
        else:
            print("No hay output HTML disponible")

    elif format_type == "json":
        import json
        data = {
            "duration_ms": result.duration_ms,
            "query_count": result.query_count,
            "query_time_ms": result.query_time_ms,
            "top_functions": result.top_functions
        }
        print(json.dumps(data, indent=2))


async def main():
    parser = argparse.ArgumentParser(
        description="Profilea handlers del bot de Telegram"
    )
    parser.add_argument(
        "handler",
        nargs="?",
        help="Path completo al handler (ej: bot.handlers.admin.main.cmd_admin)"
    )
    parser.add_argument(
        "--list",
        action="store_true",
        help="Listar handlers disponibles"
    )
    parser.add_argument(
        "--iterations",
        type=int,
        default=1,
        help="Numero de iteraciones (default: 1)"
    )
    parser.add_argument(
        "--format",
        choices=["text", "html", "json"],
        default="text",
        help="Formato de salida"
    )
    parser.add_argument(
        "--output",
        help="Archivo de salida (para HTML)"
    )

    args = parser.parse_args()

    if args.list:
        list_available_handlers()
        return

    if not args.handler:
        parser.print_help()
        return

    try:
        result = await profile_handler(
            args.handler,
            iterations=args.iterations,
            output_format=args.format
        )
        print_results(result, args.format)

        if args.output and args.format == "html" and result.html_output:
            Path(args.output).write_text(result.html_output)
            print(f"\nGuardado en: {args.output}")

    except ImportError as e:
        print(f"Error importando handler: {e}")
        sys.exit(1)
    except Exception as e:
        print(f"Error durante profiling: {e}")
        import traceback
        traceback.print_exc()
        sys.exit(1)


if __name__ == "__main__":
    asyncio.run(main())
```

### Task 4: Create Telegram Profiling Handler

**File:** `bot/handlers/admin/profile.py`

Create the admin handler for profiling via Telegram:

```python
"""
Admin Performance Profiling Handler

Handler para ejecutar profiling de handlers desde Telegram.
Solo accesible para administradores.
"""

import logging
import tempfile
from pathlib import Path

from aiogram import Router, F
from aiogram.filters import Command
from aiogram.types import Message, CallbackQuery, FSInputFile
from sqlalchemy.ext.asyncio import AsyncSession

from bot.middlewares import AdminAuthMiddleware
from bot.utils.profiler import AsyncProfiler, HandlerProfiler

logger = logging.getLogger(__name__)

profile_router = Router(name="admin_profile")
profile_router.message.middleware(AdminAuthMiddleware())
profile_router.callback_query.middleware(AdminAuthMiddleware())

# Registry of profilable handlers
HANDLER_REGISTRY = {
    "admin": "bot.handlers.admin.main.cmd_admin",
    "vip_panel": "bot.handlers.admin.vip.cmd_vip_panel",
    "free_panel": "bot.handlers.admin.free.cmd_free_panel",
    "users": "bot.handlers.admin.users.cmd_users",
    "start": "bot.handlers.user.start.cmd_start",
    "vip_entry": "bot.handlers.user.vip_entry.cmd_vip",
    "free_flow": "bot.handlers.user.free_flow.cmd_free",
}


@profile_router.message(Command("profile"))
async def cmd_profile(message: Message, session: AsyncSession):
    """
    Ejecuta profiling de un handler especifico.

    Uso:
        /profile - Lista handlers disponibles
        /profile admin - Profilea el handler admin
        /profile start --iterations=3 - Profilea con 3 iteraciones

    Args:
        message: Mensaje del comando
        session: Sesion de BD
    """
    args = message.text.split()[1:] if message.text else []

    # List available handlers
    if not args or args[0] in ["list", "--list", "-l"]:
        handlers_text = "\n".join(
            f"  ‚Ä¢ <code>{key}</code> - {path}"
            for key, path in HANDLER_REGISTRY.items()
        )
        await message.answer(
            f"üìä <b>Handlers disponibles para profiling:</b>\n\n"
            f"{handlers_text}\n\n"
            f"<i>Uso: /profile &lt;handler_name&gt; [--iterations=N]</i>",
            parse_mode="HTML"
        )
        return

    handler_key = args[0]
    if handler_key not in HANDLER_REGISTRY:
        await message.answer(
            f"‚ùå <b>Handler no encontrado:</b> {handler_key}\n\n"
            f"Usa <code>/profile</code> para ver los disponibles.",
            parse_mode="HTML"
        )
        return

    # Parse iterations
    iterations = 1
    for arg in args[1:]:
        if arg.startswith("--iterations="):
            iterations = int(arg.split("=")[1])
        elif arg.startswith("-i="):
            iterations = int(arg.split("=")[1])

    if iterations > 10:
        await message.answer(
            "‚ö†Ô∏è <b>Demasiadas iteraciones</b>\n"
            "El maximo permitido es 10 para evitar timeouts."
        )
        return

    handler_path = HANDLER_REGISTRY[handler_key]

    # Send initial status
    status_msg = await message.answer(
        f"üîç <b>Profileando handler:</b> <code>{handler_key}</code>\n"
        f"Iteraciones: {iterations}\n\n"
        f"<i>Esto puede tomar unos segundos...</i>",
        parse_mode="HTML"
    )

    try:
        # Import and profile
        import importlib
        module_path, func_name = handler_path.rsplit(".", 1)
        module = importlib.import_module(module_path)
        handler = getattr(module, func_name)

        profiler = AsyncProfiler()

        # Mock objects
        from unittest.mock import AsyncMock, MagicMock

        mock_message = MagicMock()
        mock_message.from_user.id = message.from_user.id
        mock_message.from_user.username = message.from_user.username or "admin"
        mock_message.answer = AsyncMock()
        mock_message.bot = message.bot

        # Run profiling
        result = await profiler.profile_async(
            handler,
            mock_message,
            session=session
        )

        # Format results
        report_lines = [
            f"üìä <b>Resultados del Profiling</b>",
            f"",
            f"Handler: <code>{handler_key}</code>",
            f"Iteraciones: {iterations}",
            f"",
            f"‚è±Ô∏è <b>Duracion promedio:</b> {result.duration_ms:.2f}ms",
            f"üóÑÔ∏è <b>Queries:</b> {result.query_count}",
            f"",
            f"üìà <b>Funciones mas lentas:</b>"
        ]

        for func in result.top_functions[:5]:
            name = func['name'][:40]  # Truncate long names
            report_lines.append(
                f"  ‚Ä¢ <code>{name}</code>: {func['time_ms']:.2f}ms"
            )

        report = "\n".join(report_lines)

        await status_msg.delete()

        # Send report
        if len(report) > 4000:
            # Send as file if too long
            with tempfile.NamedTemporaryFile(
                mode='w',
                suffix='.txt',
                delete=False
            ) as f:
                f.write(result.summary())
                f.write("\n\n")
                f.write(result.text_output or "")

            await message.answer_document(
                document=FSInputFile(f.name),
                caption=f"üìä Profile report for {handler_key}"
            )
            Path(f.name).unlink()
        else:
            await message.answer(report, parse_mode="HTML")

        # Offer HTML report
        if result.html_output:
            from aiogram.types import InlineKeyboardMarkup, InlineKeyboardButton
            keyboard = InlineKeyboardMarkup(inline_keyboard=[
                [InlineKeyboardButton(
                    text="üìÑ Descargar reporte HTML",
                    callback_data=f"profile:html:{handler_key}"
                )]
            ])
            await message.answer(
                "¬øDeseas descargar el reporte HTML detallado?",
                reply_markup=keyboard
            )

    except Exception as e:
        logger.exception("Error durante profiling")
        await status_msg.edit_text(
            f"‚ùå <b>Error en profiling</b>\n\n"
            f"<code>{str(e)[:500]}</code>"
        )


@profile_router.callback_query(F.data.startswith("profile:html:"))
async def callback_profile_html(callback: CallbackQuery):
    """Envia reporte HTML de profiling."""
    handler_key = callback.data.split(":")[2]

    await callback.answer("Generando reporte HTML...")

    # Re-run profiling to get HTML (or cache from previous run)
    # For now, just acknowledge
    await callback.message.answer(
        "‚ö†Ô∏è <i>Reporte HTML generado. "
        "Usa el script CLI para obtener el HTML completo.</i>"
    )


@profile_router.message(Command("profile_stats"))
async def cmd_profile_stats(message: Message):
    """
    Muestra estadisticas acumuladas de profiling.

    Requiere que PROFILE_HANDLERS este habilitado
    para recolectar estadisticas.
    """
    await message.answer(
        "üìä <b>Estadisticas de Profiling</b>\n\n"
        "<i>Esta funcion requiere habilitar PROFILE_HANDLERS=1 "
        "en las variables de entorno.</i>\n\n"
        "Cuando esta habilitado, muestra:\n"
        "‚Ä¢ Handlers mas lentos en promedio\n"
        "‚Ä¢ Numero de queries por handler\n"
        "‚Ä¢ Tendencias de rendimiento"
    )
```

### Task 5: Register Profile Router

**File:** `bot/handlers/admin/__init__.py`

Add the profile router:

```python
# bot/handlers/admin/__init__.py

from bot.handlers.admin.main import admin_router
from bot.handlers.admin.tests import tests_router
from bot.handlers.admin.profile import profile_router

# Include routers
admin_router.include_router(tests_router)
admin_router.include_router(profile_router)

__all__ = ["admin_router"]
```

## Verification

**Manual Verification:**
1. Run `python scripts/profile_handler.py --list` and verify handlers display
2. Run `python scripts/profile_handler.py bot.handlers.admin.main.cmd_admin` and verify output
3. Run with `--iterations=3` and verify aggregation works
4. Run with `--format=html` and verify HTML file is created
5. In Telegram, send `/profile` and verify handler list displays
6. Send `/profile admin` and verify profiling executes

**Automated Verification:**
```python
async def test_profiler_async():
    """Test async profiling works correctly."""
    async def sample_handler():
        await asyncio.sleep(0.1)
        return "done"

    profiler = AsyncProfiler()
    result = await profiler.profile_async(sample_handler)

    assert result.duration_ms >= 100
    assert result.duration_ms < 200  # Should be close to 100ms

async def test_profile_block():
    """Test profile context manager."""
    with profile_block("test"):
        await asyncio.sleep(0.05)

    # Should complete without errors
```

## Anti-Patterns to Avoid

1. **Don't profile in production without gating** - Use env var to enable
2. **Don't block the event loop** - Always use async profiling
3. **Don't store large HTML in memory** - Write to temp files
4. **Don't profile without timeout** - Set max execution time
5. **Don't expose internal paths** - Sanitize file paths in output

## Notes

- pyinstrument uses statistical profiling (low overhead)
- HTML reports are interactive with flame graphs
- Query monitoring requires SQLAlchemy session injection
- Iterations > 1 help average out variance

## References

- pyinstrument documentation: https://pyinstrument.readthedocs.io/
- SQLAlchemy events: https://docs.sqlalchemy.org/en/20/core/event.html
- aiogram handlers: https://docs.aiogram.dev/

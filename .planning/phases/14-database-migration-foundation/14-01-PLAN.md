---
phase: 14-database-migration-foundation
plan: 14-01
type: execute
wave: 1
depends_on: [13]
files_modified:
  - bot/database/engine.py
  - requirements.txt
  - .env.example
  - config.py
  - bot/database/dialect.py
autonomous: true
must_haves:
  truths:
    - "System supports both SQLite and PostgreSQL via DATABASE_URL environment variable"
    - "Engine automatically detects dialect from URL scheme (postgresql:// vs sqlite://)"
    - "Appropriate connection pooling is used per dialect (QueuePool for PostgreSQL, NullPool for SQLite)"
    - "SQLite-specific optimizations (PRAGMAs) are only applied to SQLite connections"
    - "Invalid or unsupported database URLs produce clear error messages"
  artifacts:
    - path: "bot/database/dialect.py"
      provides: "Database URL parser and dialect detector with error handling"
      min_lines: 70
    - path: "bot/database/engine.py"
      provides: "Dialect-aware engine factory with SQLite and PostgreSQL support"
      contains: ["_create_postgresql_engine", "_create_sqlite_engine", "parse_database_url"]
    - path: "requirements.txt"
      provides: "PostgreSQL async driver (asyncpg==0.29.0)"
    - path: "config.py"
      provides: "DATABASE_URL validation in Config.validate() method"
    - path: ".env.example"
      provides: "PostgreSQL and SQLite URL examples with documentation"
  key_links:
    - from: "bot/database/engine.py"
      to: "bot/database/dialect.py"
      via: "import parse_database_url, DatabaseDialect"
      pattern: "from bot.database.dialect import parse_database_url"
    - from: "config.py"
      to: "bot/database/dialect.py"
      via: "validate_database_url() calls parse_database_url()"
      pattern: "validate_database_url"
    - from: "bot/database/engine.py"
      to: "environment variable DATABASE_URL"
      via: "Config.DATABASE_URL passed to parse_database_url()"
      pattern: "parse_database_url\\(Config.DATABASE_URL\\)"
---

# Plan 14-01: Database Abstraction Layer with Dialect Detection

**Wave:** 1
**Depends on:** Phase 13 (v1.1 complete)

---

## Overview

Implement PostgreSQL support alongside the existing SQLite backend through automatic dialect detection from `DATABASE_URL` environment variable. The system will use `asyncpg` driver for PostgreSQL and `aiosqlite` for SQLite, with dialect-specific optimizations applied automatically.

---

## Tasks

<task type="auto">
  <name>Task 1: Update requirements.txt with PostgreSQL driver</name>
  <files>requirements.txt</files>
  <action>Add `asyncpg==0.29.0` to requirements.txt for PostgreSQL async support.

Do NOT modify any other dependencies. The version 0.29.0 is compatible with SQLAlchemy 2.0.25.

Add it in the Database section alongside aiosqlite:
```diff
# Database
sqlalchemy==2.0.25
aiosqlite==0.19.0
+ asyncpg==0.29.0
```
</action>
  <verify>grep "asyncpg==0.29.0" requirements.txt returns the line</verify>
  <done>asyncpg==0.29.0 is present in requirements.txt</done>
</task>

<task type="auto">
  <name>Task 2: Create database URL parser and dialect detector</name>
  <files>bot/database/dialect.py</files>
  <action>Create a new module `bot/database/dialect.py` that implements:

1. **DatabaseDialect enum** with values: SQLITE, POSTGRESQL, UNSUPPORTED

2. **parse_database_url(url: str) -> Tuple[DatabaseDialect, str]** function that:
   - Raises ValueError if URL is empty or malformed
   - Detects `postgresql://` or `postgresql+asyncpg://` ‚Üí returns DatabaseDialect.POSTGRESQL
   - Detects `sqlite://` or `sqlite+aiosqlite://` ‚Üí returns DatabaseDialect.SQLITE
   - Auto-injects driver if URL lacks it (e.g., `sqlite://` ‚Üí `sqlite+aiosqlite://`)
   - Returns ValueError with helpful message for unsupported dialects
   - Logs detected dialect at INFO level

3. **is_production_database(url: str) -> bool** function that:
   - Returns True if PostgreSQL dialect detected
   - Returns False if SQLite dialect detected

Use urllib.parse for URL parsing. Include comprehensive docstrings and type hints.
</action>
  <verify>
```python
from bot.database.dialect import parse_database_url, DatabaseDialect, is_production_database

# Test SQLite detection
dialect, url = parse_database_url("sqlite:///bot.db")
assert dialect == DatabaseDialect.SQLITE

# Test PostgreSQL detection
dialect, url = parse_database_url("postgresql://localhost/test")
assert dialect == DatabaseDialect.POSTGRESQL

# Test production detection
assert is_production_database("postgresql://localhost/test") == True
assert is_production_database("sqlite:///bot.db") == False

# Test error handling
try:
    parse_database_url("mysql://localhost/test")
except ValueError as e:
    assert "Unsupported" in str(e)
```
</verify>
  <done>
- parse_database_url() detects sqlite:// ‚Üí DatabaseDialect.SQLITE
- parse_database_url() detects postgresql:// ‚Üí DatabaseDialect.POSTGRESQL
- parse_database_url() raises ValueError for unsupported dialects
- is_production_database() returns True for PostgreSQL, False for SQLite
</done>
</task>

<task type="auto">
  <name>Task 3: Refactor engine.py with dialect-specific initialization</name>
  <files>bot/database/engine.py</files>
  <action>Modify `bot/database/engine.py` to support both SQLite and PostgreSQL:

1. Import dialect utilities:
```python
from bot.database.dialect import parse_database_url, DatabaseDialect, is_production_database
from sqlalchemy.pool import NullPool, QueuePool
```

2. Replace the existing `init_db()` function with dialect-aware implementation:
   - Parse `Config.DATABASE_URL` using `parse_database_url()` to detect dialect
   - Call `_create_postgresql_engine(db_url)` if POSTGRESQL detected
   - Call `_create_sqlite_engine(db_url)` if SQLITE detected
   - Raise ValueError if unsupported dialect
   - Log the detected dialect at INFO level

3. Create `_create_postgresql_engine(url: str) -> AsyncEngine` function:
   - Uses `QueuePool` with `pool_size=5`, `max_overflow=10`
   - Sets `pool_pre_ping=True` to validate connections
   - Sets `connect_args` with `timeout=30`, `command_timeout=30`
   - Logs "üêò Configurando PostgreSQL engine..." at INFO level

4. Create `_create_sqlite_engine(url: str) -> AsyncEngine` function:
   - Uses `NullPool` (SQLite doesn't need connection pooling)
   - Sets `check_same_thread=False` for async compatibility
   - Executes PRAGMA commands: journal_mode=WAL, synchronous=NORMAL, cache_size=-64000, foreign_keys=ON
   - Logs "üóÑÔ∏è Configurando SQLite engine..." and PRAGMA success at INFO level

IMPORTANT: Do NOT change the existing `_ensure_bot_config_exists()` function or session factory initialization.
</action>
  <verify>
```python
# Test that dialect detection works
from bot.database.engine import init_db
from unittest.mock import patch

# Mock DATABASE_URL for PostgreSQL
with patch.object(Config, 'DATABASE_URL', 'postgresql://localhost/test'):
    # Should create PostgreSQL engine with QueuePool
    await init_db()
    # Check logs for "üêò Configurando PostgreSQL engine"

# Mock DATABASE_URL for SQLite
with patch.object(Config, 'DATABASE_URL', 'sqlite:///test.db'):
    # Should create SQLite engine with NullPool
    await init_db()
    # Check logs for "üóÑÔ∏è Configurando SQLite engine"
```
</verify>
  <done>
- init_db() calls _create_postgresql_engine() for postgresql:// URLs
- init_db() calls _create_sqlite_engine() for sqlite:// URLs
- PostgreSQL engine uses QueuePool with pool_size=5
- SQLite engine uses NullPool and executes PRAGMAs
- Logs show detected dialect
</done>
</task>

<task type="auto">
  <name>Task 4: Update .env.example with PostgreSQL URL examples</name>
  <files>.env.example</files>
  <action>Add PostgreSQL URL examples to .env.example with clear documentation:

Replace or augment the existing DATABASE_URL section:
```diff
# Database
- DATABASE_URL=sqlite+aiosqlite:///bot.db
+# Local development (SQLite)
+# DATABASE_URL=sqlite+aiosqlite:///bot.db
+# DATABASE_URL=sqlite:///bot.db
+
+# Production (PostgreSQL on Railway)
+# DATABASE_URL=postgresql://user:password@host:5432/dbname
+# DATABASE_URL=postgresql+asyncpg://user:password@host:5432/dbname
+
+# Default (fallback to SQLite if not set)
DATABASE_URL=sqlite+aiosqlite:///bot.db
```

Keep the default as SQLite for local development.
</action>
  <verify>grep -E "postgresql|sqlite" .env.example returns both URL formats with comments</verify>
  <done>
- .env.example shows both SQLite and PostgreSQL URL formats
- Comments explain when to use each format
- Default remains SQLite for local development
</done>
</task>

<task type="auto">
  <name>Task 5: Add Config validation for DATABASE_URL dialect</name>
  <files>config.py</files>
  <action>Add DATABASE_URL validation to the Config class (REQUIRED - not optional):

1. Add `validate_database_url()` class method:
```python
@classmethod
def validate_database_url(cls) -> bool:
    """
    Valida que DATABASE_URL tiene un formato soportado.

    Returns:
        True si el formato es v√°lido, False en caso contrario
    """
    try:
        from bot.database.dialect import parse_database_url
        dialect, _ = parse_database_url(cls.DATABASE_URL)
        logger.info(f"‚úÖ DATABASE_URL dialect detectado: {dialect.value}")
        return True
    except ValueError as e:
        logger.error(f"‚ùå DATABASE_URL inv√°lido: {e}")
        return False
```

2. Update the existing `validate()` method to include database URL validation:
```python
# Add to the existing validation logic
if not cls.DATABASE_URL:
    errors.append("DATABASE_URL no configurado")
elif not cls.validate_database_url():
    errors.append("DATABASE_URL tiene formato inv√°lido")
```

This is REQUIRED for DBMIG-02 error handling and DBMIG-06 type validation.
</action>
  <verify>
```python
from config import Config

# Test valid URL
Config.DATABASE_URL = "sqlite:///bot.db"
assert Config.validate_database_url() == True

# Test invalid URL
Config.DATABASE_URL = "mysql://localhost/test"
assert Config.validate_database_url() == False
assert "DATABASE_URL tiene formato inv√°lido" in Config.validate()
```
</verify>
  <done>
- Config.validate_database_url() returns True for valid URLs
- Config.validate_database_url() returns False for invalid URLs
- Config.validate() includes database URL validation
- Invalid URLs are caught during config validation with clear error message
</done>
</task>

---

## Verification Criteria

**Must-haves (goal-backward verification):**

1. ‚úÖ System supports SQLite and PostgreSQL via `DATABASE_URL` environment variable
   - Test: Set `DATABASE_URL=sqlite:///bot.db` ‚Üí engine uses SQLite
   - Test: Set `DATABASE_URL=postgresql://localhost/test` ‚Üí engine uses PostgreSQL

2. ‚úÖ Engine factory automatically detects dialect from URL scheme
   - Test: `parse_database_url("sqlite:///bot.db")` ‚Üí `(DatabaseDialect.SQLITE, ...)`
   - Test: `parse_database_url("postgresql://localhost/test")` ‚Üí `(DatabaseDialect.POSTGRESQL, ...)`

3. ‚úÖ Appropriate connection pooling per dialect
   - Test: PostgreSQL engine uses `QueuePool` with `pool_size=5`
   - Test: SQLite engine uses `NullPool`

4. ‚úÖ SQLite-specific optimizations (PRAGMAs) only applied to SQLite
   - Test: SQLite engine configures WAL mode, cache, foreign keys
   - Test: PostgreSQL engine does NOT execute PRAGMA commands

5. ‚úÖ Clear error messages for unsupported dialects (DBMIG-02 error handling)
   - Test: Malformed URL ‚Üí `ValueError` with helpful message
   - Test: Unsupported scheme (e.g., `mysql://`) ‚Üí `ValueError` listing supported formats

6. ‚úÖ Database URL validation before initialization (DBMIG-06)
   - Test: `Config.validate_database_url()` validates URL format
   - Test: Invalid URL caught by `Config.validate()` before engine creation

---

## Success Metrics

- ‚úÖ Local development still works with SQLite (backward compatibility)
- ‚úÖ Production deployment can use PostgreSQL via `DATABASE_URL`
- ‚úÖ No manual configuration needed ‚Äî dialect detection is automatic
- ‚úÖ Clear error messages if `DATABASE_URL` is malformed (DBMIG-02)
- ‚úÖ Type validation before engine initialization (DBMIG-06)

---

## Output

After completion, create `.planning/phases/14-database-migration-foundation/14-01-SUMMARY.md`

---
phase: 05-role-detection-database
plan: 05
type: execute
wave: 7
depends_on: [05-01, 05-02B]
files_modified:
  - bot/services/role_change.py
  - bot/services/container.py
  - bot/services/__init__.py
autonomous: true

must_haves:
  truths:
    - "Sistema registra autom√°ticamente cambios de rol con raz√≥n y auditor√≠a"
    - "Admin puede ver historial completo de cambios de rol de un usuario"
    - "Cambios autom√°ticos (VIP expiraci√≥n) se registran con raz√≥n SYSTEM_AUTOMATIC"
    - "Cambios manuales por admin se registran con admin ID y raz√≥n"
    - "Logs incluyen metadata opcional (duraci√≥n, token, etc.)"
  artifacts:
    - path: "bot/services/role_change.py"
      provides: "RoleChangeService with log_role_change() method"
      exports: ["RoleChangeService"]
      min_lines: 100
    - path: "bot/services/container.py"
      provides: "ServiceContainer.role_change property for lazy loading"
      contains: "@property def role_change"
      min_lines: 10 (new code)
    - path: "bot/services/__init__.py"
      provides: "Export of RoleChangeService"
      contains: "from bot.services.role_change import RoleChangeService"
      min_lines: 5 (new or modified)
  key_links:
    - from: "bot/services/role_change.py"
      to: "bot/database/models.py"
      via: "UserRoleChangeLog model import and usage"
      pattern: "from bot\.database\.models import.*UserRoleChangeLog"
    - from: "bot/services/role_change.py"
      to: "bot/database/enums.py"
      via: "UserRole and RoleChangeReason enums"
      pattern: "from bot\.database\.enums import.*UserRole"
    - from: "bot/services/container.py"
      to: "bot/services/role_change.py"
      via: "RoleChangeService instantiation in lazy loading"
      pattern: "RoleChangeService\(self\.session"
---

<objective>
Create RoleChangeService for logging role changes to UserRoleChangeLog audit table, addressing MENU-04 requirement for role change tracking and audit trail.

Purpose: Enable comprehensive audit trail of all role changes (admin promotions, VIP subscriptions, expirations, etc.)
Output: Working RoleChangeService integrated with ServiceContainer
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-role-detection-database/05-CONTEXT.md
@.planning/phases/05-role-detection-database/05-RESEARCH.md

# Dependencies
@.planning/phases/05-role-detection-database/05-01-SUMMARY.md (RoleDetectionService for detecting current role)
@.planning/phases/05-role-detection-database/05-02B-SUMMARY.md (UserRoleChangeLog model and enums)

# Existing patterns to follow
@bot/services/subscription.py (SubscriptionService pattern - async, session injection, no commits)
@bot/services/container.py (ServiceContainer lazy loading pattern)
@bot/database/models.py (UserRoleChangeLog model)
@bot/database/enums.py (UserRole, RoleChangeReason enums)
</context>

<tasks>

<task type="auto">
  <name>Create RoleChangeService for audit logging</name>
  <files>bot/services/role_change.py</files>
  <action>
Create bot/services/role_change.py with RoleChangeService class:

```python
"""
Role Change Service - Registra cambios de rol para auditor√≠a.

Responsabilidades:
- Registrar cambios de rol en tabla UserRoleChangeLog
- Proporcionar historial de cambios por usuario
- Integrar con SubscriptionService para cambios autom√°ticos (VIP expiraci√≥n)
- Seguir patr√≥n stateless (sin cach√©, solo logging)

Pattern: Sigue SubscriptionService (async, session injection, sin commits)
"""
import logging
from datetime import datetime
from typing import Optional, Dict, Any, List

from sqlalchemy import select, desc
from sqlalchemy.ext.asyncio import AsyncSession

from bot.database.models import UserRoleChangeLog
from bot.database.enums import UserRole, RoleChangeReason

logger = logging.getLogger(__name__)


class RoleChangeService:
    """
    Servicio para registro de cambios de rol.

    Uso:
        # Log cambio manual por admin
        await service.log_role_change(
            user_id=123456,
            new_role=UserRole.VIP,
            changed_by=789012,  # Admin ID
            reason=RoleChangeReason.VIP_REDEEMED,
            change_source="ADMIN_PANEL",
            metadata={"token": "ABC123", "duration_hours": 24}
        )

        # Log cambio autom√°tico (VIP expiraci√≥n)
        await service.log_role_change(
            user_id=123456,
            new_role=UserRole.FREE,
            changed_by=0,  # SYSTEM
            reason=RoleChangeReason.VIP_EXPIRED,
            change_source="SYSTEM",
            metadata={"expired_at": "2024-01-01 12:00:00"}
        )
    """

    def __init__(self, session: AsyncSession):
        """
        Inicializa el service.

        Args:
            session: Sesi√≥n de base de datos SQLAlchemy
        """
        self.session = session
        logger.debug("‚úÖ RoleChangeService inicializado")

    async def log_role_change(
        self,
        user_id: int,
        new_role: UserRole,
        changed_by: int,
        reason: RoleChangeReason,
        change_source: str = "SYSTEM",
        previous_role: Optional[UserRole] = None,
        metadata: Optional[Dict[str, Any]] = None
    ) -> UserRoleChangeLog:
        """
        Registra un cambio de rol en la tabla de auditor√≠a.

        Args:
            user_id: ID del usuario que cambi√≥ de rol
            new_role: Nuevo rol del usuario
            changed_by: ID del admin que hizo el cambio (0 para SYSTEM)
            reason: Raz√≥n del cambio (RoleChangeReason enum)
            change_source: Origen del cambio ("ADMIN_PANEL", "SYSTEM", "API")
            previous_role: Rol anterior (opcional - se detecta autom√°ticamente si None)
            metadata: Informaci√≥n adicional JSON (opcional)

        Returns:
            UserRoleChangeLog: Registro creado (sin commit - handler gestiona transacci√≥n)

        Raises:
            ValueError: Si change_source no es v√°lido
        """
        # Validar change_source
        valid_sources = ["ADMIN_PANEL", "SYSTEM", "API"]
        if change_source not in valid_sources:
            raise ValueError(f"change_source inv√°lido: {change_source}. Debe ser: {valid_sources}")

        # Si previous_role no se proporciona, intentar detectarlo
        if previous_role is None:
            previous_role = await self._detect_previous_role(user_id)

        # Crear registro
        log_entry = UserRoleChangeLog(
            user_id=user_id,
            previous_role=previous_role,
            new_role=new_role,
            changed_by=changed_by,
            reason=reason,
            change_source=change_source,
            metadata=metadata,
            changed_at=datetime.utcnow()
        )

        self.session.add(log_entry)
        # NO commit - dejar que el handler gestione la transacci√≥n

        logger.info(
            f"üìù Cambio de rol registrado: user {user_id} "
            f"{previous_role.value if previous_role else 'NEW'} ‚Üí {new_role.value} "
            f"(reason: {reason.value}, by: {changed_by})"
        )

        return log_entry

    async def _detect_previous_role(self, user_id: int) -> Optional[UserRole]:
        """
        Detecta el rol anterior del usuario.

        Intenta obtener el √∫ltimo rol registrado en UserRoleChangeLog.
        Si no hay registros, retorna None (usuario nuevo).

        Args:
            user_id: ID del usuario

        Returns:
            UserRole anterior o None si no hay registros
        """
        # Buscar √∫ltimo cambio de rol para este usuario
        query = (
            select(UserRoleChangeLog)
            .where(UserRoleChangeLog.user_id == user_id)
            .order_by(desc(UserRoleChangeLog.changed_at))
            .limit(1)
        )

        result = await self.session.execute(query)
        last_change = result.scalar_one_or_none()

        if last_change:
            return last_change.new_role

        # No hay registros previos (usuario nuevo)
        logger.debug(f"üìù Usuario {user_id} no tiene registros previos de rol (nuevo usuario)")
        return None

    async def get_user_role_history(
        self,
        user_id: int,
        limit: int = 50,
        offset: int = 0
    ) -> List[UserRoleChangeLog]:
        """
        Obtiene historial de cambios de rol de un usuario.

        Args:
            user_id: ID del usuario
            limit: M√°ximo de resultados (default: 50)
            offset: Desplazamiento para paginaci√≥n (default: 0)

        Returns:
            Lista de UserRoleChangeLog ordenada por fecha descendente
        """
        query = (
            select(UserRoleChangeLog)
            .where(UserRoleChangeLog.user_id == user_id)
            .order_by(desc(UserRoleChangeLog.changed_at))
            .limit(limit)
            .offset(offset)
        )

        result = await self.session.execute(query)
        history = list(result.scalars().all())

        logger.debug(f"üìù Historial obtenido: {len(history)} cambios para user {user_id}")

        return history

    async def get_recent_role_changes(
        self,
        limit: int = 100,
        offset: int = 0
    ) -> List[UserRoleChangeLog]:
        """
        Obtiene cambios de rol recientes (todos los usuarios).

        Args:
            limit: M√°ximo de resultados (default: 100)
            offset: Desplazamiento para paginaci√≥n (default: 0)

        Returns:
            Lista de UserRoleChangeLog ordenada por fecha descendente
        """
        query = (
            select(UserRoleChangeLog)
            .order_by(desc(UserRoleChangeLog.changed_at))
            .limit(limit)
            .offset(offset)
        )

        result = await self.session.execute(query)
        changes = list(result.scalars().all())

        logger.debug(f"üìù Cambios recientes obtenidos: {len(changes)} registros")

        return changes

    async def get_changes_by_admin(
        self,
        admin_id: int,
        limit: int = 100,
        offset: int = 0
    ) -> List[UserRoleChangeLog]:
        """
        Obtiene cambios de rol realizados por un admin espec√≠fico.

        Args:
            admin_id: ID del admin
            limit: M√°ximo de resultados (default: 100)
            offset: Desplazamiento para paginaci√≥n (default: 0)

        Returns:
            Lista de UserRoleChangeLog ordenada por fecha descendente
        """
        query = (
            select(UserRoleChangeLog)
            .where(UserRoleChangeLog.changed_by == admin_id)
            .order_by(desc(UserRoleChangeLog.changed_at))
            .limit(limit)
            .offset(offset)
        )

        result = await self.session.execute(query)
        changes = list(result.scalars().all())

        logger.debug(f"üìù Cambios por admin {admin_id}: {len(changes)} registros")

        return changes

    async def count_role_changes(self, user_id: Optional[int] = None) -> int:
        """
        Cuenta cambios de rol (opcionalmente filtrado por usuario).

        Args:
            user_id: ID del usuario para filtrar (opcional)

        Returns:
            N√∫mero de cambios de rol
        """
        from sqlalchemy import func

        query = select(func.count(UserRoleChangeLog.id))

        if user_id is not None:
            query = query.where(UserRoleChangeLog.user_id == user_id)

        result = await self.session.execute(query)
        count = result.scalar_one()

        logger.debug(f"üìù Conteo cambios de rol: {count} (user_id={user_id})")

        return count
```

Key requirements:
- Follow SubscriptionService pattern exactly (async methods, session injection, no commits)
- Use select() from sqlalchemy (SQLAlchemy 2.0 style)
- Auto-detect previous role if not provided (query UserRoleChangeLog)
- Validate change_source parameter
- Add comprehensive logging (INFO for changes, DEBUG for queries)
- Add methods for querying history (by user, by admin, recent changes)
- Add count method for statistics
- Add docstrings (Google Style)
- Type hints for all parameters and returns
  </action>
  <verify>
# Check RoleChangeService structure and methods
python -c "
from bot.services.role_change import RoleChangeService
from bot.database.enums import UserRole, RoleChangeReason
import inspect

# Verify class exists
assert RoleChangeService is not None

# Verify required methods exist
methods = [
    'log_role_change',
    'get_user_role_history',
    'get_recent_role_changes',
    'get_changes_by_admin',
    'count_role_changes'
]

for method in methods:
    assert hasattr(RoleChangeService, method), f'Missing method: {method}'

# Verify log_role_change signature
sig = inspect.signature(RoleChangeService.log_role_change)
params = list(sig.parameters.keys())
assert 'user_id' in params, 'Missing user_id parameter'
assert 'new_role' in params, 'Missing new_role parameter'
assert 'changed_by' in params, 'Missing changed_by parameter'
assert 'reason' in params, 'Missing reason parameter'

# Verify methods are async
import asyncio
for method in methods:
    method_obj = getattr(RoleChangeService, method)
    assert asyncio.iscoroutinefunction(method_obj), f'{method} must be async'

print('‚úÖ RoleChangeService structure verified')
"
  </verify>
  <done>
RoleChangeService exists with log_role_change() and query methods following SubscriptionService pattern
  </done>
</task>

<task type="auto">
  <name>Integrate RoleChangeService into ServiceContainer</name>
  <files>bot/services/container.py</files>
  <action>
Modify bot/services/container.py to add role_change property:

1. Add _role_change_service private attribute in __init__:
   After line 55 (after self._content_service = None, following alphabetical order):
   Add: self._role_change_service = None

2. Add role_change property after the role_detection property (alphabetical order):
```python
    # ===== ROLE CHANGE SERVICE =====

    @property
    def role_change(self):
        """
        Service de registro de cambios de rol (auditor√≠a).

        Se carga lazy (solo en primer acceso).

        Returns:
            RoleChangeService: Instancia del service
        """
        if self._role_change_service is None:
            from bot.services.role_change import RoleChangeService
            logger.debug("üîÑ Lazy loading: RoleChangeService")
            self._role_change_service = RoleChangeService(self._session)

        return self._role_change_service
```

Key requirements:
- Follow existing lazy loading pattern
- Add DEBUG logging for lazy loading
- Only pass session (RoleChangeService doesn't need bot)
- Place property logically after role_detection (alphabetical: change comes after detection)
  </action>
  <verify>
# Verify container has role_change property
python -c "
from bot.services.container import ServiceContainer

# Verify property exists
assert hasattr(ServiceContainer, 'role_change'), 'Missing role_change property'

# Verify it's a property
assert isinstance(type(ServiceContainer.role_change), property), 'role_change must be @property'

# Test lazy loading structure
import inspect
prop = ServiceContainer.role_change
assert prop.fget is not None, 'role_change property must have getter'

print('‚úÖ ServiceContainer.role_change property verified')
"
  </verify>
  <done>
ServiceContainer has role_change property with lazy loading following existing pattern
  </done>
</task>

<task type="auto">
  <name>Export RoleChangeService from services __init__.py</name>
  <files>bot/services/__init__.py</files>
  <action>
Modify bot/services/__init__.py to export RoleChangeService:

Check if __init__.py exists and has existing exports. Add:

```python
from bot.services.role_change import RoleChangeService
```

If __all__ exists in the file, add "RoleChangeService" to the list.

If __init__.py doesn't exist or is minimal, ensure the import is present for:
```python
from bot.services import RoleChangeService
```

Key requirements:
- Follow existing export pattern in the file
- Add to __all__ if it exists
- Otherwise, import is sufficient
  </action>
  <verify>
# Verify import works
python -c "
from bot.services import RoleChangeService

# Verify class is importable
assert RoleChangeService is not None

# Verify it has the expected methods
assert hasattr(RoleChangeService, 'log_role_change')
assert hasattr(RoleChangeService, 'get_user_role_history')

print('‚úÖ RoleChangeService export verified')
"
  </verify>
  <done>
RoleChangeService is exportable from bot.services module
  </done>
</task>

</tasks>

<verification>
# Overall Phase 5-5 Verification

## 1. RoleChangeService Logging Test
```bash
python -c "
import asyncio
from bot.database.engine import get_session
from bot.services.role_change import RoleChangeService
from bot.database.enums import UserRole, RoleChangeReason

async def test_role_change_service():
    async with get_session() as session:
        async with session.begin():
            service = RoleChangeService(session)

            # Test: Log role change
            log_entry = await service.log_role_change(
                user_id=123456,
                new_role=UserRole.VIP,
                changed_by=789012,
                reason=RoleChangeReason.VIP_REDEEMED,
                change_source='ADMIN_PANEL',
                metadata={'token': 'ABC123', 'duration_hours': 24}
            )
            assert log_entry.id is not None
            assert log_entry.new_role == UserRole.VIP
            print('‚úÖ Role change logged successfully')

            # Test: Get user history
            history = await service.get_user_role_history(user_id=123456)
            assert len(history) >= 1
            print(f'‚úÖ User history retrieved: {len(history)} entries')

            # Test: Count changes
            count = await service.count_role_changes(user_id=123456)
            assert count >= 1
            print(f'‚úÖ Role changes counted: {count}')

    print('‚úÖ All RoleChangeService operations work correctly')

asyncio.run(test_role_change_service())
"
```

## 2. ServiceContainer Integration Test
```bash
python -c "
import asyncio
from bot.database.engine import get_session
from bot.services.container import ServiceContainer

async def test_container():
    async with get_session() as session:
        from aiogram import Bot
        # Mock bot for testing
        class MockBot:
            pass

        container = ServiceContainer(session, MockBot())

        # Test lazy loading
        role_change_service = container.role_change
        assert role_change_service is not None
        print('‚úÖ RoleChangeService loaded from container')

        # Test caching (second call returns same instance)
        role_change_service2 = container.role_change
        assert role_change_service is role_change_service2
        print('‚úÖ RoleChangeService cached correctly')

asyncio.run(test_container())
"
```

## 3. Input Validation Test
```bash
python -c "
import asyncio
from bot.database.engine import get_session
from bot.services.role_change import RoleChangeService
from bot.database.enums import UserRole, RoleChangeReason

async def test_validations():
    async with get_session() as session:
        async with session.begin():
            service = RoleChangeService(session)

            # Test: Invalid change_source raises ValueError
            try:
                await service.log_role_change(
                    user_id=123456,
                    new_role=UserRole.VIP,
                    changed_by=789012,
                    reason=RoleChangeReason.VIP_REDEEMED,
                    change_source='INVALID_SOURCE'
                )
                assert False, 'Should have raised ValueError'
            except ValueError as e:
                assert 'inv√°lido' in str(e)
                print('‚úÖ Invalid change_source validation works')

asyncio.run(test_validations())
"
```
</verification>

<success_criteria>
1. RoleChangeService.log_role_change() creates UserRoleChangeLog record with all fields
2. Auto-detection of previous role works (queries last change or returns None for new users)
3. RoleChangeService.get_user_role_history() returns list of changes for a user
4. RoleChangeService.get_recent_role_changes() returns recent changes across all users
5. RoleChangeService.get_changes_by_admin() returns changes made by specific admin
6. RoleChangeService.count_role_changes() returns count (optionally filtered by user)
7. All methods are async (using async def)
8. No methods call session.commit() - handlers manage transactions
9. ServiceContainer.role_change property loads RoleChangeService lazily
10. Input validation works (invalid change_source raises ValueError)
</success_criteria>

<output>
After completion, create `.planning/phases/05-role-detection-database/05-05-SUMMARY.md` with:

1. Frontmatter with phase, plan, subsystem, dependencies, tech-stack, key-files, key-decisions, patterns-established, duration, completed date
2. Summary of RoleChangeService implementation (audit logging, history queries)
3. Integration with ServiceContainer (lazy loading)
4. Any deviations from plan or discovered edge cases
5. Test results summary
</output>

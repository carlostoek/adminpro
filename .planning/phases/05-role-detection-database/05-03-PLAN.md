---
phase: 05-role-detection-database
plan: 03
type: execute
wave: 4
depends_on: [05-02A, 05-02B]
files_modified:
  - bot/services/content.py
  - bot/services/container.py
  - bot/services/__init__.py
autonomous: true

must_haves:
  truths:
    - "Admin puede crear nuevos paquetes de contenido con nombre, categor√≠a y precio"
    - "Admin puede ver lista de paquetes filtrada por categor√≠a y estado activo"
    - "Admin puede buscar paquetes por nombre o descripci√≥n"
    - "Admin puede actualizar informaci√≥n de paquetes existentes"
    - "Admin puede desactivar/reactivar paquetes (soft delete)"
    - "Sistema valida que precios no sean negativos y nombres no est√©n vac√≠os"
    - "Precios se almacenan con precisi√≥n decimal para moneda"
  artifacts:
    - path: "bot/services/content.py"
      provides: "ContentService with CRUD operations"
      exports: ["ContentService"]
      contains: "async def create_package", "async def get_package", "async def list_packages", "async def update_package", "async def deactivate_package"
      min_lines: 250
    - path: "bot/services/container.py"
      provides: "ServiceContainer.content property for lazy loading"
      contains: "@property def content"
      min_lines: 10 (new code)
    - path: "bot/services/__init__.py"
      provides: "Export of ContentService"
      contains: "from bot.services.content import ContentService"
      min_lines: 5 (new or modified)
  key_links:
    - from: "bot/services/content.py"
      to: "bot/database/models.py"
      via: "ContentPackage, UserInterest imports"
      pattern: "from bot\.database\.models import.*ContentPackage"
    - from: "bot/services/content.py"
      to: "bot/database/enums.py"
      via: "ContentCategory, PackageType imports"
      pattern: "from bot\.database\.enums import.*ContentCategory"
    - from: "bot/services/container.py"
      to: "bot/services/content.py"
      via: "ContentService instantiation in lazy loading"
      pattern: "ContentService\(self\.session"
---

<objective>
Create ContentService with full CRUD operations (create, read, update, deactivate, list) for content packages following SubscriptionService pattern - async methods, session injection, no commits in service methods.

Purpose: Enable content package management for admin - CONTENT-03 requirement
Output: Working ContentService integrated with ServiceContainer
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-role-detection-database/05-CONTEXT.md
@.planning/phases/05-role-detection-database/05-RESEARCH.md

# Existing patterns to follow
@bot/services/subscription.py (SubscriptionService - reference for CRUD pattern)
@bot/services/container.py (ServiceContainer - for lazy loading integration)
@bot/database/models.py (ContentPackage model created in 05-02A)
@bot/database/enums.py (ContentCategory, PackageType enums)
</context>

<tasks>

<task type="auto">
  <name>Create ContentService with CRUD operations</name>
  <files>bot/services/content.py</files>
  <action>
Create bot/services/content.py with ContentService class:

```python
"""
Content Service - Gesti√≥n de paquetes de contenido.

Responsibilidades:
- Crear paquetes de contenido (create_package)
- Obtener paquetes por ID (get_package)
- Listar paquetes con filtros (list_packages)
- Actualizar paquetes (update_package)
- Desactivar paquetes (deactivate_package - soft delete)
- Listar paquetes activos (get_active_packages)

Pattern: Sigue SubscriptionService (async, session injection, sin commits)
"""
import logging
from datetime import datetime
from decimal import Decimal
from typing import List, Optional, Tuple

from sqlalchemy import select, and_, or_
from sqlalchemy.ext.asyncio import AsyncSession

from bot.database.models import ContentPackage
from bot.database.enums import ContentCategory, PackageType

logger = logging.getLogger(__name__)


class ContentService:
    """
    Servicio para gesti√≥n de paquetes de contenido.

    CRUD Operations:
    1. Create: create_package() - Crear nuevo paquete
    2. Read: get_package() - Obtener por ID, list_packages() - Listar con filtros
    3. Update: update_package() - Actualizar campos
    4. Delete: deactivate_package() - Soft delete (is_active=False)

    Transaction Handling:
    - Los m√©todos NO hacen commit
    - El handler gestiona la transacci√≥n con SessionContextManager
    - Sigue patr√≥n de SubscriptionService
    """

    def __init__(self, session: AsyncSession):
        """
        Inicializa el service.

        Args:
            session: Sesi√≥n de base de datos SQLAlchemy
        """
        self.session = session
        logger.debug("‚úÖ ContentService inicializado")

    # ===== CREATE =====

    async def create_package(
        self,
        name: str,
        category: ContentCategory,
        description: Optional[str] = None,
        price: Optional[Decimal | float] = None,
        package_type: PackageType = PackageType.STANDARD,
        media_url: Optional[str] = None
    ) -> ContentPackage:
        """
        Crea un nuevo paquete de contenido.

        Args:
            name: Nombre del paquete (max 200 chars)
            category: Categor√≠a (FREE_CONTENT, VIP_CONTENT, VIP_PREMIUM)
            description: Descripci√≥n detallada (opcional)
            price: Precio en moneda base (Decimal o Float)
            package_type: Tipo de paquete (default: STANDARD)
            media_url: URL del contenido (opcional)

        Returns:
            ContentPackage: Paquete creado (sin commit - handler gestiona transacci√≥n)

        Raises:
            ValueError: Si name est√° vac√≠o o price es negativo
        """
        # Validaciones
        if not name or not name.strip():
            raise ValueError("El nombre del paquete no puede estar vac√≠o")

        if name.strip() != name:
            logger.warning("‚ö†Ô∏è Nombre del paquete tiene espacios extra, se limpiar√°n")
            name = name.strip()

        # Convertir price a Decimal si es Float
        if price is not None:
            if isinstance(price, float):
                price = Decimal(str(price))
            if price < 0:
                raise ValueError("El precio no puede ser negativo")

        # Crear paquete
        package = ContentPackage(
            name=name,
            description=description,
            price=price,
            category=category,
            type=package_type,
            media_url=media_url,
            is_active=True,
            created_at=datetime.utcnow(),
            updated_at=datetime.utcnow()
        )

        self.session.add(package)
        # NO commit - dejar que el handler gestione la transacci√≥n

        logger.info(
            f"‚úÖ Paquete creado: {name} ({category.value}, "
            f"price={price}, type={package_type.value})"
        )

        return package

    # ===== READ =====

    async def get_package(self, package_id: int) -> Optional[ContentPackage]:
        """
        Obtiene un paquete por ID.

        Args:
            package_id: ID del paquete

        Returns:
            ContentPackage si existe, None si no
        """
        result = await self.session.execute(
            select(ContentPackage).where(ContentPackage.id == package_id)
        )
        package = result.scalar_one_or_none()

        if package:
            logger.debug(f"üì¶ Paquete encontrado: {package_id} - {package.name}")
        else:
            logger.debug(f"üì¶ Paquete no encontrado: {package_id}")

        return package

    async def list_packages(
        self,
        category: Optional[ContentCategory] = None,
        package_type: Optional[PackageType] = None,
        is_active: Optional[bool] = None,
        limit: int = 100,
        offset: int = 0
    ) -> List[ContentPackage]:
        """
        Lista paquetes con filtros opcionales.

        Args:
            category: Filtrar por categor√≠a (opcional)
            package_type: Filtrar por tipo (opcional)
            is_active: Filtrar por estado (True=activos, False=inactivos, None=todos)
            limit: M√°ximo de resultados (default: 100)
            offset: Desplazamiento para paginaci√≥n (default: 0)

        Returns:
            Lista de ContentPackage (ordenada por created_at DESC)
        """
        query = select(ContentPackage).order_by(ContentPackage.created_at.desc())

        # Aplicar filtros
        if category is not None:
            query = query.where(ContentPackage.category == category)

        if package_type is not None:
            query = query.where(ContentPackage.type == package_type)

        if is_active is not None:
            query = query.where(ContentPackage.is_active == is_active)

        # Aplicar paginaci√≥n
        query = query.limit(limit).offset(offset)

        result = await self.session.execute(query)
        packages = list(result.scalars().all())

        logger.debug(
            f"üì¶ Listados {len(packages)} paquetes "
            f"(category={category}, type={package_type}, active={is_active})"
        )

        return packages

    async def get_active_packages(
        self,
        category: Optional[ContentCategory] = None,
        limit: int = 100
    ) -> List[ContentPackage]:
        """
        Obtiene solo paquetes activos (shortcut para list_packages).

        Args:
            category: Filtrar por categor√≠a (opcional)
            limit: M√°ximo de resultados (default: 100)

        Returns:
            Lista de ContentPackage con is_active=True
        """
        return await self.list_packages(category=category, is_active=True, limit=limit)

    async def count_packages(
        self,
        category: Optional[ContentCategory] = None,
        is_active: Optional[bool] = None
    ) -> int:
        """
        Cuenta paquetes con filtros opcionales.

        Args:
            category: Filtrar por categor√≠a (opcional)
            is_active: Filtrar por estado (opcional)

        Returns:
            N√∫mero de paquetes que cumplen los filtros
        """
        from sqlalchemy import func

        query = select(func.count(ContentPackage.id))

        if category is not None:
            query = query.where(ContentPackage.category == category)

        if is_active is not None:
            query = query.where(ContentPackage.is_active == is_active)

        result = await self.session.execute(query)
        count = result.scalar_one()

        logger.debug(f"üì¶ Conteo: {count} paquetes")

        return count

    # ===== UPDATE =====

    async def update_package(
        self,
        package_id: int,
        **kwargs
    ) -> Optional[ContentPackage]:
        """
        Actualiza campos de un paquete.

        Args:
            package_id: ID del paquete a actualizar
            **kwargs: Campos a actualizar (name, description, price, category, type, media_url)

        Returns:
            ContentPackage actualizado si existe, None si no

        Raises:
            ValueError: Si se intenta actualizar price con valor negativo

        Note:
            - Actualiza solo los campos especificados en kwargs
            - Actualiza autom√°ticamente updated_at
        """
        package = await self.get_package(package_id)

        if not package:
            logger.warning(f"üì¶ Paquete no encontrado para actualizar: {package_id}")
            return None

        # Validaciones
        if 'price' in kwargs:
            price = kwargs['price']
            if price is not None:
                if isinstance(price, float):
                    kwargs['price'] = Decimal(str(price))
                if kwargs['price'] < 0:
                    raise ValueError("El precio no puede ser negativo")

        if 'name' in kwargs:
            name = kwargs['name']
            if name and name.strip() != name:
                kwargs['name'] = name.strip()

        # Actualizar campos
        for key, value in kwargs.items():
            if hasattr(package, key) and value is not None:
                setattr(package, key, value)
                logger.debug(f"üì¶ Actualizado {key}={value} en paquete {package_id}")

        # Actualizar timestamp
        package.updated_at = datetime.utcnow()

        # NO commit - dejar que el handler gestione la transacci√≥n

        logger.info(f"‚úÖ Paquete actualizado: {package_id} - {package.name}")

        return package

    # ===== DELETE (Soft) =====

    async def deactivate_package(self, package_id: int) -> Optional[ContentPackage]:
        """
        Desactiva un paquete (soft delete).

        No elimina el registro, solo marca is_active=False.

        Args:
            package_id: ID del paquete a desactivar

        Returns:
            ContentPackage si existe, None si no
        """
        package = await self.get_package(package_id)

        if not package:
            logger.warning(f"üì¶ Paquete no encontrado para desactivar: {package_id}")
            return None

        package.is_active = False
        package.updated_at = datetime.utcnow()

        # NO commit - dejar que el handler gestione la transacci√≥n

        logger.info(f"‚úÖ Paquete desactivado: {package_id} - {package.name}")

        return package

    async def activate_package(self, package_id: int) -> Optional[ContentPackage]:
        """
        Reactiva un paquete (soft delete undo).

        Args:
            package_id: ID del paquete a reactivar

        Returns:
            ContentPackage si existe, None si no
        """
        package = await self.get_package(package_id)

        if not package:
            logger.warning(f"üì¶ Paquete no encontrado para reactivar: {package_id}")
            return None

        package.is_active = True
        package.updated_at = datetime.utcnow()

        # NO commit - dejar que el handler gestione la transacci√≥n

        logger.info(f"‚úÖ Paquete reactivado: {package_id} - {package.name}")

        return package

    async def toggle_package_active(self, package_id: int) -> Tuple[bool, Optional[ContentPackage]]:
        """
        Alterna el estado activo de un paquete.

        Args:
            package_id: ID del paquete

        Returns:
            Tuple (nuevo_estado, ContentPackage) - (True, package) si √©xito, (False, None) si no existe
        """
        package = await self.get_package(package_id)

        if not package:
            return (False, None)

        package.is_active = not package.is_active
        package.updated_at = datetime.utcnow()

        # NO commit

        logger.info(
            f"‚úÖ Paquete {'activado' if package.is_active else 'desactivado'}: "
            f"{package_id} - {package.name}"
        )

        return (True, package)

    # ===== SEARCH =====

    async def search_packages(
        self,
        search_term: str,
        is_active: Optional[bool] = None,
        limit: int = 50
    ) -> List[ContentPackage]:
        """
        Busca paquetes por nombre o descripci√≥n.

        Args:
            search_term: T√©rmino de b√∫squeda
            is_active: Filtrar por estado (opcional)
            limit: M√°ximo de resultados (default: 50)

        Returns:
            Lista de ContentPackage que coinciden con la b√∫squeda
        """
        search_pattern = f"%{search_term}%"

        query = select(ContentPackage).where(
            or_(
                ContentPackage.name.ilike(search_pattern),
                ContentPackage.description.ilike(search_pattern)
            )
        ).order_by(ContentPackage.created_at.desc())

        if is_active is not None:
            query = query.where(ContentPackage.is_active == is_active)

        query = query.limit(limit)

        result = await self.session.execute(query)
        packages = list(result.scalars().all())

        logger.debug(f"üì¶ B√∫squeda '{search_term}': {len(packages)} resultados")

        return packages
```

Key requirements:
- Follow SubscriptionService pattern exactly (async methods, session injection, no commits)
- Use select() from sqlalchemy (SQLAlchemy 2.0 style)
- Use scalar_one_or_none() for single result queries
- Add comprehensive logging (DEBUG for queries, INFO for changes)
- Add input validations (empty name, negative price)
- Convert float to Decimal for price (storage precision)
- Auto-update updated_at timestamp in update methods
- Add docstrings (Google Style)
- Type hints for all parameters and returns
  </action>
  <verify>
# Check ContentService structure and methods
python -c "
from bot.services.content import ContentService
from bot.database.enums import ContentCategory
import inspect

# Verify class exists
assert ContentService is not None

# Verify required methods exist
methods = [
    'create_package',
    'get_package',
    'list_packages',
    'get_active_packages',
    'count_packages',
    'update_package',
    'deactivate_package',
    'activate_package',
    'toggle_package_active',
    'search_packages'
]

for method in methods:
    assert hasattr(ContentService, method), f'Missing method: {method}'

# Verify create_package signature
sig = inspect.signature(ContentService.create_package)
params = list(sig.parameters.keys())
assert 'name' in params, 'Missing name parameter'
assert 'category' in params, 'Missing category parameter'

# Verify methods are async
import asyncio
for method in methods:
    method_obj = getattr(ContentService, method)
    assert asyncio.iscoroutinefunction(method_obj), f'{method} must be async'

print('‚úÖ ContentService structure verified')
"
  </verify>
  <done>
ContentService exists with all CRUD methods (create, read, update, deactivate, search) following SubscriptionService pattern
  </done>
</task>

<task type="auto">
  <name>Integrate ContentService into ServiceContainer</name>
  <files>bot/services/container.py</files>
  <action>
Modify bot/services/container.py to add content property:

1. Add _content_service private attribute in __init__:
   After line 55 (after self._role_detection_service = None, following alphabetical order):
   Add: self._content_service = None

2. Add content property after the role_detection property (alphabetical order):
```python
    # ===== CONTENT SERVICE =====

    @property
    def content(self):
        """
        Service de gesti√≥n de paquetes de contenido.

        Se carga lazy (solo en primer acceso).

        Returns:
            ContentService: Instancia del service
        """
        if self._content_service is None:
            from bot.services.content import ContentService
            logger.debug("üîÑ Lazy loading: ContentService")
            self._content_service = ContentService(self._session)

        return self._content_service
```

Key requirements:
- Follow existing lazy loading pattern
- Add DEBUG logging for lazy loading
- Only pass session (ContentService doesn't need bot)
- Place property logically after role_detection
  </action>
  <verify>
# Verify container has content property
python -c "
from bot.services.container import ServiceContainer

# Verify property exists
assert hasattr(ServiceContainer, 'content'), 'Missing content property'

# Verify it's a property
assert isinstance(type(ServiceContainer.content), property), 'content must be @property'

# Test lazy loading structure
import inspect
prop = ServiceContainer.content
assert prop.fget is not None, 'content property must have getter'

print('‚úÖ ServiceContainer.content property verified')
"
  </verify>
  <done>
ServiceContainer has content property with lazy loading following existing pattern
  </done>
</task>

<task type="auto">
  <name>Export ContentService from services __init__.py</name>
  <files>bot/services/__init__.py</files>
  <action>
Modify bot/services/__init__.py to export ContentService:

Check if __init__.py exists and has existing exports. Add:

```python
from bot.services.content import ContentService
```

If __all__ exists in the file, add "ContentService" to the list.

If __init__.py doesn't exist or is minimal, ensure the import is present for:
```python
from bot.services import ContentService
```

Key requirements:
- Follow existing export pattern in the file
- Add to __all__ if it exists
- Otherwise, import is sufficient
  </action>
  <verify>
# Verify import works
python -c "
from bot.services import ContentService

# Verify class is importable
assert ContentService is not None

# Verify it has the expected methods
assert hasattr(ContentService, 'create_package')
assert hasattr(ContentService, 'get_package')

print('‚úÖ ContentService export verified')
"
  </verify>
  <done>
ContentService is exportable from bot.services module
  </done>
</task>

</tasks>

<verification>
# Overall Phase 5-3 Verification

## 1. ContentService CRUD Operations Test
```bash
python -c "
import asyncio
from bot.database.engine import get_session
from bot.services.content import ContentService
from bot.database.enums import ContentCategory, PackageType
from decimal import Decimal

async def test_content_service():
    async with get_session() as session:
        async with session.begin():
            service = ContentService(session)

            # Test: Create package
            pkg = await service.create_package(
                name='Test Package',
                category=ContentCategory.VIP_CONTENT,
                description='Test description',
                price=Decimal('9.99')
            )
            assert pkg.id is not None
            print(f'‚úÖ Package created: {pkg.id} - {pkg.name}')

            # Test: Get package
            retrieved = await service.get_package(pkg.id)
            assert retrieved is not None
            assert retrieved.name == 'Test Package'
            print('‚úÖ Package retrieved successfully')

            # Test: List packages
            packages = await service.list_packages(is_active=True)
            assert len(packages) >= 1
            print(f'‚úÖ Listed {len(packages)} active packages')

            # Test: Update package
            updated = await service.update_package(pkg.id, description='Updated description')
            assert updated.description == 'Updated description'
            print('‚úÖ Package updated successfully')

            # Test: Deactivate package
            deactivated = await service.deactivate_package(pkg.id)
            assert deactivated.is_active == False
            print('‚úÖ Package deactivated successfully')

    print('‚úÖ All ContentService CRUD operations work correctly')

asyncio.run(test_content_service())
"
```

## 2. ServiceContainer Integration Test
```bash
python -c "
import asyncio
from bot.database.engine import get_session
from bot.services.container import ServiceContainer

async def test_container():
    async with get_session() as session:
        from aiogram import Bot
        # Mock bot for testing
        class MockBot:
            pass

        container = ServiceContainer(session, MockBot())

        # Test lazy loading
        content_service = container.content
        assert content_service is not None
        print('‚úÖ ContentService loaded from container')

        # Test caching (second call returns same instance)
        content_service2 = container.content
        assert content_service is content_service2
        print('‚úÖ ContentService cached correctly')

asyncio.run(test_container())
"
```

## 3. Input Validation Test
```bash
python -c "
import asyncio
from bot.database.engine import get_session
from bot.services.content import ContentService
from bot.database.enums import ContentCategory

async def test_validations():
    async with get_session() as session:
        async with session.begin():
            service = ContentService(session)

            # Test: Empty name raises ValueError
            try:
                await service.create_package(name='', category=ContentCategory.FREE_CONTENT)
                assert False, 'Should have raised ValueError'
            except ValueError as e:
                assert 'no puede estar vac√≠o' in str(e)
                print('‚úÖ Empty name validation works')

            # Test: Negative price raises ValueError
            try:
                await service.create_package(name='Test', category=ContentCategory.FREE_CONTENT, price=-10)
                assert False, 'Should have raised ValueError'
            except ValueError as e:
                assert 'no puede ser negativo' in str(e)
                print('‚úÖ Negative price validation works')

asyncio.run(test_validations())
"
```
</verification>

<success_criteria>
1. ContentService.create_package() creates ContentPackage with all fields
2. ContentService.get_package(id) returns package or None
3. ContentService.list_packages() returns list with optional filters (category, type, is_active)
4. ContentService.update_package() updates specified fields and updates updated_at
5. ContentService.deactivate_package() sets is_active=False (soft delete)
6. ContentService.toggle_package_active() toggles is_active and returns new state
7. ContentService.search_packages() searches by name/description with LIKE pattern
8. All methods are async (using async def)
9. No methods call session.commit() - handlers manage transactions
10. ServiceContainer.content property loads ContentService lazily
11. Float prices converted to Decimal for storage precision
12. Input validations work (empty name, negative price)
</success_criteria>

<output>
After completion, create `.planning/phases/05-role-detection-database/05-03-SUMMARY.md` with:

1. Frontmatter with phase, plan, subsystem, dependencies, tech-stack, key-files, key-decisions, patterns-established, duration, completed date
2. Summary of ContentService implementation (CRUD methods, validation, search)
3. Integration with ServiceContainer (lazy loading)
4. Any deviations from plan or discovered edge cases
5. Test results summary
</output>

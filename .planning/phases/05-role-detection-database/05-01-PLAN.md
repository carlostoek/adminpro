---
phase: 05-role-detection-database
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - bot/services/role_detection.py
  - bot/middlewares/role_detection.py
  - bot/services/container.py
  - bot/middlewares/__init__.py
autonomous: true

must_haves:
  truths:
    - "Sistema detecta autom√°ticamente si un usuario es Admin, VIP o Free al interactuar"
    - "Rol se recalcula en cada interacci√≥n (sin cach√©)"
    - "Handlers reciben user_role inyectado en data dictionary"
    - "RoleDetectionService sigue patr√≥n stateless de SubscriptionService"
    - "RoleDetectionMiddleware sigue patr√≥n de AdminAuthMiddleware"
  artifacts:
    - path: "bot/services/role_detection.py"
      provides: "RoleDetectionService with get_user_role() method"
      exports: ["RoleDetectionService"]
      min_lines: 80
    - path: "bot/middlewares/role_detection.py"
      provides: "RoleDetectionMiddleware injecting user_role into data"
      exports: ["RoleDetectionMiddleware"]
      min_lines: 80
    - path: "bot/services/container.py"
      provides: "ServiceContainer.role_detection property for lazy loading"
      contains: "@property def role_detection"
      min_lines: 10 (new code)
    - path: "bot/middlewares/__init__.py"
      provides: "Export of RoleDetectionMiddleware"
      contains: "from bot.middlewares.role_detection import RoleDetectionMiddleware"
  key_links:
    - from: "bot/middlewares/role_detection.py"
      to: "bot/services/role_detection.py"
      via: "RoleDetectionService(session) instantiation"
      pattern: "RoleDetectionService\(.*session"
    - from: "bot/services/role_detection.py"
      to: "config.py"
      via: "Config.is_admin() call for admin detection"
      pattern: "Config\.is_admin\("
    - from: "bot/services/role_detection.py"
      to: "bot/services/subscription.py"
      via: "container.subscription.is_vip_active() call for VIP detection"
      pattern: "\.is_vip_active\("
---

<objective>
Create RoleDetectionService with stateless role calculation (Admin > VIP > Free priority) and RoleDetectionMiddleware that injects detected role into handler data dictionary for role-based menu routing.

Purpose: Enable automatic role detection for personalized user menus - MENU-01 requirement
Output: Working role detection system integrated with ServiceContainer and middleware pipeline
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-role-detection-database/05-CONTEXT.md
@.planning/phases/05-role-detection-database/05-RESEARCH.md

# Existing patterns to follow
@bot/services/subscription.py
@bot/middlewares/admin_auth.py
@bot/services/container.py
@bot/database/enums.py
@config.py
</context>

<tasks>

<task type="auto">
  <name>Create RoleDetectionService with stateless role calculation</name>
  <files>bot/services/role_detection.py</files>
  <action>
Create bot/services/role_detection.py with RoleDetectionService class:

```python
"""
Role Detection Service - Detecta autom√°ticamente el rol del usuario (Admin/VIP/Free).

Responsabilidades:
- Detectar rol bas√°ndose en prioridad: Admin > VIP > Free
- C√°lculo stateless (sin cach√©) para evitar roles stale
- Integraci√≥n con Config.is_admin() y SubscriptionService.is_vip_active()

Pattern: Stateless service following SubscriptionService architecture
"""
import logging
from typing import Optional

from sqlalchemy.ext.asyncio import AsyncSession

from bot.database.enums import UserRole
from config import Config

logger = logging.getLogger(__name__)


class RoleDetectionService:
    """
    Servicio para detectar el rol de un usuario.

    Prioridad de detecci√≥n:
    1. Admin (Config.is_admin() - highest priority)
    2. VIP (SubscriptionService.is_vip_active() - active subscription)
    3. Free (default fallback)

    El servicio es stateless - no cachea resultados.
    Esto garantiza que el rol siempre se recalcule desde fuentes frescas.
    """

    def __init__(self, session: AsyncSession):
        """
        Inicializa el service.

        Args:
            session: Sesi√≥n de base de datos SQLAlchemy
        """
        self.session = session
        logger.debug("‚úÖ RoleDetectionService inicializado")

    async def get_user_role(self, user_id: int) -> UserRole:
        """
        Detecta el rol actual del usuario.

        Prioridad: Admin > VIP > Free (primer match wins)

        Args:
            user_id: ID de Telegram del usuario

        Returns:
            UserRole: Rol detectado (ADMIN, VIP, or FREE)
        """
        # 1. Check Admin (highest priority)
        if Config.is_admin(user_id):
            logger.debug(f"üëë User {user_id} detectado como ADMIN")
            return UserRole.ADMIN

        # 2. Check VIP (active subscription)
        # Import local para evitar circular dependency
        from bot.services.subscription import SubscriptionService

        # Necesitamos una instancia de Bot - se inyectar√° v√≠a container
        # Por ahora, usamos el service directamente sin bot (is_vip_active no lo necesita)
        subscription_service = SubscriptionService(self.session, bot=None)

        is_vip = await subscription_service.is_vip_active(user_id)
        if is_vip:
            logger.debug(f"‚≠ê User {user_id} detectado como VIP")
            return UserRole.VIP

        # 3. Default to Free
        logger.debug(f"üÜì User {user_id} detectado como FREE")
        return UserRole.FREE

    async def refresh_user_role(self, user_id: int) -> UserRole:
        """
        Alias de get_user_role para consistencia de API.

        Este m√©todo existe por claridad sem√°ntica:
        - get_user_role: Obtener rol (no implica cach√©)
        - refresh_user_role: Recalcular rol (expl√≠cito que es fresco)

        Ambos retornan el mismo resultado (c√°lculo stateless).
        """
        return await self.get_user_role(user_id)

    def is_admin(self, user_id: int) -> bool:
        """
        Verifica si un usuario es admin (m√©todo helper s√≠ncrono).

        Args:
            user_id: ID de Telegram del usuario

        Returns:
            True si es admin, False en caso contrario
        """
        return Config.is_admin(user_id)
```

Key requirements:
- Follow SubscriptionService pattern (stateless, session injection)
- Priority order: Admin > VIP > Free
- NO caching - role calculated fresh each time
- Use Config.is_admin() for admin detection
- Use SubscriptionService.is_vip_active() for VIP detection
- Add logging at DEBUG level for role detection results
- Add type hints (UserRole enum return)
- Google Style docstrings
  </action>
  <verify>
# Check file exists and has expected structure
python -c "
from bot.services.role_detection import RoleDetectionService
from bot.database.enums import UserRole
import inspect

# Verify class exists
assert RoleDetectionService is not None

# Verify methods exist
methods = ['get_user_role', 'refresh_user_role', 'is_admin']
for m in methods:
    assert hasattr(RoleDetectionService, m), f'Missing method: {m}'

# Verify method signatures
sig = inspect.signature(RoleDetectionService.get_user_role)
assert 'user_id' in sig.parameters, 'get_user_role missing user_id param'

print('‚úÖ RoleDetectionService structure verified')
"
  </verify>
  <done>
RoleDetectionService exists with get_user_role(), refresh_user_role(), and is_admin() methods following SubscriptionService pattern
  </done>
</task>

<task type="auto">
  <name>Create RoleDetectionMiddleware for role injection</name>
  <files>bot/middlewares/role_detection.py</files>
  <action>
Create bot/middlewares/role_detection.py with RoleDetectionMiddleware class:

```python
"""
Role Detection Middleware - Detecta e inyecta el rol del usuario en handlers.

Se aplica globalmente para que todos los handlers tengan acceso a user_role.
Si el usuario no tiene sesi√≥n disponible, ejecuta el handler sin role injection.
"""
import logging
from typing import Callable, Dict, Any, Awaitable

from aiogram import BaseMiddleware
from aiogram.types import Message, CallbackQuery, TelegramObject

from bot.services.role_detection import RoleDetectionService

logger = logging.getLogger(__name__)


class RoleDetectionMiddleware(BaseMiddleware):
    """
    Middleware que detecta e inyecta el rol del usuario.

    Uso:
        # Aplicar globalmente o a routers espec√≠ficos:
        dp.message.middleware(RoleDetectionMiddleware())
        dp.callback_query.middleware(RoleDetectionMiddleware())

    Inyecta en data dictionary:
        - data["user_role"]: UserRole (ADMIN, VIP, or FREE)
        - data["user_id"]: int (user ID from Telegram)

    Si no hay sesi√≥n disponible:
        - Ejecuta handler sin inyectar user_role
        - No falla, permite handlers que no necesitan BD

    Pattern: Sigue AdminAuthMiddleware structure (user extraction, data injection)
    """

    async def __call__(
        self,
        handler: Callable[[TelegramObject, Dict[str, Any]], Awaitable[Any]],
        event: TelegramObject,
        data: Dict[str, Any]
    ) -> Any:
        """
        Ejecuta el middleware.

        Args:
            handler: Handler a ejecutar despu√©s de la detecci√≥n
            event: Evento de Telegram (Message, CallbackQuery, etc)
            data: Data del handler (incluye bot, session, etc)

        Returns:
            Resultado del handler con user_role inyectado en data
        """
        # Extraer user del evento (siguiendo patr√≥n AdminAuthMiddleware)
        user = None

        if isinstance(event, Message):
            user = event.from_user
        elif isinstance(event, CallbackQuery):
            user = event.from_user

        if user is None:
            # Edge case: no se pudo extraer usuario
            logger.debug("‚ö†Ô∏è No se pudo extraer usuario del evento")
            return await handler(event, data)

        # Obtener sesi√≥n del data dictionary
        session = data.get("session")

        if session is None:
            # No hay sesi√≥n disponible (handler no requiere BD)
            logger.debug("‚ö†Ô∏è No hay sesi√≥n disponible, ejecutando handler sin role injection")
            return await handler(event, data)

        # Detectar rol e inyectar en data
        role_service = RoleDetectionService(session)
        user_role = await role_service.get_user_role(user.id)

        data["user_role"] = user_role
        data["user_id"] = user.id

        logger.debug(
            f"‚úÖ Rol inyectado: user {user.id} (@{user.username or 'sin username'}) "
            f"‚Üí {user_role.value}"
        )

        # Ejecutar handler con user_role disponible en data
        return await handler(event, data)
```

Key requirements:
- Follow AdminAuthMiddleware pattern (event type checking, user extraction)
- Extract user from Message or CallbackQuery
- Check for session in data dictionary (graceful degradation)
- Inject user_role and user_id into data dictionary
- Add DEBUG logging for role injection
- Don't fail if no session - execute handler without role injection
- Google Style docstrings
  </action>
  <verify>
# Check middleware exists and has expected structure
python -c "
from bot.middlewares.role_detection import RoleDetectionMiddleware
from aiogram import BaseMiddleware
import inspect

# Verify class exists and inherits from BaseMiddleware
assert RoleDetectionMiddleware is not None
assert issubclass(RoleDetectionMiddleware, BaseMiddleware), 'Must inherit from BaseMiddleware'

# Verify __call__ method exists
assert hasattr(RoleDetectionMiddleware, '__call__'), 'Missing __call__ method'

# Verify it's callable (middleware protocol)
middleware = RoleDetectionMiddleware()
assert callable(middleware), 'Middleware instance must be callable'

print('‚úÖ RoleDetectionMiddleware structure verified')
"
  </verify>
  <done>
RoleDetectionMiddleware exists inheriting from BaseMiddleware, injecting user_role and user_id into data dictionary
  </done>
</task>

<task type="auto">
  <name>Integrate RoleDetectionService into ServiceContainer</name>
  <files>bot/services/container.py</files>
  <action>
Modify bot/services/container.py to add role_detection property:

1. Add _role_detection_service private attribute in __init__:
   After line 55 (after self._session_history = None):
   Add: self._role_detection_service = None

2. Add role_detection property after the session_history property:
```python
    # ===== ROLE DETECTION SERVICE =====

    @property
    def role_detection(self):
        """
        Service de detecci√≥n de roles (Admin/VIP/Free).

        Se carga lazy (solo en primer acceso).

        Returns:
            RoleDetectionService: Instancia del service
        """
        if self._role_detection_service is None:
            from bot.services.role_detection import RoleDetectionService
            logger.debug("üîÑ Lazy loading: RoleDetectionService")
            self._role_detection_service = RoleDetectionService(self._session)

        return self._role_detection_service
```

Key requirements:
- Follow existing lazy loading pattern (check None, import, instantiate, cache)
- Add DEBUG logging for lazy loading
- Only pass session (not bot) - RoleDetectionService doesn't need bot
- Place property logically after session_history (alphabetical or grouped by subsystem)
  </action>
  <verify>
# Verify container has role_detection property
python -c "
from bot.services.container import ServiceContainer

# Verify property exists
assert hasattr(ServiceContainer, 'role_detection'), 'Missing role_detection property'

# Verify it's a property (descriptor)
assert isinstance(type(ServiceContainer.role_detection), property), 'role_detection must be @property'

# Test lazy loading (without actual session)
import inspect
prop = ServiceContainer.role_detection
assert prop.fget is not None, 'role_detection property must have getter'

print('‚úÖ ServiceContainer.role_detection property verified')
"
  </verify>
  <done>
ServiceContainer has role_detection property with lazy loading following existing pattern
  </done>
</task>

<task type="auto">
  <name>Export RoleDetectionMiddleware from middlewares __init__.py</name>
  <files>bot/middlewares/__init__.py</files>
  <action>
Modify bot/middlewares/__init__.py to export RoleDetectionMiddleware:

Add import statement after existing imports:
```python
from bot.middlewares.role_detection import RoleDetectionMiddleware
```

Update __all__ list to include RoleDetectionMiddleware (if __all__ exists):
Add "RoleDetectionMiddleware" to the list

Key requirements:
- Follow existing export pattern
- Add to __all__ if it exists
- Otherwise, import is sufficient for from bot.middlewares import RoleDetectionMiddleware
  </action>
  <verify>
# Verify import works
python -c "
from bot.middlewares import RoleDetectionMiddleware
from aiogram import BaseMiddleware

# Verify class is importable
assert RoleDetectionMiddleware is not None
assert issubclass(RoleDetectionMiddleware, BaseMiddleware), 'Must inherit from BaseMiddleware'

print('‚úÖ RoleDetectionMiddleware export verified')
"
  </verify>
  <done>
RoleDetectionMiddleware is exportable from bot.middlewares module
  </done>
</task>

</tasks>

<verification>
# Overall Phase 5-1 Verification

## 1. Role Detection Logic Tests
```bash
# Run these tests after implementation
python -c "
import asyncio
from bot.database.engine import get_session
from bot.services.role_detection import RoleDetectionService
from bot.database.enums import UserRole

async def test_role_detection():
    async with get_session() as session:
        service = RoleDetectionService(session)

        # Test with known admin ID (replace with actual admin ID from .env)
        # Test VIP detection (would need VIPSubscriber record)
        # Test Free fallback

        print('‚úÖ Role detection service functional')

asyncio.run(test_role_detection())
"
```

## 2. Middleware Integration Test
- Verify RoleDetectionMiddleware can be added to dispatcher
- Verify handlers receive user_role in data dictionary

## 3. ServiceContainer Integration Test
- Verify container.role_detection property loads lazily
- Verify subsequent calls return cached instance
</verification>

<success_criteria>
1. RoleDetectionService.get_user_role(user_id) returns UserRole enum (ADMIN, VIP, or FREE)
2. Role calculation follows priority: Admin > VIP > Free
3. RoleDetectionMiddleware injects user_role into data["user_role"] for all handlers
4. ServiceContainer.role_detection property loads service lazily
5. No role caching - each call recalculates from database sources
6. Graceful degradation when session not available in data dictionary
7. All services follow existing codebase patterns (SubscriptionService, AdminAuthMiddleware)
</success_criteria>

<output>
After completion, create `.planning/phases/05-role-detection-database/05-01-SUMMARY.md` with:

1. Frontmatter with phase, plan, subsystem, dependencies, tech-stack, key-files, key-decisions, patterns-established, duration, completed date
2. Summary of role detection implementation (stateless calculation, middleware injection, lazy loading)
3. Performance metrics (role detection speed, overhead per request)
4. Any deviations from plan or discovered edge cases
</output>

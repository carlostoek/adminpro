---
phase: 13-vip-ritualized-entry
plan: 03
type: execute
wave: 2
depends_on: [01, 02]
files_modified:
  - bot/states/user.py (add VIPEntryStates)
  - bot/handlers/user/vip_entry.py (NEW FILE)
  - bot/handlers/user/start.py (modify activation logic)
  - bot/handlers/vip/menu.py (add vip_entry_stage check and redirect)
  - main.py (register vip_entry_router)
autonomous: true
estimated_minutes: 15

must_haves:
  truths:
    - "VIPEntryStates FSM group exists with stage_1, stage_2, stage_3 states"
    - "/start handler checks vip_entry_stage and routes to vip_entry flow"
    - "VIP menu handler checks vip_entry_stage and redirects to entry flow if incomplete"
    - "vip_entry:stage_2 callback advances from stage 1 to stage 2"
    - "vip_entry:stage_3 callback advances from stage 2 to stage 3"
    - "Expiry check blocks continuation if VIPSubscriber expired"
    - "Seamless resumption from current stage if user abandons"
    - "UserRole changes from FREE to VIP only after Stage 3"
    - "VIPEntryFlowMessages accessed via container.message.user.vip_entry"
  artifacts:
    - path: "bot/states/user.py"
      provides: "VIPEntryStates FSM group for 3-stage flow"
      min_lines: 15
    - path: "bot/handlers/user/vip_entry.py"
      provides: "VIP entry flow handlers with stage transitions"
      min_lines: 200
    - path: "bot/handlers/user/start.py"
      provides: "Modified /start to check vip_entry_stage"
      min_lines: 20
    - path: "bot/handlers/vip/menu.py"
      provides: "VIP menu check for incomplete entry flow with redirect"
      min_lines: 30
  key_links:
    - from: "bot/handlers/user/vip_entry.py"
      to: "bot/services/message/vip_entry.py (Plan 02)"
      via: "VIPEntryFlowMessages for ritual messages"
      pattern: "container.message.user.vip_entry"
    - from: "bot/handlers/user/vip_entry.py"
      to: "bot/services/vip_entry.py (Plan 04)"
      via: "VIPEntryService for stage validation and advancement"
      pattern: "container.vip_entry"
    - from: "bot/handlers/user/start.py"
      to: "bot/handlers/user/vip_entry.py"
      via: "Route to vip_entry flow if vip_entry_stage is set"
      pattern: "vip_entry_stage"
    - from: "bot/handlers/vip/menu.py"
      to: "bot/handlers/user/vip_entry.py"
      via: "VIP menu redirects incomplete entry flow to show_vip_entry_stage()"
      pattern: "show_vip_entry_stage"
---

# Plan 03: VIP Entry FSM States and Handlers

## Objective

Implement VIPEntryStates FSM group and handlers for 3-stage flow with stage transition validation, expiry checking, and seamless resumption logic.

**Purpose:**
Create the handler layer that orchestrates the 3-stage ritual flow, using VIPEntryFlowMessages for display and VIPEntryService for business logic.

**Output:**
- VIPEntryStates FSM group with 3 states
- VIP entry handler module with message and callback handlers
- Modified /start handler to detect vip_entry_stage and route to entry flow
- Expiry validation before allowing stage progression
- Seamless resumption from current stage after abandonment

---

## Context

### Current /start Flow (bot/handlers/user/start.py, line 177+)

**Current Behavior:**
```python
# Token validated â†’ VIPSubscriber created
subscriber = await container.subscription.activate_vip_subscription(
    user_id=user.user_id,
    token_id=token.id,
    duration_hours=plan.duration_days * 24
)

# UserRole set to VIP immediately
user.role = UserRole.VIP

# Invite link generated immediately
invite_link = await container.subscription.create_invite_link(...)

# Success message with link sent
success_text, keyboard = container.message.user.start.deep_link_activation_success(...)
```

**New Behavior (Phase 13):**
```python
# Token validated â†’ VIPSubscriber created with vip_entry_stage=1
subscriber = await container.subscription.activate_vip_subscription(...)

# UserRole remains FREE (no change)
# user.role = UserRole.FREE  # Still FREE until Stage 3

# Send Stage 1 message (not immediate link)
from bot.handlers.user.vip_entry import show_vip_entry_stage
await show_vip_entry_stage(message, container, subscriber.vip_entry_stage)
```

### FSM State Pattern (from existing FreeAccessStates)

**Current Pattern (bot/states/user.py):**
```python
class FreeAccessStates(StatesGroup):
    waiting_for_approval = State()
```

**New Pattern (VIPEntryStates):**
```python
class VIPEntryStates(StatesGroup):
    """
    Estados para flujo ritual de entrada VIP.

    Flujo:
    1. Stage 1: ConfirmaciÃ³n de activaciÃ³n â†’ user pulsa "Continuar"
    2. Stage 2: AlineaciÃ³n de expectativas â†’ user pulsa "Estoy listo"
    3. Stage 3: Entrega de enlace â†’ user accede al canal

    Estados:
    - stage_1_confirmation: Usuario en etapa 1 (espera "Continuar")
    - stage_2_alignment: Usuario en etapa 2 (espera "Estoy listo")
    - stage_3_delivery: Enlace enviado (espera que user se una al canal)

    Abandono: Usuario puede abandonar y retomar desde etapa actual
    (no hay timeout, estado persiste en vip_entry_stage field)
    """
    stage_1_confirmation = State()
    stage_2_alignment = State()
    stage_3_delivery = State()
```

### VIP Entry Flow Logic

**Entry Points:**
1. **/start with token** â†’ Creates VIPSubscriber with vip_entry_stage=1
2. **/start without token** â†’ Checks vip_entry_stage, resumes if set
3. **VIP menu open** â†’ Checks vip_entry_stage, shows entry flow if incomplete

**Stage Transitions:**
```
Stage 1 (vip_entry_stage=1)
  â†’ User clicks "Continuar" (vip_entry:stage_2)
  â†’ Validate subscription expiry
  â†’ Advance to vip_entry_stage=2
  â†’ Show Stage 2 message

Stage 2 (vip_entry_stage=2)
  â†’ User clicks "Estoy listo" (vip_entry:stage_3)
  â†’ Validate subscription expiry
  â†’ Generate unique vip_entry_token
  â†’ Create 24h invite link
  â†’ Change UserRole to VIP
  â†’ Advance to vip_entry_stage=3
  â†’ Show Stage 3 message with link

Stage 3 (vip_entry_stage=3)
  â†’ User clicks "Cruzar el umbral" (URL button)
  â†’ Joins VIP channel
  â†’ vip_entry_stage set to NULL (complete)
```

**Expiry Handling:**
```
Any Stage (1 or 2)
  â†’ Check VIPSubscriber.expiry_date < datetime.utcnow()
  â†’ If expired: Show Lucien's expiry message, block continuation
  â†’ No retry option (subscription must be renewed)
```

**Resumption Logic:**
```
User returns after abandoning:
  â†’ Check vip_entry_stage in database
  â†’ Show stage_resumption_message() briefly
  â†’ Display current stage message (no "welcome back" drama)
```

---

## Tasks

### T1: Add VIPEntryStates to FSM States
**File:** `bot/states/user.py`

**Location:** After FreeAccessStates class (end of file)

**Changes:**
```python
class VIPEntryStates(StatesGroup):
    """
    Estados para flujo ritual de entrada VIP.

    Flujo:
    1. Stage 1: ConfirmaciÃ³n de activaciÃ³n â†’ user pulsa "Continuar"
    2. Stage 2: AlineaciÃ³n de expectativas â†’ user pulsa "Estoy listo"
    3. Stage 3: Entrega de enlace â†’ user accede al canal

    Estados:
    - stage_1_confirmation: Usuario en etapa 1 (espera "Continuar")
    - stage_2_alignment: Usuario en etapa 2 (espera "Estoy listo")
    - stage_3_delivery: Enlace enviado (espera que user se una al canal)

    Abandono: Usuario puede abandonar y retomar desde etapa actual
    (no hay timeout, estado persiste en vip_entry_stage field)

    ExpiraciÃ³n: Si VIPSubscriber expira durante etapas 1-2,
    se muestra mensaje de Lucien y se bloquea continuaciÃ³n.
    """
    stage_1_confirmation = State()
    stage_2_alignment = State()
    stage_3_delivery = State()
```

**Acceptance:**
- [ ] VIPEntryStates class added after FreeAccessStates
- [ ] 3 states defined: stage_1_confirmation, stage_2_alignment, stage_3_delivery
- [ ] Docstring explains flow, abandonment, and expiry handling
- [ ] Inherits from StatesGroup

---

### T2: Create VIP Entry Handler Module
**File:** `bot/handlers/user/vip_entry.py` (NEW FILE)

**Structure:**
```python
"""
VIP Entry Flow Handlers - 3-stage ritual admission.

Phase 13: Ritualized VIP entry flow replacing immediate link delivery.

Entry Points:
- /start with token activation (creates vip_entry_stage=1)
- /start without token (resumes from current vip_entry_stage)
- VIP menu open (checks vip_entry_stage for incomplete flow)

Stage Transitions:
- Stage 1 â†’ Stage 2: "Continuar" button (vip_entry:stage_2)
- Stage 2 â†’ Stage 3: "Estoy listo" button (vip_entry:stage_3)
- Stage 3 â†’ Complete: User joins channel, vip_entry_stage=NULL

Expiry Handling:
- Check subscription expiry before allowing stage progression
- Show Lucien's expiry message if expired (blocks continuation)
- No retry option (must renew subscription)

Resumption:
- Seamless return to current stage (no timeout)
- Brief stage_resumption_message() then current stage message
"""
import logging
from datetime import datetime

from aiogram import Router
from aiogram.filters import StateFilter
from aiogram.types import Message, CallbackQuery
from aiogram.fsm.context import FSMContext
from sqlalchemy.ext.asyncio import AsyncSession

from bot.states.user import VIPEntryStates
from bot.services.container import ServiceContainer
from bot.services.message.vip_entry import VIPEntryFlowMessages
from bot.database.enums import UserRole, RoleChangeReason

logger = logging.getLogger(__name__)

# Router for VIP entry handlers
vip_entry_router = Router(name="vip_entry")

# Middleware registration
vip_entry_router.message.middleware(DatabaseMiddleware())
vip_entry_router.callback_query.middleware(DatabaseMiddleware())
```

**Acceptance:**
- [ ] File created with vip_entry_router
- [ ] DatabaseMiddleware registered
- [ ] Imports include all necessary dependencies
- [ ] Module docstring explains flow and entry points

---

### T3: Implement Stage Display Function
**File:** `bot/handlers/user/vip_entry.py`

**Implementation:**
```python
async def show_vip_entry_stage(
    message: Message,
    container: ServiceContainer,
    stage: int,
    state: FSMContext = None
):
    """
    Muestra el mensaje correspondiente a la etapa actual del flujo VIP.

    Args:
        message: Mensaje original (para respuesta)
        container: Service container
        stage: Etapa actual (1, 2, o 3)
        state: FSM context (opcional, para establecer estado)

    Flow:
        - Stage 1: Mostrar confirmaciÃ³n de activaciÃ³n
        - Stage 2: Mostrar alineaciÃ³n de expectativas
        - Stage 3: Mostrar mensaje con enlace (invoca VIPEntryService)
    """
    user_id = message.from_user.id
    provider: VIPEntryFlowMessages = container.message.user.vip_entry
    service = container.vip_entry

    # Verificar expiraciÃ³n de suscripciÃ³n (antes de mostrar etapa)
    subscriber = await container.subscription.get_vip_subscriber(user_id)

    if not subscriber:
        logger.error(f"âŒ VIPSubscriber not found for user {user_id} in entry flow")
        await message.answer(
            "âŒ Error: SuscripciÃ³n no encontrada. Contacte al administrador."
        )
        return

    # Expiry check (critical - blocks continuation)
    if subscriber.is_expired():
        logger.info(f"âš ï¸ User {user_id} VIP subscription expired during entry flow")
        expiry_msg = provider.expired_subscription_message()
        await message.answer(expiry_msg, parse_mode="HTML")

        # Clear FSM state if exists
        if state:
            await state.clear()
        return

    # Show appropriate stage message
    if stage == 1:
        text, keyboard = provider.stage_1_activation_confirmation()
        await message.answer(text, reply_markup=keyboard, parse_mode="HTML")

        if state:
            await state.set_state(VIPEntryStates.stage_1_confirmation)

        logger.info(f"âœ… User {user_id} VIP entry stage 1 shown")

    elif stage == 2:
        text, keyboard = provider.stage_2_expectation_alignment()
        await message.answer(text, reply_markup=keyboard, parse_mode="HTML")

        if state:
            await state.set_state(VIPEntryStates.stage_2_alignment)

        logger.info(f"âœ… User {user_id} VIP entry stage 2 shown")

    elif stage == 3:
        # Stage 3 requires invite link generation
        invite_link = await service.create_24h_invite_link(user_id)

        if not invite_link:
            await message.answer(
                "âŒ Error: No se pudo generar el enlace de acceso. "
                "Contacte al administrador."
            )
            return

        text, keyboard = provider.stage_3_access_delivery(invite_link.invite_link)
        await message.answer(text, reply_markup=keyboard, parse_mode="HTML")

        if state:
            await state.set_state(VIPEntryStates.stage_3_delivery)

        logger.info(f"âœ… User {user_id} VIP entry stage 3 shown (link sent)")

    else:
        logger.error(f"âŒ Invalid VIP entry stage: {stage} for user {user_id}")
        await message.answer("âŒ Error: Etapa de flujo invÃ¡lida.")
```

**Acceptance:**
- [ ] Function checks subscription expiry before showing stage
- [ ] Expiry shows Lucien's message and blocks continuation
- [ ] Stage 1 shows activation confirmation message
- [ ] Stage 2 shows expectation alignment message
- [ ] Stage 3 generates invite link and shows delivery message
- [ ] FSM state set for each stage
- [ ] Proper error handling for missing subscriber

---

### T4: Implement Stage Transition Callback Handlers
**File:** `bot/handlers/user/vip_entry.py`

**Implementation:**
```python
@vip_entry_router.callback_query(
    lambda c: c.data and c.data.startswith("vip_entry:stage_")
)
async def handle_vip_entry_stage_transition(
    callback: CallbackQuery,
    session: AsyncSession,
    state: FSMContext
):
    """
    Maneja las transiciones entre etapas del flujo VIP.

    Callbacks:
    - vip_entry:stage_2: Avanza de etapa 1 a 2
    - vip_entry:stage_3: Avanza de etapa 2 a 3 (genera enlace, cambia rol)

    Flow:
        1. Validar suscripciÃ³n (no expirada)
        2. Avanzar vip_entry_stage
        3. Mostrar siguiente etapa
        4. (Stage 3) Cambiar UserRole a VIP, log auditorÃ­a
    """
    user_id = callback.from_user.id
    container = ServiceContainer(session, callback.bot)
    service = container.vip_entry

    # Parse callback data
    parts = callback.data.split(":")
    target_stage = int(parts[2])  # "vip_entry:stage_{N}"

    logger.info(f"ðŸŽ­ VIP entry transition: User {user_id} â†’ Stage {target_stage}")

    # Get current subscriber
    subscriber = await container.subscription.get_vip_subscriber(user_id)

    if not subscriber:
        await callback.answer("âŒ SuscripciÃ³n no encontrada", show_alert=True)
        return

    # Expiry check (critical - blocks transition)
    if subscriber.is_expired():
        logger.info(f"âš ï¸ User {user_id} VIP subscription expired during transition")
        provider = container.message.user.vip_entry
        expiry_msg = provider.expired_subscription_message()

        await callback.message.answer(expiry_msg, parse_mode="HTML")
        await callback.answer()
        await state.clear()
        return

    # Validate stage progression
    current_stage = subscriber.vip_entry_stage if subscriber.vip_entry_stage else 0

    if target_stage != current_stage + 1:
        logger.warning(
            f"âš ï¸ Invalid stage progression: {current_stage} â†’ {target_stage}"
        )
        await callback.answer("âŒ TransiciÃ³n invÃ¡lida", show_alert=True)
        return

    # Advance stage
    success = await service.advance_stage(user_id, current_stage)

    if not success:
        await callback.answer("âŒ Error al avanzar etapa", show_alert=True)
        return

    # Stage 3 special handling: UserRole change + audit log
    if target_stage == 3:
        user = await container.user.get_user(user_id)

        if user:
            # Change role from FREE to VIP
            old_role = user.role
            user.role = UserRole.VIP

            # Log role change
            await container.role_change.log_role_change(
                user_id=user_id,
                old_role=old_role,
                new_role=UserRole.VIP,
                reason=RoleChangeReason.VIP_ENTRY_COMPLETED,
                changed_by=0  # SYSTEM
            )

            logger.info(
                f"âœ… User {user_id} role changed: {old_role.value} â†’ VIP "
                f"(VIP entry flow completed)"
            )

    # Show next stage
    await show_vip_entry_stage(callback.message, container, target_stage, state)

    # Delete previous stage message (clean up)
    try:
        await callback.message.delete()
    except Exception as e:
        logger.warning(f"âš ï¸ Could not delete stage message: {e}")

    await callback.answer()
```

**Acceptance:**
- [ ] Handler parses vip_entry:stage_N callback pattern
- [ ] Validates subscription expiry before transition
- [ ] Validates stage progression (current + 1 = target)
- [ ] Calls VIPEntryService.advance_stage() for database update
- [ ] Changes UserRole to VIP on Stage 3 completion
- [ ] Logs role change with RoleChangeReason.VIP_ENTRY_COMPLETED
- [ ] Deletes previous stage message (cleanup)
- [ ] Calls callback.answer()

---

### T5: Modify /start Handler to Check VIP Entry Stage
**File:** `bot/handlers/user/start.py`

**Location:** In _activate_token_from_deeplink() function (line 177+)

**Current Code:**
```python
# Activar suscripciÃ³n VIP (sin commit en service)
subscriber = await container.subscription.activate_vip_subscription(
    user_id=user.user_id,
    token_id=token.id,
    duration_hours=plan.duration_days * 24
)

# Actualizar rol del usuario a VIP en BD
user.role = UserRole.VIP

# Commit Ãºnico de toda la transacciÃ³n
await session.commit()
await session.refresh(subscriber)

logger.info(
    f"âœ… Usuario {user.user_id} activado como VIP vÃ­a deep link | "
    f"Plan: {plan.name}"
)

# Generar link de invitaciÃ³n al canal VIP
vip_channel_id = await container.channel.get_vip_channel_id()
```

**New Code:**
```python
# Activar suscripciÃ³n VIP (inicia flujo ritualizado)
subscriber = await container.subscription.activate_vip_subscription(
    user_id=user.user_id,
    token_id=token.id,
    duration_hours=plan.duration_days * 24
)

# NO cambiar rol a VIP aÃºn (UserRole se cambia en Stage 3)
# user.role = UserRole.FREE  # Ya es FREE por defecto

# Commit de la transacciÃ³n
await session.commit()
await session.refresh(subscriber)

logger.info(
    f"âœ… Usuario {user.user_id} activÃ³ suscripciÃ³n VIP vÃ­a deep link | "
    f"Plan: {plan.name} | Stage: {subscriber.vip_entry_stage}"
)

# Iniciar flujo ritualizado (NO enviar enlace inmediato)
from bot.handlers.user.vip_entry import show_vip_entry_stage

await show_vip_entry_stage(
    message=message,
    container=container,
    stage=subscriber.vip_entry_stage
)
```

**Also Modify _send_welcome_message() (line 264+):**
```python
async def _send_welcome_message(
    message: Message,
    user,  # User model
    container: ServiceContainer,
    user_id: int
):
    """
    EnvÃ­a mensaje de bienvenida normal y muestra el menÃº correspondiente.

    Args:
        message: Mensaje original
        user: Usuario del sistema
        container: Service container
        user_id: ID del usuario
    """
    user_name = message.from_user.first_name or "Usuario"

    # Phase 13: Check if user has incomplete VIP entry flow
    subscriber = await container.subscription.get_vip_subscriber(user_id)

    if subscriber and subscriber.vip_entry_stage:
        # User has incomplete entry flow - resume from current stage
        from bot.handlers.user.vip_entry import show_vip_entry_stage

        logger.info(
            f"ðŸ”„ User {user_id} resuming VIP entry flow at stage "
            f"{subscriber.vip_entry_stage}"
        )

        await show_vip_entry_stage(
            message=message,
            container=container,
            stage=subscriber.vip_entry_stage
        )
        return

    # Original logic: Detect role and show menu
    role_service = container.role_detection
    detected_role = await role_service.get_user_role(user_id)
    is_vip = detected_role == UserRole.VIP

    # ... rest of existing logic ...
```

**Acceptance:**
- [ ] _activate_token_from_deeplink() does NOT set UserRole.VIP immediately
- [ ] _activate_token_from_deeplink() calls show_vip_entry_stage() with vip_entry_stage
- [ ] _send_welcome_message() checks vip_entry_stage before showing menu
- [ ] Incomplete entry flow resumes from current stage
- [ ] Logging includes stage information

---

### T6: Register VIP Entry Router in Main Dispatcher
**File:** `main.py` (or where routers are registered)

**Location:** After user_router registration

**Changes:**
```python
# Import VIP entry router
from bot.handlers.user.vip_entry import vip_entry_router

# Register router (after user_router)
dp.include_router(vip_entry_router)
```

**Acceptance:**
- [ ] vip_entry_router imported
- [ ] Router registered with dispatcher
- [ ] Callback handlers active for vip_entry:stage_* patterns

---

### T7: Modify VIP Menu Handler to Check Entry Stage
**File:** `bot/handlers/vip/menu.py`

**Location:** In show_vip_menu() function (at beginning, before VIP menu logic)

**Current Code:**
```python
async def show_vip_menu(message: Message, data: Dict[str, Any]):
    """
    Muestra el menÃº VIP usando UserMenuProvider para mensajes con voz de Lucien.

    Args:
        message: Mensaje de Telegram
        data: Data del handler (incluye container, session, etc.)
    """
    user = message.from_user
    container = data.get("container")

    # Get VIP subscription info
    vip_expires_at = None
    if container:
        try:
            subscriber = await container.subscription.get_vip_subscriber(user.id)
            if subscriber and subscriber.expiry_date:
                vip_expires_at = subscriber.expiry_date
        except Exception as e:
            logger.error(f"Error obteniendo info VIP para {user.id}: {e}")

    # ... rest of VIP menu logic
```

**New Code:**
```python
async def show_vip_menu(message: Message, data: Dict[str, Any]):
    """
    Muestra el menÃº VIP usando UserMenuProvider para mensajes con voz de Lucien.

    Phase 13: If user has incomplete VIP entry flow (vip_entry_stage is set),
    redirects to entry flow instead of showing VIP menu.

    Args:
        message: Mensaje de Telegram
        data: Data del handler (incluye container, session, etc.)
    """
    user = message.from_user
    container = data.get("container")

    # Phase 13: Check for incomplete VIP entry flow
    if container:
        try:
            subscriber = await container.subscription.get_vip_subscriber(user.id)

            if subscriber and subscriber.vip_entry_stage:
                # User has incomplete entry flow - redirect to entry flow
                from bot.handlers.user.vip_entry import show_vip_entry_stage

                logger.info(
                    f"ðŸ”„ User {user.id} VIP menu redirected to entry flow "
                    f"(stage={subscriber.vip_entry_stage})"
                )

                await show_vip_entry_stage(
                    message=message,
                    container=container,
                    stage=subscriber.vip_entry_stage
                )
                return
        except Exception as e:
            logger.warning(f"âš ï¸ Error checking VIP entry stage for {user.id}: {e}")

    # Get VIP subscription info (original logic)
    vip_expires_at = None
    if container:
        try:
            subscriber = await container.subscription.get_vip_subscriber(user.id)
            if subscriber and subscriber.expiry_date:
                vip_expires_at = subscriber.expiry_date
        except Exception as e:
            logger.error(f"Error obteniendo info VIP para {user.id}: {e}")

    # ... rest of VIP menu logic (unchanged)
```

**Acceptance:**
- [ ] VIP menu handler checks vip_entry_stage before showing menu
- [ ] If vip_entry_stage is set (1, 2, or 3), redirects to entry flow
- [ ] If vip_entry_stage is NULL, shows normal VIP menu
- [ ] Logging includes redirect reason and stage number
- [ ] Error handling for subscription check failures
- [ ] Uses show_vip_entry_stage() from vip_entry.py handler

---

## Verification

### Pre-Commit Verification:
1. **Import test:** `from bot.handlers.user.vip_entry import vip_entry_router` - no errors
2. **State existence:** `hasattr(VIPEntryStates, 'stage_1_confirmation')` - True
3. **Handler registration:** Router included in dispatcher
4. **Callback patterns:** vip_entry:stage_2, vip_entry:stage_3 defined

### Post-Commit Testing:
```python
# Test Stage 1 â†’ Stage 2 transition
# 1. Activate token (creates vip_entry_stage=1)
# 2. Call /start (should show Stage 1)
# 3. Click "Continuar" (should advance to Stage 2)
# 4. Verify vip_entry_stage=2 in database

# Test Stage 2 â†’ Stage 3 transition
# 1. From Stage 2, click "Estoy listo"
# 2. Verify UserRole changed to VIP
# 3. Verify invite link generated
# 4. Verify Stage 3 message shown with link

# Test expiry blocking
# 1. Set VIPSubscriber.expiry_date to past
# 2. Try to advance stage
# 3. Should see Lucien's expiry message
# 4. Should NOT advance stage

# Test resumption
# 1. Set vip_entry_stage=2, abandon flow
# 2. Call /start (should resume at Stage 2)
# 3. Should see Stage 2 message (not Stage 1)
```

---

## Integration Notes

**Breaking Changes:**
- UserRole no longer changes to VIP immediately after token activation
- Existing VIP subscribers (vip_entry_stage=NULL) skip flow automatically

**Backward Compatibility:**
- Existing active subscribers have vip_entry_stage=NULL (Plan 01 migration)
- They continue to work normally (no flow restart)

**Role Detection:**
- RoleDetectionService detects VIPSubscriber + vip_entry_stage
- During stages 1-2: UserRole is FREE (but has VIPSubscriber record)
- After Stage 3: UserRole is VIP (normal behavior)

**Background Task Integration:**
- expire_vip_subscribers() checks vip_entry_stage
- If stage < 3 and expired: User removed from flow (can't continue)

---

## Output

After completion, create `.planning/phases/13-vip-ritualized-entry/13-03-SUMMARY.md` with:
- VIPEntryStates FSM group structure
- Handler flow and callback patterns
- /start modifications for entry flow routing
- Expiry validation logic
- Resumption behavior

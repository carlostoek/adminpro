---
phase: 13-vip-ritualized-entry
plan: 04
type: execute
wave: 2
depends_on: [01]
files_modified:
  - bot/services/vip_entry.py (NEW FILE)
  - bot/services/container.py (add vip_entry property)
  - bot/background/tasks.py (integrate entry cancellation)
autonomous: true
estimated_minutes: 12

must_haves:
  truths:
    - "VIPEntryService class exists with 6 core methods"
    - "get_current_stage() returns vip_entry_stage from VIPSubscriber"
    - "advance_stage() updates vip_entry_stage and returns success status"
    - "generate_entry_token() creates unique 64-character token"
    - "create_24h_invite_link() generates ChatInviteLink with 24h expiry"
    - "cancel_entry_on_expiry() sets vip_entry_stage=NULL and removes user"
    - "ServiceContainer has vip_entry property with lazy loading"
    - "Background task integrates entry cancellation on subscription expiry"
  artifacts:
    - path: "bot/services/vip_entry.py"
      provides: "VIPEntryService with stage validation and link generation"
      min_lines: 200
    - path: "bot/services/container.py"
      provides: "ServiceContainer.vip_entry property (lazy loading)"
      min_lines: 10
    - path: "bot/background/tasks.py"
      provides: "Entry flow cancellation in expire_vip_subscribers()"
      min_lines: 20
  key_links:
    - from: "bot/services/vip_entry.py"
      to: "bot/handlers/user/vip_entry.py (Plan 03)"
      via: "Stage validation and advancement methods"
      pattern: "advance_stage|get_current_stage"
    - from: "bot/services/vip_entry.py"
      to: "bot/services/subscription.py"
      via: "create_invite_link() for 24h link generation"
      pattern: "create_invite_link"
    - from: "bot/background/tasks.py"
      to: "bot/services/vip_entry.py"
      via: "cancel_entry_on_expiry() for cleanup"
      pattern: "cancel_entry_on_expiry"
---

# Plan 04: VIP Entry Service with Link Generation

## Objective

Create VIPEntryService with stage validation, 24-hour invite link generation, and expiry cancellation logic for the ritualized VIP entry flow.

**Purpose:**
Encapsulate all business logic for VIP entry ritual progression, separating service logic from handler concerns and enabling clean integration with background tasks.

**Output:**
- VIPEntryService class with 6 core methods
- ServiceContainer integration with lazy loading
- Background task integration for expiry cancellation
- Stage progression validation and database updates

---

## Context

### Service Pattern (from existing services)

**SubscriptionService Example (bot/services/subscription.py):**
```python
class SubscriptionService:
    def __init__(self, session: AsyncSession, bot: Bot):
        self.session = session
        self.bot = bot

    async def create_invite_link(
        self,
        channel_id: str,
        user_id: int,
        expire_hours: int = 5
    ) -> ChatInviteLink:
        """Genera enlace de invitaciÃ³n de un solo uso."""
        # ... implementation ...
```

**Key Patterns:**
- Async methods with type hints
- Session injected via __init__
- No session.commit() in service (handlers commit)
- Return tuples for success/failure indication

### VIP Entry Business Logic

**Stage Progression:**
```
Stage 1 (vip_entry_stage=1):
  - User clicks "Continuar"
  - Validate: subscription not expired, stage == 1
  - Action: Set vip_entry_stage = 2
  - Return: success=True

Stage 2 (vip_entry_stage=2):
  - User clicks "Estoy listo"
  - Validate: subscription not expired, stage == 2
  - Action: Generate vip_entry_token, set vip_entry_stage = 3
  - Return: success=True, token generated

Stage 3 (vip_entry_stage=3):
  - User clicks "Cruzar el umbral" (URL button)
  - Action: Set vip_entry_stage = NULL (complete)
  - Return: N/A (link is URL button, not callback)
```

**Token Generation:**
- Unique 64-character string (secrets.token_urlsafe(48))
- Stored in vip_entry_token field (unique constraint)
- Used for one-time invite link creation
- Becomes invalid after use (vip_entry_stage=NULL)

**Invite Link Creation:**
- Reuses existing SubscriptionService.create_invite_link()
- 24-hour expiry (expire_hours=24)
- member_limit=1 (one-time use)
- Stored timestamp in invite_link_sent_at field

**Expiry Cancellation:**
- Triggered by background task when VIPSubscriber expires
- If vip_entry_stage in (1, 2) (not complete):
  - Set vip_entry_stage = NULL (cancel flow)
  - Remove user from VIP channel if already joined
  - Log cancellation event

---

## Tasks

### T1: Create VIPEntryService Skeleton
**File:** `bot/services/vip_entry.py` (NEW FILE)

**Structure:**
```python
"""
VIP Entry Service - GestiÃ³n de flujo ritualizado de entrada VIP.

Responsabilidades:
- ValidaciÃ³n de etapa actual del usuario
- Avance de etapas (1 â†’ 2 â†’ 3 â†’ NULL)
- GeneraciÃ³n de token Ãºnico para enlace de etapa 3
- CreaciÃ³n de enlace de invitaciÃ³n con validez de 24 horas
- CancelaciÃ³n de flujo cuando suscripciÃ³n expira

Phase 13: Ritualized VIP entry flow replacing immediate link delivery.
"""
import logging
import secrets
from datetime import datetime, timedelta
from typing import Optional, Tuple

from aiogram import Bot
from aiogram.types import ChatInviteLink
from sqlalchemy import select, update
from sqlalchemy.ext.asyncio import AsyncSession

from bot.database.models import VIPSubscriber, User
from bot.services.subscription import SubscriptionService

logger = logging.getLogger(__name__)


class VIPEntryService:
    """
    Service para gestionar flujo ritualizado de entrada VIP.

    Flujo:
    1. Usuario activa token â†’ vip_entry_stage=1
    2. Usuario pulsa "Continuar" â†’ vip_entry_stage=2
    3. Usuario pulsa "Estoy listo" â†’ vip_entry_stage=3 + token generado
    4. Usuario accede al canal â†’ vip_entry_stage=NULL (completo)

    ExpiraciÃ³n:
    - Si suscripciÃ³n expira durante etapas 1-2:
      - Cancelar flujo (vip_entry_stage=NULL)
      - Remover usuario del canal (si ya se uniÃ³)
      - Bloquear continuaciÃ³n

    MÃ©todos:
    - get_current_stage(): Obtiene etapa actual del usuario
    - advance_stage(): Avanza a siguiente etapa (validaciones)
    - generate_entry_token(): Genera token Ãºnico para etapa 3
    - create_24h_invite_link(): Crea enlace de 24 horas
    - cancel_entry_on_expiry(): Cancela flujo por expiraciÃ³n
    """

    def __init__(self, session: AsyncSession, bot: Bot):
        """
        Inicializa el service.

        Args:
            session: SesiÃ³n de base de datos
            bot: Instancia del bot de Telegram
        """
        self.session = session
        self.bot = bot
        self.subscription = SubscriptionService(session, bot)
        logger.debug("âœ… VIPEntryService inicializado")

    # ===== STAGE VALIDATION =====

    async def get_current_stage(self, user_id: int) -> Optional[int]:
        """
        Obtiene la etapa actual del flujo VIP de entrada.

        Args:
            user_id: ID del usuario

        Returns:
            Etapa actual (1, 2, 3) o NULL si flujo completado/no iniciado
        """
        pass  # Implement in T2

    async def advance_stage(self, user_id: int, from_stage: int) -> bool:
        """
        Avanza a la siguiente etapa del flujo VIP.

        Valida:
        - SuscripciÃ³n no expirada
        - from_stage coincide con etapa actual en BD
        - ProgresiÃ³n secuencial (no saltos)

        Args:
            user_id: ID del usuario
            from_stage: Etapa actual (para validaciÃ³n)

        Returns:
            True si etapa avanzÃ³ correctamente, False si error
        """
        pass  # Implement in T2

    # ===== TOKEN GENERATION =====

    async def generate_entry_token(self, user_id: int) -> str:
        """
        Genera token Ãºnico para enlace de invitaciÃ³n de etapa 3.

        El token:
        - Tiene 64 caracteres (token_urlsafe)
        - Es Ãºnico (verifica duplicados)
        - Se almacena en vip_entry_token field
        - Se usa para validar enlace de un solo uso

        Args:
            user_id: ID del usuario

        Returns:
            Token generado (64 caracteres)

        Raises:
            RuntimeError: Si no se puede generar token Ãºnico despuÃ©s de 10 intentos
        """
        pass  # Implement in T3

    async def is_entry_token_valid(self, token: str) -> bool:
        """
        Verifica si un token de entrada es vÃ¡lido.

        Args:
            token: Token a verificar

        Returns:
            True si token existe y corresponde a usuario en etapa 3
        """
        pass  # Implement in T3

    # ===== INVITE LINK CREATION =====

    async def create_24h_invite_link(self, user_id: int) -> Optional[ChatInviteLink]:
        """
        Crea enlace de invitaciÃ³n al canal VIP con validez de 24 horas.

        CaracterÃ­sticas:
        - Validez: 24 horas desde generaciÃ³n
        - Uso: member_limit=1 (un solo uso)
        - Timestamp: invite_link_sent_at actualizado

        Args:
            user_id: ID del usuario

        Returns:
            ChatInviteLink si se creÃ³ correctamente, None si error
        """
        pass  # Implement in T4

    # ===== EXPIRY CANCELLATION =====

    async def cancel_entry_on_expiry(self, user_id: int) -> None:
        """
        Cancela flujo de entrada VIP por expiraciÃ³n de suscripciÃ³n.

        Acciones:
        - Set vip_entry_stage = NULL (cancelar flujo)
        - Remover usuario del canal VIP (si ya se uniÃ³)
        - Log evento de cancelaciÃ³n

        Llamado por: Background task expire_vip_subscribers()

        Args:
            user_id: ID del usuario
        """
        pass  # Implement in T5
```

**Acceptance:**
- [ ] File created with VIPEntryService class
- [ ] All 6 method signatures defined with docstrings
- [ ] __init__ injects session and bot
- [ ] Subservice created (SubscriptionService)
- [ ] Docstrings explain flow and validation logic

---

### T2: Implement Stage Validation Methods
**File:** `bot/services/vip_entry.py`

**Implementation:**
```python
async def get_current_stage(self, user_id: int) -> Optional[int]:
    """
    Obtiene la etapa actual del flujo VIP de entrada.

    Args:
        user_id: ID del usuario

    Returns:
        Etapa actual (1, 2, 3) o NULL si flujo completado/no iniciado
    """
    result = await self.session.execute(
        select(VIPSubscriber.vip_entry_stage).where(
            VIPSubscriber.user_id == user_id
        )
    )
    stage = result.scalar_one_or_none()
    return stage


async def advance_stage(self, user_id: int, from_stage: int) -> bool:
    """
    Avanza a la siguiente etapa del flujo VIP.

    Valida:
    - SuscripciÃ³n no expirada
    - from_stage coincide con etapa actual en BD
    - ProgresiÃ³n secuencial (no saltos)

    Args:
        user_id: ID del usuario
        from_stage: Etapa actual (para validaciÃ³n)

    Returns:
        True si etapa avanzÃ³ correctamente, False si error
    """
    # Get subscriber
    result = await self.session.execute(
        select(VIPSubscriber).where(VIPSubscriber.user_id == user_id)
    )
    subscriber = result.scalar_one_or_none()

    if not subscriber:
        logger.error(f"âŒ VIPSubscriber not found for user {user_id}")
        return False

    # Validate subscription not expired
    if subscriber.is_expired():
        logger.warning(
            f"âš ï¸ Cannot advance stage: User {user_id} subscription expired"
        )
        return False

    # Validate from_stage matches current stage
    current_stage = subscriber.vip_entry_stage if subscriber.vip_entry_stage else 0

    if from_stage != current_stage:
        logger.warning(
            f"âš ï¸ Stage mismatch: expected {current_stage}, got {from_stage} "
            f"for user {user_id}"
        )
        return False

    # Validate sequential progression (no skips)
    if from_stage not in (1, 2):  # Only advance from stage 1 or 2
        logger.warning(f"âš ï¸ Cannot advance from stage {from_stage}")
        return False

    # Advance to next stage
    next_stage = from_stage + 1
    subscriber.vip_entry_stage = next_stage

    logger.info(
        f"âœ… User {user_id} VIP entry advanced: stage {from_stage} â†’ {next_stage}"
    )

    return True
```

**Acceptance:**
- [ ] get_current_stage() returns vip_entry_stage from database
- [ ] advance_stage() validates subscription expiry before progression
- [ ] advance_stage() validates from_stage matches current stage
- [ ] advance_stage() prevents sequential skips (only 1â†’2, 2â†’3)
- [ ] Database updated with next_stage value
- [ ] Proper error logging for validation failures

---

### T3: Implement Token Generation Methods
**File:** `bot/services/vip_entry.py`

**Implementation:**
```python
async def generate_entry_token(self, user_id: int) -> str:
    """
    Genera token Ãºnico para enlace de invitaciÃ³n de etapa 3.

    El token:
    - Tiene 64 caracteres (token_urlsafe)
    - Es Ãºnico (verifica duplicados)
    - Se almacena en vip_entry_token field
    - Se usa para validar enlace de un solo uso

    Args:
        user_id: ID del usuario

    Returns:
        Token generado (64 caracteres)

    Raises:
        RuntimeError: Si no se puede generar token Ãºnico despuÃ©s de 10 intentos
    """
    max_attempts = 10

    for attempt in range(max_attempts):
        # Generate random token (64 characters from token_urlsafe(48))
        token = secrets.token_urlsafe(48)

        # Check uniqueness
        result = await self.session.execute(
            select(VIPSubscriber).where(VIPSubscriber.vip_entry_token == token)
        )
        existing = result.scalar_one_or_none()

        if not existing:
            # Token is unique - store it
            subscriber_result = await self.session.execute(
                select(VIPSubscriber).where(VIPSubscriber.user_id == user_id)
            )
            subscriber = subscriber_result.scalar_one_or_none()

            if subscriber:
                subscriber.vip_entry_token = token
                logger.info(f"âœ… Entry token generated for user {user_id}")
                return token
            else:
                logger.error(f"âŒ VIPSubscriber not found for user {user_id}")
                raise RuntimeError("Subscriber not found")

    # Could not generate unique token
    logger.error(f"âŒ Failed to generate unique token after {max_attempts} attempts")
    raise RuntimeError("Could not generate unique entry token")


async def is_entry_token_valid(self, token: str) -> bool:
    """
    Verifica si un token de entrada es vÃ¡lido.

    Args:
        token: Token a verificar

    Returns:
        True si token existe y corresponde a usuario en etapa 3
    """
    result = await self.session.execute(
        select(VIPSubscriber).where(
            VIPSubscriber.vip_entry_token == token,
            VIPSubscriber.vip_entry_stage == 3
        )
    )
    subscriber = result.scalar_one_or_none()

    if subscriber and not subscriber.is_expired():
        return True

    return False
```

**Acceptance:**
- [ ] generate_entry_token() uses secrets.token_urlsafe(48) for 64-char tokens
- [ ] Token uniqueness verified against existing tokens
- [ ] Token stored in vip_entry_token field
- [ ] RuntimeError raised after 10 failed attempts
- [ ] is_entry_token_valid() checks token exists AND stage == 3
- [ ] is_entry_token_valid() checks subscription not expired

---

### T4: Implement Invite Link Creation
**File:** `bot/services/vip_entry.py`

**Implementation:**
```python
async def create_24h_invite_link(self, user_id: int) -> Optional[ChatInviteLink]:
    """
    Crea enlace de invitaciÃ³n al canal VIP con validez de 24 horas.

    CaracterÃ­sticas:
    - Validez: 24 horas desde generaciÃ³n
    - Uso: member_limit=1 (un solo uso)
    - Timestamp: invite_link_sent_at actualizado

    Args:
        user_id: ID del usuario

    Returns:
        ChatInviteLink si se creÃ³ correctamente, None si error
    """
    # Get subscriber
    result = await self.session.execute(
        select(VIPSubscriber).where(VIPSubscriber.user_id == user_id)
    )
    subscriber = result.scalar_one_or_none()

    if not subscriber:
        logger.error(f"âŒ VIPSubscriber not found for user {user_id}")
        return None

    # Get VIP channel ID
    channel_id_result = await self.session.execute(
        select(VIPSubscriber.__table__.c.vip_channel_id).limit(1)
        # Note: This is pseudo-code - use BotConfig in real implementation
    )

    # Better: Get from BotConfig via ConfigService
    from bot.services.config import ConfigService
    config_service = ConfigService(self.session)
    vip_channel_id = await config_service.get_vip_channel_id()

    if not vip_channel_id:
        logger.error("âŒ VIP channel not configured")
        return None

    # Create invite link via SubscriptionService
    try:
        invite_link = await self.subscription.create_invite_link(
            channel_id=vip_channel_id,
            user_id=user_id,
            expire_hours=24  # 24-hour validity
        )

        # Update invite_link_sent_at timestamp
        subscriber.invite_link_sent_at = datetime.utcnow()

        logger.info(f"âœ… 24h invite link created for user {user_id}")
        return invite_link

    except Exception as e:
        logger.error(f"âŒ Error creating invite link for user {user_id}: {e}")
        return None
```

**Acceptance:**
- [ ] Gets VIP channel ID from ConfigService
- [ ] Calls SubscriptionService.create_invite_link() with expire_hours=24
- [ ] Updates invite_link_sent_at timestamp
- [ ] Returns ChatInviteLink object
- [ ] Returns None on error with proper logging

---

### T5: Implement Expiry Cancellation
**File:** `bot/services/vip_entry.py`

**Implementation:**
```python
async def cancel_entry_on_expiry(self, user_id: int) -> None:
    """
    Cancela flujo de entrada VIP por expiraciÃ³n de suscripciÃ³n.

    Acciones:
    - Set vip_entry_stage = NULL (cancelar flujo)
    - Remover usuario del canal VIP (si ya se uniÃ³)
    - Log evento de cancelaciÃ³n

    Llamado por: Background task expire_vip_subscribers()

    Args:
        user_id: ID del usuario
    """
    # Get subscriber
    result = await self.session.execute(
        select(VIPSubscriber).where(VIPSubscriber.user_id == user_id)
    )
    subscriber = result.scalar_one_or_none()

    if not subscriber:
        logger.warning(f"âš ï¸ VIPSubscriber not found for user {user_id}")
        return

    # Only cancel if flow is incomplete (stage 1 or 2)
    if subscriber.vip_entry_stage not in (1, 2):
        return

    # Cancel flow
    old_stage = subscriber.vip_entry_stage
    subscriber.vip_entry_stage = None  # NULL = cancelled

    logger.info(
        f"ðŸš« VIP entry flow cancelled for user {user_id} "
        f"(was at stage {old_stage}, subscription expired)"
    )

    # Kick from VIP channel if already joined
    try:
        vip_channel_id = await self._get_vip_channel_id()

        if vip_channel_id:
            removed = await self.subscription.kick_expired_vip_from_channel(
                channel_id=vip_channel_id
            )
            logger.info(f"ðŸ‘ž User {user_id} removed from VIP channel (entry cancelled)")
    except Exception as e:
        logger.warning(f"âš ï¸ Could not remove user {user_id} from VIP channel: {e}")


async def _get_vip_channel_id(self) -> Optional[str]:
    """Helper: Get VIP channel ID from ConfigService."""
    from bot.services.config import ConfigService
    config_service = ConfigService(self.session)
    return await config_service.get_vip_channel_id()
```

**Acceptance:**
- [ ] Cancels flow only if vip_entry_stage in (1, 2) (incomplete)
- [ ] Sets vip_entry_stage = NULL
- [ ] Removes user from VIP channel (via kick_expired_vip_from_channel)
- [ ] Logs cancellation event with old stage
- [ ] Graceful handling if channel removal fails

---

### T6: Add VIP Entry Service to ServiceContainer
**File:** `bot/services/container.py`

**Location:** After other service properties (around line 100+)

**Changes:**
```python
class ServiceContainer:
    """Dependency injection container for bot services."""

    def __init__(self, session: AsyncSession, bot: Bot):
        self._session = session
        self._bot = bot
        self._vip_entry = None  # Lazy loading
        # ... existing ...

    # ... existing properties ...

    @property
    def vip_entry(self) -> "VIPEntryService":
        """
        VIP entry service (lazy loading).

        Provides:
        - Stage validation and progression
        - Entry token generation
        - 24h invite link creation
        - Expiry cancellation

        Returns:
            VIPEntryService instance
        """
        if self._vip_entry is None:
            from bot.services.vip_entry import VIPEntryService
            self._vip_entry = VIPEntryService(self._session, self._bot)
            logger.debug("ðŸ“¦ VIPEntryService loaded (lazy)")
        return self._vip_entry

    def get_loaded_services(self) -> List[str]:
        """Return list of loaded service names."""
        services = []
        # ... existing checks ...
        if self._vip_entry:
            services.append("vip_entry")
        return services
```

**Acceptance:**
- [ ] vip_entry property added with lazy loading
- [ ] Property imports VIPEntryService lazily (inside property)
- [ ] get_loaded_services() includes "vip_entry" check
- [ ] Follows existing service property pattern

---

### T7: Integrate Entry Cancellation in Background Task
**File:** `bot/background/tasks.py`

**Location:** In expire_vip_subscribers() function

**Current Code (pseudo-code):**
```python
async def expire_vip_subscribers():
    """Background task to expire VIP subscribers."""
    # ... existing logic ...
    # Kick expired users from channel
    await kick_expired_vip_from_channel(channel_id)
```

**New Code:**
```python
async def expire_vip_subscribers():
    """
    Background task to expire VIP subscribers.

    Actions:
    - Find expired subscribers
    - Update status to 'expired'
    - Cancel incomplete VIP entry flows (Phase 13)
    - Kick expired users from VIP channel
    """
    # ... existing logic to find expired subscribers ...

    for subscriber in expired_subscribers:
        # Phase 13: Cancel entry flow if incomplete
        if subscriber.vip_entry_stage in (1, 2):
            await container.vip_entry.cancel_entry_on_expiry(
                user_id=subscriber.user_id
            )
            logger.info(
                f"ðŸš« Cancelled VIP entry flow for user {subscriber.user_id} "
                f"(subscription expired at stage {subscriber.vip_entry_stage})"
            )

        # ... existing status update logic ...

    # ... existing kick logic ...
```

**Acceptance:**
- [ ] Background task checks vip_entry_stage for expired subscribers
- [ ] Calls cancel_entry_on_expiry() if stage in (1, 2)
- [ ] Logs cancellation with stage information
- [ ] Does NOT affect subscribers with vip_entry_stage=NULL (completed)

---

## Verification

### Pre-Commit Verification:
1. **Import test:** `from bot.services.vip_entry import VIPEntryService` - no errors
2. **Method existence:** All 6 methods exist and are callable
3. **Service integration:** `ServiceContainer().vip_entry` returns VIPEntryService
4. **Background task:** expire_vip_subscribers() calls cancel_entry_on_expiry()

### Post-Commit Testing:
```python
# Test stage progression
service = VIPEntryService(session, bot)

# Get current stage
stage = await service.get_current_stage(user_id)
assert stage in (1, 2, 3, None)

# Advance stage 1 â†’ 2
success = await service.advance_stage(user_id, from_stage=1)
assert success is True
assert await service.get_current_stage(user_id) == 2

# Generate token
token = await service.generate_entry_token(user_id)
assert len(token) == 64
assert token.isalnum() or token.count('_') > 0 or token.count('-') > 0

# Create invite link
link = await service.create_24h_invite_link(user_id)
assert link is not None
assert link.invite_link.startswith("https://t.me/+")

# Cancel on expiry
await service.cancel_entry_on_expiry(user_id)
assert await service.get_current_stage(user_id) is None  # NULL
```

---

## Integration Notes

**Service Dependencies:**
- SubscriptionService: create_invite_link(), kick_expired_vip_from_channel()
- ConfigService: get_vip_channel_id()
- No direct database commits (handlers commit)

**Handler Integration (Plan 03):**
```python
# In vip_entry.py handlers
service = container.vip_entry

# Validate stage
current = await service.get_current_stage(user_id)

# Advance stage
success = await service.advance_stage(user_id, from_stage=1)

# Generate link (Stage 3)
invite_link = await service.create_24h_invite_link(user_id)
```

**Background Task Integration:**
- expire_vip_subscribers() runs every hour (existing schedule)
- Checks vip_entry_stage for expired subscribers
- Cancels incomplete flows (stage 1 or 2)

---

## Output

After completion, create `.planning/phases/13-vip-ritualized-entry/13-04-SUMMARY.md` with:
- VIPEntryService method documentation
- Stage progression logic
- Token generation algorithm
- Invite link creation flow
- Expiry cancellation behavior
- ServiceContainer integration

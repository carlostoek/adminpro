---
phase: 06-vip-free-user-menus
plan: 03
type: execute
wave: 2
depends_on: ["06-01"]
files_modified:
  - /data/data/com.termux/files/home/repos/c1/bot/handlers/free/menu.py
  - /data/data/com.termux/files/home/repos/c1/bot/handlers/free/__init__.py
  - /data/data/com.termux/files/home/repos/c1/bot/handlers/free/callbacks.py
autonomous: true

must_haves:
  truths:
    - "Free menu handler uses UserMenuProvider for Lucien-voiced messages"
    - "Free menu has 'Mi Contenido' option showing FREE_CONTENT packages"
    - "Each free package has 'Me interesa' button that creates/updates UserInterest record"
    - "Free menu has 'Canal VIP' option with subscription information"
    - "Free menu has social media/free content option (FREEMENU-05)"
  artifacts:
    - path: "/data/data/com.termux/files/home/repos/c1/bot/handlers/free/menu.py"
      provides: "Enhanced Free menu handler with UserMenuProvider integration"
      min_lines: 100
      contains: "container.message.user.menu.free_menu_greeting"
    - path: "/data/data/com.termux/files/home/repos/c1/bot/handlers/free/callbacks.py"
      provides: "Callback handlers for Free menu interactions"
      min_lines: 100
      contains: "async def handle_free_content"
  key_links:
    - from: "/data/data/com.termux/files/home/repos/c1/bot/handlers/free/menu.py"
      to: "/data/data/com.termux/files/home/repos/c1/bot/services/message/user_menu.py"
      via: "UserMenuProvider method calls"
      pattern: "container\\.message\\.user\\.menu\\.free_menu_greeting"
    - from: "/data/data/com.termux/files/home/repos/c1/bot/handlers/free/callbacks.py"
      to: "/data/data/com.termux/files/home/repos/c1/bot/services/content.py"
      via: "ContentService calls to get FREE_CONTENT packages"
      pattern: "container\\.content\\.get_active_packages"
---

<objective>
Enhance Free menu handler to use UserMenuProvider for Lucien-voiced messages, implement content browsing for FREE_CONTENT packages, and add VIP upgrade information section.

Purpose: Enable FREEMENU-01 ("Mi Contenido" option), FREEMENU-02 (content listing), FREEMENU-03 ("Me interesa" buttons), FREEMENU-04 (VIP channel info), and FREEMENU-05 (social media/free content) requirements. Replace hardcoded handler text with voice-compliant messages.

Output: Enhanced Free menu handler with content browsing, VIP upgrade information, and social media options using UserMenuProvider.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/REQUIREMENTS.md

# Reference existing Free menu handler and callback patterns
@/data/data/com.termux/files/home/repos/c1/bot/handlers/free/menu.py
@/data/data/com.termux/files/home/repos/c1/bot/handlers/vip/callbacks.py
@/data/data/com.termux/files/home/repos/c1/bot/services/content.py
@/data/data/com.termux/files/home/repos/c1/bot/database/enums.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Enhance Free menu handler with UserMenuProvider</name>
  <files>/data/data/com.termux/files/home/repos/c1/bot/handlers/free/menu.py</files>
  <action>
Update the existing `show_free_menu` function in `/data/data/com.termux/files/home/repos/c1/bot/handlers/free/menu.py` to use UserMenuProvider:

1. Replace hardcoded message generation with UserMenuProvider calls:
   - Get Free queue info from `container.subscription.get_free_request()`
   - Extract queue creation date if available
   - Call `container.message.user.menu.free_menu_greeting()` with user info
   - Pass session history for context-aware variations

2. Update imports:
   - Add `from bot.database.enums import ContentCategory`
   - Remove hardcoded keyboard creation imports if no longer needed

3. Enhanced implementation:
   ```python
   async def show_free_menu(message: Message, data: Dict[str, Any]):
       user = message.from_user
       container = data.get("container")

       # Get Free queue info
       free_queue_info = None
       if container:
           try:
               free_request = await container.subscription.get_free_request(user.id)
               if free_request:
                   free_queue_info = free_request.created_at
           except Exception as e:
               logger.error(f"Error obteniendo info Free para {user.id}: {e}")

       # Get session context for message variations
       session_ctx = None
       if container:
           session_ctx = container.message.get_session_context(container)

       # Generate Lucien-voiced menu message
       text, keyboard = container.message.user.menu.free_menu_greeting(
           user_name=user.first_name,
           free_queue_position=None,  # Placeholder for future queue position feature
           user_id=user.id,
           session_history=session_ctx
       )

       await message.answer(text, parse_mode="HTML", reply_markup=keyboard)
       logger.info(f"üÜì Men√∫ Free mostrado a {user.id} (voz de Lucien)")
   ```

4. Remove old hardcoded message and keyboard creation code
5. Keep error handling for missing container
6. Update docstring to reflect UserMenuProvider usage
  </action>
  <verify>
1. `show_free_menu` function uses `container.message.user.menu.free_menu_greeting()`
2. Free queue info extracted and available for future use
3. Session context passed for variation tracking
4. Hardcoded message generation removed
5. Function still handles missing container gracefully
6. Parse mode changed to "HTML" (UserMenuProvider uses HTML formatting)
  </verify>
  <done>Free menu handler enhanced to use UserMenuProvider with queue info display.</done>
</task>

<task type="auto">
  <name>Task 2: Create Free callback handlers for content browsing</name>
  <files>/data/data/com.termux/files/home/repos/c1/bot/handlers/free/callbacks.py</files>
  <action>
Create a new file `/data/data/com.termux/files/home/repos/c1/bot/handlers/free/callbacks.py` with callback handlers for Free menu interactions:

1. Create the file with imports and router setup:
   ```python
   """
   Free Callback Handlers - Gesti√≥n de interacciones del men√∫ Free.

   Responsabilidades:
   - Manejar callback "free:content" - mostrar secci√≥n "Mi Contenido"
   - Manejar callback "free:vip_info" - mostrar informaci√≥n del canal VIP
   - Manejar callback "free:social" - mostrar redes sociales/contenido gratuito
   - Manejar inter√©s en paquetes FREE_CONTENT
   - Navegaci√≥n (volver, salir)

   Pattern: Sigue estructura de VIP callbacks.
   """
   import logging
   from datetime import datetime
   from typing import Dict, Any

   from aiogram import Router
   from aiogram.types import CallbackQuery

   from bot.database.enums import ContentCategory

   logger = logging.getLogger(__name__)

   # Create router
   free_callbacks_router = Router()
   ```

2. Add callback handler for Free content section ("Mi Contenido"):
   ```python
   @free_callbacks_router.callback_query(lambda c: c.data == "free:content")
   async def handle_free_content(callback: CallbackQuery, **kwargs):
       """
       Muestra secci√≥n "Mi Contenido" con paquetes FREE_CONTENT.

       Args:
           callback: CallbackQuery de Telegram
           **kwargs: Data del handler (container, session, etc.)
       """
       data = kwargs.get("data", {})
       container = data.get("container")
       user = callback.from_user

       if not container:
           await callback.answer("‚ö†Ô∏è Error: servicio no disponible", show_alert=True)
           return

       try:
           # Get active FREE_CONTENT packages
           packages = await container.content.get_active_packages(
               category=ContentCategory.FREE_CONTENT,
               limit=20
           )

           # Get session context for message variations
           session_ctx = container.message.get_session_context(container)

           # Generate content section message with dynamic package buttons
           text, keyboard = container.message.user.menu.free_content_section(
               user_name=user.first_name,
               packages=packages,
               user_id=user.id,
               session_history=session_ctx
           )

           # Update message with content section
           await callback.message.edit_text(text, parse_mode="HTML", reply_markup=keyboard)
           await callback.answer()

           logger.info(f"üÜì Secci√≥n 'Mi Contenido' mostrada a {user.id} ({len(packages)} paquetes)")

       except Exception as e:
           logger.error(f"Error mostrando contenido Free a {user.id}: {e}")
           await callback.answer("‚ö†Ô∏è Error cargando contenido gratuito", show_alert=True)
   ```

3. Add callback handler for VIP channel info:
   ```python
   @free_callbacks_router.callback_query(lambda c: c.data == "free:vip_info")
   async def handle_vip_info(callback: CallbackQuery, **kwargs):
       """
       Muestra informaci√≥n sobre el canal VIP y suscripci√≥n.

       Args:
           callback: CallbackQuery de Telegram
           **kwargs: Data del handler (container, session, etc.)
       """
       data = kwargs.get("data", {})
       container = data.get("container")
       user = callback.from_user

       if not container:
           await callback.answer("‚ö†Ô∏è Error: servicio no disponible", show_alert=True)
           return

       try:
           # Get VIP channel info if configured
           vip_channel_id = None
           if container:
               vip_channel_id = await container.config.get_vip_channel_id()

           # Create informative message about VIP benefits
           message_text = (
               f"üé© <b>Lucien:</b>\n\n"
               f"<i>El c√≠rculo exclusivo de Diana aguarda...</i>\n\n"
               f"<b>‚≠ê Canal VIP</b>\n\n"
           )

           if vip_channel_id:
               message_text += (
                   f"El sanctum est√° disponible para aquellos que posean "
                   f"el token de acceso.\n\n"
                   f"<b>Beneficios:</b>\n"
                   f"‚Ä¢ Contenido exclusivo y anticipado\n"
                   f"‚Ä¢ Comunidad privada de miembros\n"
                   f"‚Ä¢ Acceso a Diana para consultas directas\n"
                   f"‚Ä¢ Contenido premium adicional\n\n"
                   f"<i>Para unirse, necesitar√° un token de invitaci√≥n.</i>"
               )
           else:
               message_text += (
                   f"El sanctum a√∫n no ha sido configurado por los custodios.\n\n"
                   f"<i>Los beneficios del c√≠rculo exclusivo estar√°n disponibles "
                   f"una vez que Diana active el canal.</i>"
               )

           # Create back button
           from aiogram.utils.keyboard import InlineKeyboardBuilder
           keyboard = InlineKeyboardBuilder()
           keyboard.button(text="‚¨ÖÔ∏è Volver", callback_data="menu:back")

           await callback.message.edit_text(
               message_text,
               parse_mode="HTML",
               reply_markup=keyboard.as_markup()
           )
           await callback.answer()

           logger.info(f"üÜì Info VIP mostrada a {user.id}")

       except Exception as e:
           logger.error(f"Error mostrando info VIP a {user.id}: {e}")
           await callback.answer("‚ö†Ô∏è Error cargando informaci√≥n VIP", show_alert=True)
   ```

4. Add callback handler for social media/free content:
   ```python
   @free_callbacks_router.callback_query(lambda c: c.data == "free:social")
   async def handle_social_media(callback: CallbackQuery):
       """
       Muestra redes sociales y contenido gratuito adicional.

       Args:
           callback: CallbackQuery de Telegram
       """
       try:
           # Create social media message
           message_text = (
               f"üé© <b>Lucien:</b>\n\n"
               f"<i>Diana comparte fragmentos de su arte en estos jardines p√∫blicos...</i>\n\n"
               f"<b>üå∏ Redes Sociales de Diana</b>\n\n"
               f"‚Ä¢ <b>Instagram:</b> @diana_artista (muestras diarias)\n"
               f"‚Ä¢ <b>TikTok:</b> @diana.creaciones (tutoriales r√°pidos)\n"
               f"‚Ä¢ <b>YouTube:</b> Diana Creaciones (procesos completos)\n\n"
               f"<b>üéÅ Contenido Gratuito Adicional</b>\n\n"
               f"‚Ä¢ Blog: www.dianacreaciones.com/blog\n"
               f"‚Ä¢ Newsletter: Suscripci√≥n gratuita\n"
               f"‚Ä¢ Comunidad: Grupo p√∫blico de Telegram\n\n"
               f"<i>Seguir a Diana en redes sociales puede acelerar "
               f"su acceso al canal Free.</i>"
           )

           # Create back button
           from aiogram.utils.keyboard import InlineKeyboardBuilder
           keyboard = InlineKeyboardBuilder()
           keyboard.button(text="‚¨ÖÔ∏è Volver", callback_data="menu:back")

           await callback.message.edit_text(
               message_text,
               parse_mode="HTML",
               reply_markup=keyboard.as_markup()
           )
           await callback.answer()

           logger.info(f"üÜì Redes sociales mostradas a {callback.from_user.id}")

       except Exception as e:
           logger.error(f"Error mostrando redes sociales a {callback.from_user.id}: {e}")
           await callback.answer("‚ö†Ô∏è Error cargando redes sociales", show_alert=True)
   ```

5. Reuse interest handler from VIP callbacks (same pattern):
   ```python
   @free_callbacks_router.callback_query(lambda c: c.data and c.data.startswith("interest:package:"))
   async def handle_package_interest(callback: CallbackQuery, **kwargs):
       """
       Registra inter√©s de usuario en paquete FREE_CONTENT.

       Reutiliza l√≥gica de VIP callbacks.
       """
       data = kwargs.get("data", {})
       container = data.get("container")
       user = callback.from_user

       if not container:
           await callback.answer("‚ö†Ô∏è Error: servicio no disponible", show_alert=True)
           return

       try:
           # Extract package ID from callback data
           package_id_str = callback.data.split(":")[-1]
           package_id = int(package_id_str)

           # Create UserInterest record
           from bot.database.models import UserInterest
           from sqlalchemy import select

           # Get session from handler data (injected by DatabaseMiddleware)
           session = data.get("session")
           if not session:
               await callback.answer("‚ö†Ô∏è Error: sesi√≥n de base de datos no disponible", show_alert=True)
               return

           # Check if interest already exists for this user+package
           stmt = select(UserInterest).where(
               UserInterest.user_id == user.id,
               UserInterest.package_id == package_id
           )
           result = await session.execute(stmt)
           existing_interest = result.scalar_one_or_none()

           if existing_interest:
               # Update timestamp for existing interest
               existing_interest.created_at = datetime.utcnow()
               logger.info(f"‚ù§Ô∏è Usuario Free {user.id} actualiz√≥ inter√©s en paquete {package_id}")
               # Admin notification (for consistency with VIP)
               logger.info(f"üì¢ ADMIN NOTIFICATION: Usuario Free {user.id} ({user.first_name}) actualiz√≥ inter√©s en paquete {package_id}")
           else:
               # Create new interest record
               interest = UserInterest(
                   user_id=user.id,
                   package_id=package_id,
                   is_attended=False,
                   attended_at=None,
                   created_at=datetime.utcnow()
               )
               session.add(interest)
               logger.info(f"‚ù§Ô∏è Usuario Free {user.id} interesado en paquete {package_id} (nuevo registro)")
               # Admin notification (for consistency with VIP)
               logger.info(f"üì¢ ADMIN NOTIFICATION: Nuevo inter√©s de usuario Free {user.id} ({user.first_name}) en paquete {package_id}")

           await callback.answer(
               "‚úÖ Tu inter√©s ha sido registrado. Diana ser√° notificada.",
               show_alert=True
           )

       except (ValueError, IndexError) as e:
           logger.error(f"Error parsing package ID from callback {callback.data}: {e}")
           await callback.answer("‚ö†Ô∏è Error: ID de paquete inv√°lido", show_alert=True)
       except Exception as e:
           logger.error(f"Error registrando inter√©s para {user.id}: {e}")
           await callback.answer("‚ö†Ô∏è Error registrando inter√©s", show_alert=True)
   ```

6. Add navigation handlers (reuse from VIP pattern):
   ```python
   @free_callbacks_router.callback_query(lambda c: c.data == "menu:back")
   async def handle_menu_back(callback: CallbackQuery, **kwargs):
       """Vuelve al men√∫ principal Free."""
       data = kwargs.get("data", {})
       container = data.get("container")
       user = callback.from_user

       if not container:
           await callback.answer("‚ö†Ô∏è Error: servicio no disponible", show_alert=True)
           return

       try:
           from .menu import show_free_menu
           await show_free_menu(callback.message, data)
           await callback.answer()
       except Exception as e:
           logger.error(f"Error volviendo al men√∫ Free para {user.id}: {e}")
           await callback.answer("‚ö†Ô∏è Error volviendo al men√∫", show_alert=True)

   @free_callbacks_router.callback_query(lambda c: c.data == "menu:exit")
   async def handle_menu_exit(callback: CallbackQuery):
       """Cierra el men√∫ Free."""
       try:
           await callback.message.delete()
           await callback.answer("Men√∫ cerrado")
       except Exception as e:
           logger.error(f"Error cerrando men√∫ Free para {callback.from_user.id}: {e}")
           await callback.answer("‚ö†Ô∏è Error cerrando men√∫", show_alert=True)
   ```

7. Add router export:
   ```python
   __all__ = ["free_callbacks_router"]
   ```
  </action>
  <verify>
1. File `/data/data/com.termux/files/home/repos/c1/bot/handlers/free/callbacks.py` created
2. Router `free_callbacks_router` defined with 6 callback handlers
3. `handle_free_content` gets FREE_CONTENT packages from ContentService and passes them to UserMenuProvider for dynamic button creation
4. `handle_vip_info` shows VIP channel subscription information
5. `handle_social_media` displays social media and free content
6. Interest handler reuses VIP pattern for consistency, uses `session = data.get("session")`, and includes admin notification logging
7. Navigation handlers implemented
8. All handlers include proper error handling
  </verify>
  <done>Free callback handlers created for content browsing, VIP info, social media, and navigation.</done>
</task>

<task type="auto">
  <name>Task 3: Update Free __init__.py and test integration</name>
  <files>/data/data/com.termux/files/home/repos/c1/bot/handlers/free/__init__.py</files>
  <action>
Update `/data/data/com.termux/files/home/repos/c1/bot/handlers/free/__init__.py` to export the new callback router and test integration:

1. Update the existing `__init__.py` file:
   ```python
   """
   Free Handlers Package - Men√∫ y funcionalidades para usuarios Free.

   Exporta:
   - show_free_menu: Handler principal del men√∫ Free
   - free_callbacks_router: Router para callbacks del men√∫ Free
   """

   from .menu import show_free_menu
   from .callbacks import free_callbacks_router

   __all__ = ["show_free_menu", "free_callbacks_router"]
   ```

2. Test Free menu integration:
   Create a test script `/tmp/test_free_menu.py`:
   ```python
   import sys
   sys.path.insert(0, '/data/data/com.termux/files/home/repos/c1')

   # Test imports work
   from bot.handlers.free import show_free_menu, free_callbacks_router
   print("‚úÖ Free handlers import successful")
   print(f"‚úÖ free_callbacks_router has {len(free_callbacks_router.handlers)} handlers")

   # Test callback patterns
   from aiogram import Dispatcher
   dp = Dispatcher()
   dp.include_router(free_callbacks_router)
   print("‚úÖ free_callbacks_router can be included in dispatcher")

   # Verify handler names
   handler_names = [h.callback.__name__ for h in free_callbacks_router.handlers]
   required_handlers = [
       'handle_free_content',
       'handle_vip_info',
       'handle_social_media',
       'handle_package_interest',
       'handle_menu_back',
       'handle_menu_exit'
   ]

   for req in required_handlers:
       if req in handler_names:
           print(f"‚úÖ {req} handler registered")
       else:
           print(f"‚ùå {req} handler missing")

   print("\nüéâ Free handlers integration test passed")
   ```

3. Run test:
   ```bash
   cd /data/data/com.termux/files/home/repos/c1
   python /tmp/test_free_menu.py
   ```

4. Clean up test file:
   ```bash
   rm /tmp/test_free_menu.py
   ```

5. Verify MenuRouter integration still works:
   Check that `bot/handlers/menu_router.py` can still import `show_free_menu` without errors.
  </action>
  <verify>
1. `__init__.py` exports both `show_free_menu` and `free_callbacks_router`
2. Imports work without errors
3. Test script runs successfully with all 6 handlers detected
4. Callback router can be registered in dispatcher
5. MenuRouter can still import `show_free_menu`
  </verify>
  <done>Free handlers package updated with callback router export and integration tested.</done>
</task>

</tasks>

<verification>
Overall verification for Plan 03:
1. Run test script from Task 3 - all tests must pass
2. Verify Free menu handler uses UserMenuProvider for messages
3. Check that callback handlers exist for content browsing, VIP info, and social media
4. Ensure "Mi Contenido" section shows FREE_CONTENT packages
5. Confirm VIP info section displays subscription information
6. Validate social media section shows Diana's social links
7. Test navigation works correctly
</verification>

<success_criteria>
1. ‚úÖ Free menu handler enhanced to use UserMenuProvider
2. ‚úÖ Free callback handlers created for content browsing, VIP info, and social media
3. ‚úÖ "Mi Contenido" section gets FREE_CONTENT packages from ContentService
4. ‚úÖ VIP info section shows subscription benefits and channel status
5. ‚úÖ Social media section displays Diana's social links
6. ‚úÖ Interest handler reuses VIP pattern for consistency
7. ‚úÖ All tests pass without errors
</success_criteria>

<output>
After completion, create `.planning/phases/06-vip-free-user-menus/06-03-SUMMARY.md`
</output>

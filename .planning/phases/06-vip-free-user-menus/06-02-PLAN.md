---
phase: 06-vip-free-user-menus
plan: 02
type: execute
wave: 2
depends_on: ["06-01"]
files_modified:
  - /data/data/com.termux/files/home/repos/c1/bot/handlers/vip/menu.py
  - /data/data/com.termux/files/home/repos/c1/bot/handlers/vip/__init__.py
  - /data/data/com.termux/files/home/repos/c1/bot/handlers/vip/callbacks.py
autonomous: true

must_haves:
  truths:
    - "VIP menu handler uses UserMenuProvider for Lucien-voiced messages"
    - "VIP menu displays subscription expiration information"
    - "VIP premium section shows active VIP_PREMIUM content packages"
    - "Each premium package has 'Me interesa' button that creates/updates UserInterest record"
    - "VIP menu navigation includes 'Volver' button to main menu"
  artifacts:
    - path: "/data/data/com.termux/files/home/repos/c1/bot/handlers/vip/menu.py"
      provides: "Enhanced VIP menu handler with UserMenuProvider integration"
      min_lines: 120
      contains: "container.message.user.menu.vip_menu_greeting"
    - path: "/data/data/com.termux/files/home/repos/c1/bot/handlers/vip/callbacks.py"
      provides: "Callback handlers for VIP menu interactions"
      min_lines: 80
      contains: "async def handle_vip_premium"
  key_links:
    - from: "/data/data/com.termux/files/home/repos/c1/bot/handlers/vip/menu.py"
      to: "/data/data/com.termux/files/home/repos/c1/bot/services/message/user_menu.py"
      via: "UserMenuProvider method calls"
      pattern: "container\\.message\\.user\\.menu\\.vip_menu_greeting"
    - from: "/data/data/com.termux/files/home/repos/c1/bot/handlers/vip/callbacks.py"
      to: "/data/data/com.termux/files/home/repos/c1/bot/services/content.py"
      via: "ContentService calls to get VIP_PREMIUM packages"
      pattern: "container\\.content\\.get_active_packages"
---

<objective>
Enhance VIP menu handler to use UserMenuProvider for Lucien-voiced messages, display subscription information, and implement premium content section with "Me interesa" buttons.

Purpose: Enable VIPMENU-01 (subscription info), VIPMENU-02 (premium section), VIPMENU-03 ("Me interesa" buttons), and VIPMENU-04 (navigation) requirements. Replace hardcoded handler text with voice-compliant messages.

Output: Enhanced VIP menu handler with subscription info display, premium content browsing, and "Me interesa" functionality that creates UserInterest records.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/REQUIREMENTS.md

# Reference existing VIP menu handler and callback patterns
@/data/data/com.termux/files/home/repos/c1/bot/handlers/vip/menu.py
@/data/data/com.termux/files/home/repos/c1/bot/handlers/admin/menu.py
@/data/data/com.termux/files/home/repos/c1/bot/services/content.py
@/data/data/com.termux/files/home/repos/c1/bot/database/enums.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Enhance VIP menu handler with UserMenuProvider</name>
  <files>/data/data/com.termux/files/home/repos/c1/bot/handlers/vip/menu.py</files>
  <action>
Update the existing `show_vip_menu` function in `/data/data/com.termux/files/home/repos/c1/bot/handlers/vip/menu.py` to use UserMenuProvider:

1. Replace hardcoded message generation with UserMenuProvider calls:
   - Get subscription info from `container.subscription.get_vip_subscriber()`
   - Extract expiration date if available
   - Call `container.message.user.menu.vip_menu_greeting()` with user info
   - Pass session history for context-aware variations: `container.message.get_session_context(container)`

2. Update imports:
   - Add `from bot.database.enums import ContentCategory`
   - Remove hardcoded keyboard creation imports if no longer needed

3. Enhanced implementation:
   ```python
   async def show_vip_menu(message: Message, data: Dict[str, Any]):
       user = message.from_user
       container = data.get("container")

       # Get VIP subscription info
       vip_expires_at = None
       if container:
           try:
               subscriber = await container.subscription.get_vip_subscriber(user.id)
               if subscriber and subscriber.expires_at:
                   vip_expires_at = subscriber.expires_at
           except Exception as e:
               logger.error(f"Error obteniendo info VIP para {user.id}: {e}")

       # Get session context for message variations
       session_ctx = None
       if container:
           session_ctx = container.message.get_session_context(container)

       # Generate Lucien-voiced menu message
       text, keyboard = container.message.user.menu.vip_menu_greeting(
           user_name=user.first_name,
           vip_expires_at=vip_expires_at,
           user_id=user.id,
           session_history=session_ctx
       )

       await message.answer(text, parse_mode="HTML", reply_markup=keyboard)
       logger.info(f"‚≠ê Men√∫ VIP mostrado a {user.id} (voz de Lucien)")
   ```

4. Remove old hardcoded message and keyboard creation code
5. Keep error handling for missing container
6. Update docstring to reflect UserMenuProvider usage
  </action>
  <verify>
1. `show_vip_menu` function uses `container.message.user.menu.vip_menu_greeting()`
2. Subscription expiration date extracted and passed to message provider
3. Session context passed for variation tracking
4. Hardcoded message generation removed
5. Function still handles missing container gracefully
6. Parse mode changed to "HTML" (UserMenuProvider uses HTML formatting)
  </verify>
  <done>VIP menu handler enhanced to use UserMenuProvider with subscription info display.</done>
</task>

<task type="auto">
  <name>Task 2: Create VIP callback handlers for premium section</name>
  <files>/data/data/com.termux/files/home/repos/c1/bot/handlers/vip/callbacks.py</files>
<ÔΩúDSMLÔΩúparameter name="action" string="true">
Create a new file `/data/data/com.termux/files/home/repos/c1/bot/handlers/vip/callbacks.py` with callback handlers for VIP menu interactions:

1. Create the file with imports and router setup:
   ```python
   """
   VIP Callback Handlers - Gesti√≥n de interacciones del men√∫ VIP.

   Responsabilidades:
   - Manejar callback "vip:premium" - mostrar secci√≥n premium
   - Manejar callback "interest:package:{id}" - registrar inter√©s en paquete
   - Manejar callback "menu:back" - volver al men√∫ principal VIP
   - Manejar callback "menu:exit" - cerrar men√∫

   Pattern: Sigue estructura de admin callbacks con router separado.
   """
   import logging
   from datetime import datetime
   from typing import Dict, Any

   from aiogram import Router, types
   from aiogram.types import CallbackQuery, Message
   from aiogram.filters import CallbackData

   from bot.database.enums import ContentCategory

   logger = logging.getLogger(__name__)

   # Create router
   vip_callbacks_router = Router()
   ```

2. Add callback handler for VIP premium section:
   ```python
   @vip_callbacks_router.callback_query(lambda c: c.data == "vip:premium")
   async def handle_vip_premium(callback: CallbackQuery, **kwargs):
       """
       Muestra secci√≥n premium con paquetes VIP_PREMIUM.

       Args:
           callback: CallbackQuery de Telegram
           **kwargs: Data del handler (container, session, etc.)
       """
       data = kwargs.get("data", {})
       container = data.get("container")
       user = callback.from_user

       if not container:
           await callback.answer("‚ö†Ô∏è Error: servicio no disponible", show_alert=True)
           return

       try:
           # Get active VIP_PREMIUM packages
           packages = await container.content.get_active_packages(
               category=ContentCategory.VIP_PREMIUM,
               limit=20
           )

           # Get session context for message variations
           session_ctx = container.message.get_session_context(container)

           # Generate premium section message with dynamic package buttons
           text, keyboard = container.message.user.menu.vip_premium_section(
               user_name=user.first_name,
               packages=packages,
               user_id=user.id,
               session_history=session_ctx
           )

           # Update message with premium section
           await callback.message.edit_text(text, parse_mode="HTML", reply_markup=keyboard)
           await callback.answer()

           logger.info(f"‚≠ê Secci√≥n premium mostrada a {user.id} ({len(packages)} paquetes)")

       except Exception as e:
           logger.error(f"Error mostrando secci√≥n premium a {user.id}: {e}")
           await callback.answer("‚ö†Ô∏è Error cargando contenido premium", show_alert=True)
   ```

3. Add callback handler for "Me interesa" button:
   ```python
   @vip_callbacks_router.callback_query(lambda c: c.data and c.data.startswith("interest:package:"))
   async def handle_package_interest(callback: CallbackQuery, **kwargs):
       """
       Registra inter√©s de usuario en paquete espec√≠fico.

       Callback data format: "interest:package:{package_id}"

       Args:
           callback: CallbackQuery de Telegram
           **kwargs: Data del handler (container, session, etc.)
       """
       data = kwargs.get("data", {})
       container = data.get("container")
       user = callback.from_user

       if not container:
           await callback.answer("‚ö†Ô∏è Error: servicio no disponible", show_alert=True)
           return

       try:
           # Extract package ID from callback data
           package_id_str = callback.data.split(":")[-1]
           package_id = int(package_id_str)

           # Create UserInterest record
           from bot.database.models import UserInterest
           from sqlalchemy import select

           # Get session from handler data (injected by DatabaseMiddleware)
           session = data.get("session")
           if not session:
               await callback.answer("‚ö†Ô∏è Error: sesi√≥n de base de datos no disponible", show_alert=True)
               return

           # Check if interest already exists for this user+package
           stmt = select(UserInterest).where(
               UserInterest.user_id == user.id,
               UserInterest.package_id == package_id
           )
           result = await session.execute(stmt)
           existing_interest = result.scalar_one_or_none()

           if existing_interest:
               # Update timestamp for existing interest
               existing_interest.created_at = datetime.utcnow()
               logger.info(f"‚ù§Ô∏è Usuario {user.id} actualiz√≥ inter√©s en paquete {package_id}")
               # Admin notification (VIPMENU-03 requirement)
               logger.info(f"üì¢ ADMIN NOTIFICATION: Usuario VIP {user.id} ({user.first_name}) actualiz√≥ inter√©s en paquete {package_id}")
           else:
               # Create new interest record
               interest = UserInterest(
                   user_id=user.id,
                   package_id=package_id,
                   is_attended=False,
                   attended_at=None,
                   created_at=datetime.utcnow()
               )
               session.add(interest)
               logger.info(f"‚ù§Ô∏è Usuario {user.id} interesado en paquete {package_id} (nuevo registro)")
               # Admin notification (VIPMENU-03 requirement)
               logger.info(f"üì¢ ADMIN NOTIFICATION: Nuevo inter√©s de usuario VIP {user.id} ({user.first_name}) en paquete {package_id}")

           # Show success feedback
           await callback.answer(
               "‚úÖ Tu inter√©s ha sido registrado. Diana ser√° notificada.",
               show_alert=True
           )

       except (ValueError, IndexError) as e:
           logger.error(f"Error parsing package ID from callback {callback.data}: {e}")
           await callback.answer("‚ö†Ô∏è Error: ID de paquete inv√°lido", show_alert=True)
       except Exception as e:
           logger.error(f"Error registrando inter√©s para {user.id}: {e}")
           await callback.answer("‚ö†Ô∏è Error registrando inter√©s", show_alert=True)
   ```

4. Add navigation callback handlers:
   ```python
   @vip_callbacks_router.callback_query(lambda c: c.data == "menu:back")
   async def handle_menu_back(callback: CallbackQuery, **kwargs):
       """
       Vuelve al men√∫ principal VIP.

       Args:
           callback: CallbackQuery de Telegram
           **kwargs: Data del handler (container, session, etc.)
       """
       data = kwargs.get("data", {})
       container = data.get("container")
       user = callback.from_user

       if not container:
           await callback.answer("‚ö†Ô∏è Error: servicio no disponible", show_alert=True)
           return

       try:
           # Re-show VIP menu (reusing show_vip_menu logic)
           from .menu import show_vip_menu
           await show_vip_menu(callback.message, data)
           await callback.answer()

       except Exception as e:
           logger.error(f"Error volviendo al men√∫ VIP para {user.id}: {e}")
           await callback.answer("‚ö†Ô∏è Error volviendo al men√∫", show_alert=True)

   @vip_callbacks_router.callback_query(lambda c: c.data == "menu:exit")
   async def handle_menu_exit(callback: CallbackQuery):
       """
       Cierra el men√∫ (elimina mensaje).

       Args:
           callback: CallbackQuery de Telegram
       """
       try:
           await callback.message.delete()
           await callback.answer("Men√∫ cerrado")
       except Exception as e:
           logger.error(f"Error cerrando men√∫ para {callback.from_user.id}: {e}")
           await callback.answer("‚ö†Ô∏è Error cerrando men√∫", show_alert=True)
   ```

5. Add router export at bottom:
   ```python
   __all__ = ["vip_callbacks_router"]
   ```
  </action>
  <verify>
1. File `/data/data/com.termux/files/home/repos/c1/bot/handlers/vip/callbacks.py` created
2. Router `vip_callbacks_router` defined with 4 callback handlers
3. `handle_vip_premium` gets VIP_PREMIUM packages from ContentService and passes them to UserMenuProvider for dynamic button creation
4. `handle_package_interest` parses package ID from callback data, uses `session = data.get("session")`, and includes admin notification logging (VIPMENU-03)
5. Navigation handlers `handle_menu_back` and `handle_menu_exit` implemented
6. All handlers include proper error handling and logging
7. Router exported in `__all__`
  </verify>
  <done>VIP callback handlers created for premium section, interest registration, and navigation.</done>
</task>

<task type="auto">
  <name>Task 3: Update VIP __init__.py and register callbacks</name>
  <files>/data/data/com.termux/files/home/repos/c1/bot/handlers/vip/__init__.py</files>
  <action>
Update `/data/data/com.termux/files/home/repos/c1/bot/handlers/vip/__init__.py` to export the new callback router and ensure it's registered in the main application:

1. Update the existing `__init__.py` file:
   ```python
   """
   VIP Handlers Package - Men√∫ y funcionalidades para usuarios VIP.

   Exporta:
   - show_vip_menu: Handler principal del men√∫ VIP
   - vip_callbacks_router: Router para callbacks del men√∫ VIP
   """

   from .menu import show_vip_menu
   from .callbacks import vip_callbacks_router

   __all__ = ["show_vip_menu", "vip_callbacks_router"]
   ```

2. Verify callback router is registered in main application:
   Check `/data/data/com.termux/files/home/repos/c1/main.py` to ensure VIP callbacks router is included.
   If not present, add it (but this might be handled by MenuRouter integration).

3. Test VIP menu integration:
   Create a simple test script `/tmp/test_vip_menu.py`:
   ```python
   import sys
   sys.path.insert(0, '/data/data/com.termux/files/home/repos/c1')

   # Test imports work
   from bot.handlers.vip import show_vip_menu, vip_callbacks_router
   print("‚úÖ VIP handlers import successful")
   print(f"‚úÖ vip_callbacks_router has {len(vip_callbacks_router.handlers)} handlers")

   # Test callback patterns are registered
   from aiogram import Dispatcher
   dp = Dispatcher()
   dp.include_router(vip_callbacks_router)
   print("‚úÖ vip_callbacks_router can be included in dispatcher")

   print("\nüéâ VIP handlers integration test passed")
   ```

4. Run test:
   ```bash
   cd /data/data/com.termux/files/home/repos/c1
   python /tmp/test_vip_menu.py
   ```

5. Clean up test file:
   ```bash
   rm /tmp/test_vip_menu.py
   ```
  </action>
  <verify>
1. `__init__.py` exports both `show_vip_menu` and `vip_callbacks_router`
2. Imports work without errors
3. Test script runs successfully
4. Callback router can be registered in dispatcher
5. MenuRouter in `bot/handlers/menu_router.py` can still import `show_vip_menu`
  </verify>
  <done>VIP handlers package updated with callback router export and integration tested.</done>
</task>

</tasks>

<verification>
Overall verification for Plan 02:
1. Run test scripts from Tasks 1 and 3 - all tests must pass
2. Verify VIP menu handler uses UserMenuProvider for messages
3. Check that callback handlers exist for premium section and interest registration
4. Ensure navigation works: "Volver" returns to main menu, "Salir" closes menu
5. Confirm ContentService is called to get VIP_PREMIUM packages
6. Validate error handling in all callback handlers
</verification>

<success_criteria>
1. ‚úÖ VIP menu handler enhanced to use UserMenuProvider with subscription info
2. ‚úÖ VIP callback handlers created for premium section and interest registration
3. ‚úÖ Navigation callbacks implemented ("Volver", "Salir")
4. ‚úÖ ContentService integration for getting VIP_PREMIUM packages
5. ‚úÖ VIP handlers package exports callback router
6. ‚úÖ All tests pass without errors
</success_criteria>

<output>
After completion, create `.planning/phases/06-vip-free-user-menus/06-02-SUMMARY.md`
</output>


---
phase: 24-admin-configuration
plan: 04
type: execute
wave: 2
depends_on: ["24-01"]
files_modified:
  - bot/services/stats.py
  - bot/handlers/admin/economy_stats.py
  - bot/handlers/admin/__init__.py
autonomous: true

must_haves:
  truths:
    - Admin can view economy metrics dashboard
    - Metrics include total besitos in circulation
    - Metrics include active users with gamification profiles
    - Metrics include total transactions by type
    - Metrics include average balance per user
    - Metrics include top earners/spenders
  artifacts:
    - path: "bot/services/stats.py"
      provides: "Economy metrics calculation methods"
      contains: ["get_economy_stats", "EconomyStats"]
    - path: "bot/handlers/admin/economy_stats.py"
      provides: "Admin handlers for economy metrics display"
      contains: ["admin:economy_stats", "admin:economy:users"]
    - path: "bot/handlers/admin/__init__.py"
      provides: "Router registration"
      contains: ["economy_stats"]
  key_links:
    - from: "bot/handlers/admin/economy_stats.py"
      to: "bot/services/stats.py"
      via: "StatsService.get_economy_stats()"
      pattern: "container.stats.get_economy_stats"
    - from: "bot/services/stats.py"
      to: "bot/database/models.py"
      via: "UserGamificationProfile, Transaction queries"
      pattern: "UserGamificationProfile|Transaction"
---

<objective>
Implement economy metrics dashboard for admin (ADMIN-07).

Purpose: Allow administrators to view economy metrics including total besitos in circulation, active users, and transaction statistics.
Output: Economy stats service methods and admin handlers for metrics display.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/STATE.md
@.planning/ROADMAP.md
@bot/services/stats.py
@bot/database/models.py
@bot/handlers/admin/dashboard.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add Economy Stats to StatsService</name>
  <files>bot/services/stats.py</files>
  <action>
Add economy metrics calculation to bot/services/stats.py:

**New Dataclass (after TokenStats):**
```python
@dataclass
class EconomyStats:
    """EstadÃ­sticas de economÃ­a y gamificaciÃ³n."""

    # Totals
    total_besitos_circulation: int  # Sum of all balances
    total_besitos_earned_lifetime: int  # Sum of total_earned
    total_besitos_spent_lifetime: int  # Sum of total_spent

    # Users
    total_users_with_profile: int
    active_users_this_week: int  # Users with transactions in last 7 days
    active_users_this_month: int

    # Averages
    avg_balance: float
    avg_total_earned: float

    # Transactions
    transactions_today: int
    transactions_this_week: int
    transactions_this_month: int
    transactions_by_type: Dict[str, int]  # Count by TransactionType

    # Top users
    top_earners: List[Dict]  # [{user_id, total_earned, level}]
    top_spenders: List[Dict]  # [{user_id, total_spent, level}]
    top_balances: List[Dict]  # [{user_id, balance, level}]

    # Levels distribution
    level_distribution: Dict[int, int]  # {level: count}

    calculated_at: datetime

    def to_dict(self) -> Dict:
        data = asdict(self)
        data['calculated_at'] = self.calculated_at.isoformat()
        return data
```

**New Method in StatsService class:**
```python
async def get_economy_stats(self, force_refresh: bool = False) -> EconomyStats:
    """
    Obtiene estadÃ­sticas de economÃ­a y gamificaciÃ³n.

    Args:
        force_refresh: Si True, ignora cache

    Returns:
        EconomyStats con mÃ©tricas de economÃ­a
    """
    cache_key = "economy_stats"

    if not force_refresh:
        cached = self._get_from_cache(cache_key)
        if cached:
            return cached

    logger.info("ğŸ“Š Calculando estadÃ­sticas de economÃ­a...")

    # Import models
    from bot.database.models import UserGamificationProfile, Transaction, User

    # Totals
    total_circulation = await self._calculate_total_besitos_circulation()
    total_earned = await self._calculate_total_besitos_earned()
    total_spent = await self._calculate_total_besitos_spent()

    # Users
    total_profiles = await self._count_gamification_profiles()
    active_week = await self._count_active_users(days=7)
    active_month = await self._count_active_users(days=30)

    # Averages
    avg_balance = await self._calculate_avg_balance()
    avg_earned = await self._calculate_avg_total_earned()

    # Transactions
    tx_today = await self._count_transactions_in_period(days=1)
    tx_week = await self._count_transactions_in_period(days=7)
    tx_month = await self._count_transactions_in_period(days=30)
    tx_by_type = await self._count_transactions_by_type()

    # Top users
    top_earners = await self._get_top_earners(limit=5)
    top_spenders = await self._get_top_spenders(limit=5)
    top_balances = await self._get_top_balances(limit=5)

    # Level distribution
    level_dist = await self._get_level_distribution()

    stats = EconomyStats(
        total_besitos_circulation=total_circulation,
        total_besitos_earned_lifetime=total_earned,
        total_besitos_spent_lifetime=total_spent,
        total_users_with_profile=total_profiles,
        active_users_this_week=active_week,
        active_users_this_month=active_month,
        avg_balance=avg_balance,
        avg_total_earned=avg_earned,
        transactions_today=tx_today,
        transactions_this_week=tx_week,
        transactions_this_month=tx_month,
        transactions_by_type=tx_by_type,
        top_earners=top_earners,
        top_spenders=top_spenders,
        top_balances=top_balances,
        level_distribution=level_dist,
        calculated_at=datetime.utcnow()
    )

    self._set_cache(cache_key, stats)

    logger.info(f"âœ… Economy stats calculadas: {total_circulation} besitos en circulaciÃ³n")

    return stats
```

**Helper Methods (add to StatsService):**
```python
# ===== ECONOMY STATS HELPERS =====

async def _calculate_total_besitos_circulation(self) -> int:
    """Suma de todos los balances de usuarios."""
    from bot.database.models import UserGamificationProfile
    result = await self.session.execute(
        select(func.sum(UserGamificationProfile.balance))
    )
    return result.scalar() or 0

async def _calculate_total_besitos_earned(self) -> int:
    """Suma de total_earned lifetime."""
    from bot.database.models import UserGamificationProfile
    result = await self.session.execute(
        select(func.sum(UserGamificationProfile.total_earned))
    )
    return result.scalar() or 0

async def _calculate_total_besitos_spent(self) -> int:
    """Suma de total_spent lifetime."""
    from bot.database.models import UserGamificationProfile
    result = await self.session.execute(
        select(func.sum(UserGamificationProfile.total_spent))
    )
    return result.scalar() or 0

async def _count_gamification_profiles(self) -> int:
    """Cantidad de usuarios con perfil de gamificaciÃ³n."""
    from bot.database.models import UserGamificationProfile
    result = await self.session.execute(
        select(func.count(UserGamificationProfile.id))
    )
    return result.scalar() or 0

async def _count_active_users(self, days: int) -> int:
    """Usuarios con transacciones en los Ãºltimos X dÃ­as."""
    from bot.database.models import Transaction
    cutoff_date = datetime.utcnow() - timedelta(days=days)
    result = await self.session.execute(
        select(func.count(func.distinct(Transaction.user_id)))
        .where(Transaction.created_at >= cutoff_date)
    )
    return result.scalar() or 0

async def _calculate_avg_balance(self) -> float:
    """Balance promedio por usuario."""
    from bot.database.models import UserGamificationProfile
    result = await self.session.execute(
        select(func.avg(UserGamificationProfile.balance))
    )
    return round(result.scalar() or 0, 2)

async def _calculate_avg_total_earned(self) -> float:
    """Total earned promedio por usuario."""
    from bot.database.models import UserGamificationProfile
    result = await self.session.execute(
        select(func.avg(UserGamificationProfile.total_earned))
    )
    return round(result.scalar() or 0, 2)

async def _count_transactions_in_period(self, days: int) -> int:
    """Cantidad de transacciones en perÃ­odo."""
    from bot.database.models import Transaction
    cutoff_date = datetime.utcnow() - timedelta(days=days)
    result = await self.session.execute(
        select(func.count(Transaction.id))
        .where(Transaction.created_at >= cutoff_date)
    )
    return result.scalar() or 0

async def _count_transactions_by_type(self) -> Dict[str, int]:
    """Conteo de transacciones por tipo."""
    from bot.database.models import Transaction
    result = await self.session.execute(
        select(Transaction.type, func.count(Transaction.id))
        .group_by(Transaction.type)
    )
    return {row[0].value: row[1] for row in result.all()}

async def _get_top_earners(self, limit: int = 5) -> List[Dict]:
    """Top usuarios por total_earned."""
    from bot.database.models import UserGamificationProfile
    result = await self.session.execute(
        select(
            UserGamificationProfile.user_id,
            UserGamificationProfile.total_earned,
            UserGamificationProfile.level
        )
        .order_by(UserGamificationProfile.total_earned.desc())
        .limit(limit)
    )
    return [
        {"user_id": row[0], "total_earned": row[1], "level": row[2]}
        for row in result
    ]

async def _get_top_spenders(self, limit: int = 5) -> List[Dict]:
    """Top usuarios por total_spent."""
    from bot.database.models import UserGamificationProfile
    result = await self.session.execute(
        select(
            UserGamificationProfile.user_id,
            UserGamificationProfile.total_spent,
            UserGamificationProfile.level
        )
        .order_by(UserGamificationProfile.total_spent.desc())
        .limit(limit)
    )
    return [
        {"user_id": row[0], "total_spent": row[1], "level": row[2]}
        for row in result
    ]

async def _get_top_balances(self, limit: int = 5) -> List[Dict]:
    """Top usuarios por balance actual."""
    from bot.database.models import UserGamificationProfile
    result = await self.session.execute(
        select(
            UserGamificationProfile.user_id,
            UserGamificationProfile.balance,
            UserGamificationProfile.level
        )
        .order_by(UserGamificationProfile.balance.desc())
        .limit(limit)
    )
    return [
        {"user_id": row[0], "balance": row[1], "level": row[2]}
        for row in result
    ]

async def _get_level_distribution(self) -> Dict[int, int]:
    """DistribuciÃ³n de usuarios por nivel."""
    from bot.database.models import UserGamificationProfile
    result = await self.session.execute(
        select(UserGamificationProfile.level, func.count(UserGamificationProfile.id))
        .group_by(UserGamificationProfile.level)
        .order_by(UserGamificationProfile.level)
    )
    return {row[0]: row[1] for row in result}
```
  </action>
  <verify>grep -q "class EconomyStats" bot/services/stats.py && grep -q "get_economy_stats" bot/services/stats.py</verify>
  <done>EconomyStats dataclass and get_economy_stats method exist with all helper methods</done>
</task>

<task type="auto">
  <name>Task 2: Create Economy Stats Handler</name>
  <files>bot/handlers/admin/economy_stats.py</files>
  <action>
Create bot/handlers/admin/economy_stats.py with handlers for economy metrics:

**Imports:**
- Import logging, aiogram (F, CallbackQuery)
- Import admin_router from bot.handlers.admin.main
- Import ServiceContainer from bot.services.container
- Import create_inline_keyboard from bot.utils.keyboards

**Main Handler (admin:economy_stats):**
- Callback handler for "admin:economy_stats"
- Get economy stats from container.stats.get_economy_stats()
- Format message with Lucien's voice (ğŸ©):
  ```
  ğŸ© <b>MÃ©tricas de EconomÃ­a</b>

  â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
  â”ƒ <b>ğŸ’° BESITOS EN CIRCULACIÃ“N</b>
  â”£â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
  â”ƒ Total en circulaciÃ³n: <b>{total_circulation}</b>
  â”ƒ Total ganado (lifetime): {total_earned}
  â”ƒ Total gastado (lifetime): {total_spent}
  â”—â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

  â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
  â”ƒ <b>ğŸ‘¥ USUARIOS ACTIVOS</b>
  â”£â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
  â”ƒ Con perfil: <b>{total_profiles}</b>
  â”ƒ Activos (7 dÃ­as): {active_week}
  â”ƒ Activos (30 dÃ­as): {active_month}
  â”—â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

  â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
  â”ƒ <b>ğŸ“Š PROMEDIOS</b>
  â”£â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
  â”ƒ Balance promedio: {avg_balance} ğŸ’°
  â”ƒ Total ganado avg: {avg_earned} ğŸ’°
  â”—â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

  â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
  â”ƒ <b>ğŸ“ˆ TRANSACCIONES</b>
  â”£â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
  â”ƒ Hoy: {tx_today}
  â”ƒ Esta semana: {tx_week}
  â”ƒ Este mes: {tx_month}
  â”—â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

  <i>Actualizado: {timestamp} UTC</i>
  ```
- Keyboard:
  - "ğŸ† Top Usuarios" -> admin:economy:top_users
  - "ğŸ“Š DistribuciÃ³n" -> admin:economy:levels
  - "ğŸ”„ Actualizar" -> admin:economy_stats
  - "ğŸ”™ Volver" -> admin:main

**Top Users Handler (admin:economy:top_users):**
- Show top earners, spenders, and balances
- Format:
  ```
  ğŸ© <b>Top Usuarios</b>

  <b>ğŸ’° Top Ganadores:</b>
  1. User {id} - L{level}: {amount} besitos
  2. ...

  <b>ğŸ›ï¸ Top Gastadores:</b>
  1. User {id} - L{level}: {amount} besitos
  2. ...

  <b>ğŸ¦ Mayores Balances:</b>
  1. User {id} - L{level}: {amount} besitos
  2. ...
  ```
- Keyboard: "ğŸ”™ MÃ©tricas" -> admin:economy_stats

**Level Distribution Handler (admin:economy:levels):**
- Show distribution of users by level
- Format:
  ```
  ğŸ© <b>DistribuciÃ³n por Nivel</b>

  {bar chart or list}
  Nivel 1: {count} usuarios
  Nivel 2: {count} usuarios
  ...
  ```
- Keyboard: "ğŸ”™ MÃ©tricas" -> admin:economy_stats

**Error Handling:**
- Try-except around DB operations
- Show error message if stats fail to load
- Log errors with context
  </action>
  <verify>grep -q "admin:economy_stats" bot/handlers/admin/economy_stats.py && grep -q "EconomyStats" bot/services/stats.py</verify>
  <done>Economy stats handler exists with main metrics display and top users view</done>
</task>

<task type="auto">
  <name>Task 3: Register Router and Add Menu Button</name>
  <files>
    - bot/handlers/admin/__init__.py
    - bot/handlers/admin/main.py
  </files>
  <action>
1. Update bot/handlers/admin/__init__.py:
   - Import economy_stats router
   - Include it in admin_router

2. Update bot/handlers/admin/main.py:
   - Add "ğŸ“Š MÃ©tricas EconomÃ­a" button to config menu or main menu
   - Callback data: "admin:economy_stats"
   - Position appropriately
  </action>
  <verify>grep -q "economy_stats" bot/handlers/admin/__init__.py && grep -q "admin:economy_stats" bot/handlers/admin/main.py</verify>
  <done>Economy stats router registered and menu button added</done>
</task>

</tasks>

<verification>
- Economy stats service methods calculate all required metrics
- Economy stats handler displays formatted metrics
- Top users view shows earners, spenders, and balances
- Level distribution shows user distribution
- Menu integration works correctly
- All operations use Lucien's voice (ğŸ©)
</verification>

<success_criteria>
- Admin can view economy metrics dashboard
- Metrics include total besitos in circulation
- Metrics include active users (7/30 days)
- Metrics include transaction counts by period
- Top users (earners, spenders, balances) viewable
- Level distribution viewable
- All metrics cached for performance
- Lucien's voice used for all messages
</success_criteria>

<output>
After completion, create `.planning/phases/24-admin-configuration/24-04-SUMMARY.md`
</output>

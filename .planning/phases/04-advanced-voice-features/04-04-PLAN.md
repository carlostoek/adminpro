---
phase: 04-advanced-voice-features
plan: 04
type: execute
wave: 1
depends_on: [04-01]
files_modified:
  - bot/services/container.py
  - bot/services/message/__init__.py
  - bot/services/message/user_start.py
  - bot/services/message/admin_vip.py
  - bot/services/message/admin_main.py
  - bot/services/message/admin_free.py
  - bot/services/message/user_flows.py
  - bot/handlers/user/start.py
  - bot/handlers/admin/vip.py
  - bot/handlers/admin/main.py
  - bot/handlers/admin/free.py
  - bot/handlers/user/free_flow.py
autonomous: true
gap_closure: true
must_haves:
  truths:
    - "Message variations avoid repetition within single session (context-aware selection)"
    - "SessionMessageHistory is instantiated and accessible via ServiceContainer"
    - "Provider methods accept optional user_id and pass session context to _choose_variant"
    - "Handlers pass user_id and session_history to provider calls"
  artifacts:
    - path: "bot/services/container.py"
      provides: "session_history property with lazy loading"
      contains: "@property def session_history"
    - path: "bot/services/message/user_start.py"
      provides: "user_id parameter in greeting() method"
      contains: "def greeting(self, user_name: str, user_id: Optional[int] = None, ...)"
    - path: "bot/services/message/base.py"
      provides: "_choose_variant with session-aware selection"
      pattern: "session_history.add_entry"
    - path: "bot/handlers/user/start.py"
      provides: "Handler passes session context to providers"
      contains: "session_history = container.session_history"
  key_links:
    - from: "ServiceContainer.session_history"
      to: "SessionMessageHistory"
      via: "lazy loading property"
    - from: "Handler"
      to: "MessageProvider"
      via: "container.message.{namespace}.{method}(user_id=user.id, session_history=session_history, ...)"
    - from: "MessageProvider"
      to: "BaseMessageProvider._choose_variant"
      via: "self._choose_variant(variants, weights, user_id, method_name, session_history)"
---

<objective>
Integrate SessionMessageHistory into the message generation flow to enable context-aware variation selection that prevents message repetition fatigue.

**Purpose:** Close the critical gap identified in VERIFICATION.md - the session tracking infrastructure (SessionMessageHistory service + enhanced _choose_variant) is fully implemented but not integrated into the actual message generation flow. Providers call _choose_variant without session context parameters, and handlers don't pass user_id/session_history to provider calls, so the session-aware code path never executes.

**Root Cause:** Two-layer integration gap:
1. Message providers (user_start.py, admin_vip.py, etc.) call `self._choose_variant(variants, weights)` without the optional `user_id`, `method_name`, `session_history` parameters
2. Handlers (start.py, vip.py, etc.) call provider methods without passing `user_id` or `session_history`

Since these default to `None`, the backward-compatible random selection path executes (base.py lines 139-146), and the session-aware code path (lines 148-181) never runs.

**Impact Without This Plan:**
- Message variations do NOT avoid repetition within single session
- Success criterion 1 from ROADMAP is NOT achieved
- The primary value proposition of Plan 04-01 (preventing "Buenos dias" 3x in a row) is not realized

**Output:**
- SessionMessageHistory integrated into ServiceContainer with lazy loading
- All message provider methods accept optional `user_id` and `session_history` parameters
- All handlers that call providers pass `user_id` and `session_history`
- Session context flows through: handler -> provider -> _choose_variant
- Message variations exclude last 2 variants seen by user
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/phases/04-advanced-voice-features/04-VERIFICATION.md
@.planning/phases/04-advanced-voice-features/04-01-SUMMARY.md
@.planning/phases/04-advanced-voice-features/04-02-PLAN.md

# Gap Summary from VERIFICATION.md
gap:
  truth: "Message variations avoid repetition within single session (context-aware selection)"
  status: partial
  reason: "SessionMessageHistory service exists with full implementation and BaseMessageProvider._choose_variant accepts session context, but message providers (user_start.py, admin_vip.py, etc.) do NOT pass session context when calling _choose_variant, and handlers do NOT pass user_id/session_history to provider calls. The infrastructure exists but is not wired into the actual message generation flow."
  missing:
    - "SessionMessageHistory instantiation in LucienVoiceService or ServiceContainer"
    - "Provider methods accepting user_id, method_name, session_history parameters"
    - "Provider methods passing user_id and method_name to _choose_variant calls"
    - "Handlers passing user_id and session_history to provider method calls"
    - "Integration of session_history parameter in provider _choose_variant invocations"
    - "Session history lifecycle management (when to create, pass through)"

# Session History Infrastructure (already built)
@bot/services/message/session_history.py
@bot/services/message/base.py

# Current Provider Patterns (need modification)
@bot/services/message/user_start.py
@bot/services/message/admin_vip.py
@bot/services/message/admin_main.py
@bot/services/message/admin_free.py
@bot/services/message/user_flows.py

# Service Container (needs session_history property)
@bot/services/container.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add SessionMessageHistory to ServiceContainer</name>
  <files>bot/services/container.py</files>
  <action>
Add lazy-loaded `session_history` property to ServiceContainer:

1. Add `_session_history = None` to `__init__` (around line 54)
2. Add new property after `message` property:

```python
@property
def session_history(self):
    """
    Servicio de historial de sesiÃ³n para selecciÃ³n de variantes consciente del contexto.

    Se carga lazy (solo en primer acceso).

    Returns:
        SessionMessageHistory: Instancia del servicio de historial

    Usage:
        # Handlers pasan user_id a message providers
        text, kb = container.message.user.start.greeting(
            user_name="Juan",
            user_id=message.from_user.id,
            is_vip=True
        )
        # Provider internamente llama _choose_variant con session_history
    """
    if self._session_history is None:
        from bot.services.message.session_history import SessionMessageHistory
        logger.debug("ðŸ”„ Lazy loading: SessionMessageHistory")
        # TTL 5 minutos, mÃ¡ximo 5 entradas por usuario
        self._session_history = SessionMessageHistory(ttl_seconds=300, max_entries=5)

    return self._session_history
```

3. Update `get_loaded_services()` to include "session_history" check:

```python
if self._session_history is not None:
    loaded.append("session_history")
```

IMPORTANT: SessionMessageHistory is STATEFUL (stores user sessions), but this is acceptable because:
- Single instance shared across all providers
- In-memory only (no database)
- Lazy cleanup prevents memory leaks
- ~80 bytes per user is acceptable overhead
</action>
  <verify>
grep -n "def session_history" bot/services/container.py
grep -n "_session_history" bot/services/container.py
python -c "from bot.services.container import ServiceContainer; print('session_history property exists')"
</verify>
  <done>ServiceContainer has lazy-loaded session_history property returning SessionMessageHistory instance with 5-minute TTL and 5-entry max</done>
</task>

<task type="auto">
  <name>Task 2: Modify UserStartMessages to accept and use session context</name>
  <files>bot/services/message/user_start.py</files>
  <action>
Modify UserStartMessages to wire session context through to _choose_variant:

1. Update `greeting()` method signature (line 58):
```python
def greeting(
    self,
    user_name: str,
    user_id: Optional[int] = None,  # NEW: Accept user_id for session tracking
    is_admin: bool = False,
    is_vip: bool = False,
    vip_days_remaining: int = 0,
    session_history: Optional["SessionMessageHistory"] = None  # NEW: Accept session_history
) -> Tuple[str, Optional[InlineKeyboardMarkup]]:
```

2. Update `_choose_variant` call (line 137):
```python
# OLD: greeting = self._choose_variant(greeting_variants, greeting_weights)
# NEW:
greeting = self._choose_variant(
    greeting_variants,
    greeting_weights,
    user_id=user_id,
    method_name="greeting",
    session_history=session_history
)
```

3. Update `deep_link_activation_success()` method signature (line 177):
```python
def deep_link_activation_success(
    self,
    user_name: str,
    user_id: Optional[int] = None,  # NEW
    plan_name: str,
    duration_days: int,
    price: str,
    days_remaining: int,
    invite_link: str,
    session_history: Optional["SessionMessageHistory"] = None  # NEW
) -> Tuple[str, InlineKeyboardMarkup]:
```

4. Update `_choose_variant` call in deep_link_activation_success (line 228):
```python
# OLD: celebration = self._choose_variant(celebration_variants)
# NEW:
celebration = self._choose_variant(
    celebration_variants,
    user_id=user_id,
    method_name="deep_link_activation_success",
    session_history=session_history
)
```

5. Update method docstrings to document new parameters (add to Args section).

IMPORTANT: Optional parameters with None defaults maintain backward compatibility. Existing code that doesn't pass user_id/session_history will still work (falls back to random selection).
</action>
  <verify>
grep -n "user_id: Optional\[int\]" bot/services/message/user_start.py
grep -n "session_history: Optional" bot/services/message/user_start.py
grep -n 'method_name="greeting"' bot/services/message/user_start.py
python -c "from bot.services.message.user_start import UserStartMessages; import inspect; sig = inspect.signature(UserStartMessages.greeting); assert 'user_id' in sig.parameters and 'session_history' in sig.parameters"
</verify>
  <done>UserStartMessages.greeting() and deep_link_activation_success() accept user_id and session_history parameters, pass them to _choose_variant with method_name</done>
</task>

<task type="auto">
  <name>Task 3: Modify AdminVIPMessages to accept and use session context</name>
  <files>bot/services/message/admin_vip.py</files>
  <action>
Modify AdminVIPMessages to wire session context through to _choose_variant:

1. Read the file to identify ALL methods that call _choose_variant. Currently:
   - `vip_menu()` - line 84
   - `token_generation_success()` - search for _choose_variant
   - Any other methods with _choose_variant calls

2. For EACH method that calls _choose_variant:
   a. Add `user_id: Optional[int] = None` to method signature
   b. Add `session_history: Optional["SessionMessageHistory"] = None` to method signature
   c. Update the _choose_variant call:
      ```python
      # OLD: variant = self._choose_variant(variants, weights)
      # NEW:
      variant = self._choose_variant(
          variants,
          weights,
          user_id=user_id,
          method_name="<method_name>",  # Use actual method name
          session_history=session_history
      )
      ```

3. Update docstrings to document new parameters.

Key methods to modify (verify with file read):
- vip_menu() -> method_name="vip_menu"
- token_generation_success() -> method_name="token_generation_success"
- Any other _choose_variant calls in the file

Reference existing docstring pattern for consistency.
</action>
  <verify>
grep -n "_choose_variant" bot/services/message/admin_vip.py | wc -l  # Should show all calls
grep -A3 "_choose_variant" bot/services/message/admin_vip.py | grep -E "(user_id|method_name|session_history)"  # Should show context params
python -c "from bot.services.message.admin_vip import AdminVIPMessages; import inspect; methods = [m for m in dir(AdminVIPMessages) if not m.startswith('_')]; print(f'Checked {len(methods)} public methods')"
</verify>
  <done>All AdminVIPMessages methods that call _choose_variant now accept and pass user_id, method_name, and session_history parameters</done>
</task>

<task type="auto">
  <name>Task 4: Modify AdminMainMessages to accept and use session context</name>
  <files>bot/services/message/admin_main.py</files>
  <action>
Modify AdminMainMessages to wire session context through to _choose_variant:

1. Read the file to identify ALL methods that call _choose_variant (line 81 confirmed).

2. For EACH method that calls _choose_variant:
   a. Add `user_id: Optional[int] = None` to method signature
   b. Add `session_history: Optional["SessionMessageHistory"] = None` to method signature
   c. Update the _choose_variant call to include user_id, method_name, session_history

3. Update docstrings to document new parameters.

Key methods (verify with file read):
- admin_menu_greeting() -> method_name="admin_menu_greeting"
- Any other methods with _choose_variant calls

Maintain consistency with Task 2 and Task 3 patterns.
</action>
  <verify>
grep -n "_choose_variant" bot/services/message/admin_main.py
grep -B5 -A5 "method_name=" bot/services/message/admin_main.py
</verify>
  <done>All AdminMainMessages methods that call _choose_variant now accept and pass session context parameters</done>
</task>

<task type="auto">
  <name>Task 5: Modify AdminFreeMessages to accept and use session context</name>
  <files>bot/services/message/admin_free.py</files>
  <action>
Modify AdminFreeMessages to wire session context through to _choose_variant:

1. Read the file to identify ALL methods that call _choose_variant (line 62 confirmed).

2. For EACH method that calls _choose_variant:
   a. Add `user_id: Optional[int] = None` to method signature
   b. Add `session_history: Optional["SessionMessageHistory"] = None` to method signature
   c. Update the _choose_variant call to include user_id, method_name, session_history

3. Update docstrings to document new parameters.

Key methods (verify with file read):
- free_menu() -> method_name="free_menu"
- Any other methods with _choose_variant calls

Maintain consistency with Tasks 2-4 patterns.
</action>
  <verify>
grep -n "_choose_variant" bot/services/message/admin_free.py
grep -B5 -A5 "method_name=" bot/services/message/admin_free.py
</verify>
  <done>All AdminFreeMessages methods that call _choose_variant now accept and pass session context parameters</done>
</task>

<task type="auto">
  <name>Task 6: Modify UserFlowMessages to accept and use session context</name>
  <files>bot/services/message/user_flows.py</files>
  <action>
Modify UserFlowMessages to wire session context through to _choose_variant:

1. Read the file to identify ALL methods that call _choose_variant.

2. For EACH method that calls _choose_variant:
   a. Add `user_id: Optional[int] = None` to method signature
   b. Add `session_history: Optional["SessionMessageHistory"] = None` to method signature
   c. Update the _choose_variant call to include user_id, method_name, session_history

3. Update docstrings to document new parameters.

Key methods to check (verify with file read):
- free_request_success() -> method_name="free_request_success"
- duplicate_request() -> method_name="duplicate_request"
- Any other methods with _choose_variant calls

Note: User flow messages are often text-only returns (no keyboards), but still benefit from session-aware variation.
</action>
  <verify>
grep -n "_choose_variant" bot/services/message/user_flows.py
grep "method_name=" bot/services/message/user_flows.py
</verify>
  <done>All UserFlowMessages methods that call _choose_variant now accept and pass session context parameters</done>
</task>

<task type="auto">
  <name>Task 7: Update LucienVoiceService to expose session_history capability</name>
  <files>bot/services/message/__init__.py</files>
  <action>
Update LucienVoiceService to support passing session_history to providers:

1. LucienVoiceService itself remains stateless (no session_history stored as instance variable).

2. Add a convenience method to LucienVoiceService for creating provider calls with session context:

```python
def get_session_context(self, container: "ServiceContainer"):
    """
    Get session history instance from container for passing to providers.

    This is a convenience method for handlers to obtain session history
    and pass it to message provider methods.

    Args:
        container: ServiceContainer instance (has session_history property)

    Returns:
        SessionMessageHistory: Session history service instance

    Usage:
        # In handler
        from bot.services.container import ServiceContainer
        session_ctx = container.message.get_session_context(container)
        text, kb = container.message.user.start.greeting(
            user_name="Juan",
            user_id=user.id,
            session_history=session_ctx
        )
    """
    return container.session_history
```

3. Update LucienVoiceService docstring to document session-aware usage pattern:

```python
Session-Aware Messages (prevents repetition):
    session_history = container.message.get_session_context(container)
    text, kb = container.message.user.start.greeting(
        user_name="Juan",
        user_id=user.id,  # Required for session tracking
        session_history=session_history  # Enables context-aware selection
    )
```

IMPORTANT: This design keeps LucienVoiceService stateless while providing a clean API for handlers to access session_history through the existing ServiceContainer.
</action>
  <verify>
grep -n "get_session_context" bot/services/message/__init__.py
python -c "from bot.services.message import LucienVoiceService; from bot.services.container import ServiceContainer; print('LucienVoiceService has get_session_context:', hasattr(LucienVoiceService, 'get_session_context'))"
</verify>
  <done>LucienVoiceService.get_session_context() method provides convenient access to SessionMessageHistory for handlers</done>
</task>

<task type="auto">
  <name>Task 8: Write integration test for session-aware message generation</name>
  <files>tests/test_session_integration.py</files>
  <action>
Create comprehensive integration test demonstrating session-aware message generation:

1. Create `tests/test_session_integration.py`:

```python
"""
Integration tests for session-aware message generation.

Tests that message providers correctly wire session context through
to _choose_variant, enabling repetition prevention.
"""
import pytest
from bot.services.message.session_history import SessionMessageHistory
from bot.services.message import UserStartMessages, AdminVIPMessages
from datetime import datetime


class TestSessionAwareGeneration:
    """Test that providers use session context to prevent repetition."""

    def test_user_greeting_excludes_recent_variants(self):
        """UserStartMessages.greeting() should avoid repeating recent greetings."""
        history = SessionMessageHistory()
        provider = UserStartMessages()

        # Generate greeting 5 times for same user
        greetings = []
        for i in range(5):
            text, kb = provider.greeting(
                user_name="Carlos",
                user_id=12345,
                session_history=history
            )
            # Extract greeting from text (first line after emoji)
            greeting = text.split('ðŸŽ©')[1].split(',')[0].strip()
            greetings.append(greeting)

        # No greeting should repeat consecutively
        for i in range(len(greetings) - 1):
            assert greetings[i] != greetings[i+1], \
                f"Greeting repeated at position {i}: {greetings[i]}"

    def test_different_users_independent_sessions(self):
        """Different users should have independent session histories."""
        history = SessionMessageHistory()
        provider = UserStartMessages()

        # User 1 gets greeting
        text1, _ = provider.greeting(
            user_name="User1",
            user_id=11111,
            session_history=history
        )
        greeting1 = text1.split('ðŸŽ©')[1].split(',')[0].strip()

        # User 2 gets greeting (can be same as User 1's first)
        text2, _ = provider.greeting(
            user_name="User2",
            user_id=22222,
            session_history=history
        )
        greeting2 = text2.split('ðŸŽ©')[1].split(',')[0].strip()

        # Users are independent - no restriction on first greetings being same
        assert greeting1 or greeting2  # Both should have greetings

    def test_admin_vip_menu_session_aware(self):
        """AdminVIPMessages.vip_menu() should use session context when provided."""
        history = SessionMessageHistory()
        provider = AdminVIPMessages()

        menus = []
        for i in range(3):
            text, kb = provider.vip_menu(
                is_configured=True,
                user_id=54321,
                session_history=history
            )
            menus.append(text)

        # Verify no consecutive exact duplicates
        for i in range(len(menus) - 1):
            assert menus[i] != menus[i+1], \
                f"Menu text repeated at position {i}"

    def test_backward_compatibility_no_session_context(self):
        """Providers should work without session_history parameter (backward compat)."""
        provider = UserStartMessages()

        # Call without session_history (old API)
        text, kb = provider.greeting(
            user_name="Ana",
            is_vip=True,
            vip_days_remaining=15
        )

        # Should still work
        assert 'ðŸŽ©' in text
        assert 'Ana' in text
        assert 'cÃ­rculo exclusivo' in text.lower()
```

2. Run tests: `pytest tests/test_session_integration.py -v`

3. All tests should pass, demonstrating:
   - Session-aware selection prevents consecutive repetition
   - Different users have independent sessions
   - Admin messages also use session context
   - Backward compatibility maintained
</action>
  <verify>
pytest tests/test_session_integration.py -v
grep -l "test_user_greeting_excludes_recent_variants" tests/test_session_integration.py
</verify>
  <done>Integration test suite demonstrates session-aware message generation works correctly across all provider types while maintaining backward compatibility</done>
</task>

<task type="auto">
  <name>Task 9: Update handlers to pass session context to providers</name>
  <files>bot/handlers/user/start.py bot/handlers/admin/vip.py bot/handlers/admin/main.py bot/handlers/admin/free.py bot/handlers/user/free_flow.py</files>
  <action>
Update all handlers that call message providers to pass user_id and session_history:

**Pattern for each handler update:**

```python
# OLD PATTERN (no session context):
text, keyboard = container.message.user.start.greeting(
    user_name=user_name,
    is_vip=is_vip,
    vip_days_remaining=vip_days_remaining
)

# NEW PATTERN (with session context):
session_history = container.session_history
text, keyboard = container.message.user.start.greeting(
    user_name=user_name,
    user_id=user_id,  # ADD user_id parameter
    is_vip=is_vip,
    vip_days_remaining=vip_days_remaining,
    session_history=session_history  # ADD session_history parameter
)
```

**Specific handler updates:**

1. **bot/handlers/user/start.py** (3 calls to update):
   - Line 70: `cmd_start()` - greeting() call for admin users
     ```python
     session_history = container.session_history
     text, _ = container.message.user.start.greeting(
         user_name=user_name,
         user_id=user_id,  # ADD
         is_admin=True,
         is_vip=False,
         vip_days_remaining=0,
         session_history=session_history  # ADD
     )
     ```
   - Line 223: `_activate_token_from_deeplink()` - deep_link_activation_success() call
     ```python
     session_history = container.session_history
     success_text, keyboard = container.message.user.start.deep_link_activation_success(
         user_name=user_name,
         user_id=user.user_id,  # ADD
         plan_name=plan.name,
         duration_days=plan.duration_days,
         price=price_str,
         days_remaining=days_remaining,
         invite_link=invite_link.invite_link,
         session_history=session_history  # ADD
     )
     ```
   - Line 293: `_send_welcome_message()` - greeting() call for regular users
     ```python
     session_history = container.session_history
     text, keyboard = container.message.user.start.greeting(
         user_name=user_name,
         user_id=user_id,  # ADD
         is_admin=False,
         is_vip=is_vip,
         vip_days_remaining=vip_days_remaining,
         session_history=session_history  # ADD
     )
     ```

2. **bot/handlers/admin/vip.py** (4 calls to update):
   - Line 63: `callback_vip_menu()` - vip_menu() call
   - Line 107: `callback_vip_setup()` - setup_channel_prompt() call
   - Line 170: `process_vip_channel_forward()` - channel_configured_success() call
   - Line 329: `callback_generate_token_with_plan()` - token_generated() call

3. **bot/handlers/admin/main.py**:
   - Identify all message provider calls and add session context
   - Look for `container.message.admin.main.*` calls

4. **bot/handlers/admin/free.py**:
   - Identify all message provider calls and add session context
   - Look for `container.message.admin.free.*` calls

5. **bot/handlers/user/free_flow.py**:
   - Identify all message provider calls and add session context
   - Look for `container.message.user.flows.*` calls

**IMPORTANT:**
- `user_id` should come from `message.from_user.id` or `callback.from_user.id`
- `session_history = container.session_history` should be called once per handler function (not inside loops)
- For handlers that don't have user_id available (rare), omit the user_id parameter (backward compatible)

**Why this task is CRITICAL:**
Without updating handlers, the new optional parameters in provider methods will default to `None`, triggering the backward-compatible random selection path instead of the session-aware path. This is the "missing link" that actually activates the session-aware code path.
</action>
  <verify>
grep -n "session_history = container.session_history" bot/handlers/user/start.py
grep -n "user_id=user" bot/handlers/user/start.py
grep -n "session_history=" bot/handlers/admin/vip.py
python -c "
import ast
import os

# Check handlers pass user_id to providers
handler_files = [
    'bot/handlers/user/start.py',
    'bot/handlers/admin/vip.py'
]

for filepath in handler_files:
    with open(filepath, 'r') as f:
        content = f.read()
        if 'session_history = container.session_history' in content:
            print(f'âœ“ {filepath}: Session context pattern found')
        else:
            print(f'âœ— {filepath}: Missing session context pattern')
"
</verify>
  <done>All handlers that call message providers now pass user_id and session_history parameters, activating the session-aware code path</done>
</task>

</tasks>

<verification>

**Plan Scope Acknowledgement:** This plan contains 9 tasks. While this exceeds the typical 2-3 task target, 7 of the tasks (Tasks 2-8) follow a well-defined pattern of applying the same session context integration across different provider files and test infrastructure. This is repetitive application of a known pattern rather than 9 fundamentally different types of work.

## Overall Verification Steps

1. **ServiceContainer Integration:**
   ```bash
   python -c "from bot.services.container import ServiceContainer; sc = ServiceContainer(None, None); print('Has session_history:', hasattr(sc, 'session_history'))"
   ```

2. **Provider Method Signatures:**
   ```bash
   python -c "from bot.services.message import UserStartMessages, AdminVIPMessages, AdminMainMessages, AdminFreeMessages, UserFlowMessages; import inspect; providers = [UserStartMessages, AdminVIPMessages, AdminMainMessages, AdminFreeMessages, UserFlowMessages]; [print(f'{p.__name__}: user_id param exists') for p in providers if 'user_id' in inspect.signature(p().greeting if hasattr(p(), 'greeting') else p().vip_menu).parameters]"
   ```

3. **Session Flow End-to-End:**
   ```bash
   python -c "
   from bot.services.container import ServiceContainer
   from bot.services.message import UserStartMessages
   from bot.services.message.session_history import SessionMessageHistory

   # Simulate handler flow
   history = SessionMessageHistory()
   provider = UserStartMessages()

   # User 1: Generate 3 greetings
   for i in range(3):
       text, kb = provider.greeting('Test', user_id=123, session_history=history)
       print(f'Greeting {i+1}: {text.split()[1]}')

   # Check no repetition
   stats = history.get_stats()
   print(f'Session stats: {stats}')
   "
   ```

4. **Integration Tests:**
   ```bash
   pytest tests/test_session_integration.py -v
   pytest tests/test_session_history.py -v  # Ensure existing tests still pass
   ```

5. **Backward Compatibility:**
   ```bash
   python -c "
   from bot.services.message import UserStartMessages
   provider = UserStartMessages()
   # Old API (no user_id or session_history) should still work
   text, kb = provider.greeting('Juan', is_vip=True, vip_days_remaining=15)
   print('Backward compat:', 'ðŸŽ©' in text and 'Juan' in text)
   "
   ```

</verification>

<success_criteria>

## Phase 4 Gap Closure Success Criteria

1. **SessionMessageHistory Accessible:**
   - ServiceContainer.session_history property exists and returns SessionMessageHistory instance
   - Lazy-loaded (only instantiated on first access)
   - TTL 300 seconds, max_entries 5

2. **All Providers Accept Session Context:**
   - UserStartMessages.greeting() accepts user_id and session_history
   - UserStartMessages.deep_link_activation_success() accepts user_id and session_history
   - AdminVIPMessages.vip_menu() and all _choose_variant-calling methods accept session context
   - AdminMainMessages.admin_menu_greeting() and all _choose_variant-calling methods accept session context
   - AdminFreeMessages.free_menu() and all _choose_variant-calling methods accept session context
   - UserFlowMessages methods that call _choose_variant accept session context

3. **Session Context Flows Through:**
   - Providers call _choose_variant with user_id, method_name, and session_history
   - method_name matches the provider method name (e.g., "greeting", "vip_menu", "free_menu")
   - SessionMessageHistory.add_entry is called after each selection

4. **Repetition Prevention Works:**
   - Generating 5 messages for same user shows no consecutive duplicates
   - Different users have independent session histories
   - Integration tests demonstrate session-aware selection

5. **Backward Compatibility Maintained:**
   - Calling provider methods WITHOUT user_id/session_history still works
   - Falls back to random selection (old behavior)
   - All existing tests continue to pass

6. **Handlers Pass Session Context:**
   - bot/handlers/user/start.py: All 3 provider calls pass user_id and session_history
   - bot/handlers/admin/vip.py: All provider calls pass session context
   - bot/handlers/admin/main.py: All provider calls pass session context
   - bot/handlers/admin/free.py: All provider calls pass session context
   - bot/handlers/user/free_flow.py: All provider calls pass session context

7. **Observable Truth Achieved:**
   - "Message variations avoid repetition within single session (context-aware selection)" is now TRUE
   - Success criterion 1 from ROADMAP Phase 4 is achieved

</success_criteria>

<output>

After completion, create `.planning/phases/04-advanced-voice-features/04-04-SUMMARY.md` with:

1. Frontmatter tracking gap closure metadata
2. Summary of changes (ServiceContainer integration, provider modifications, handler updates)
3. Files modified: container.py, __init__.py, 6 provider files, 5 handler files
4. Integration test results
5. Verification that gap is closed (session-aware selection now active)
6. Updated ROADMAP entry for Phase 4

</output>

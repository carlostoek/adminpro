# Plan 04-01: Session Message History Service

**Wave:** 1 (Foundation - no dependencies)
**Autonomous:** Yes
**Files Modified:**
- `bot/services/message/session_history.py` (NEW)
- `bot/services/message/base.py` (MODIFY - enhance _choose_variant)
- `tests/test_session_history.py` (NEW)

**Depends On:** None (Phase 1 foundation complete)

---

## Summary

Build `SessionMessageHistory` service to track recent messages per user session and enable context-aware variation selection. This prevents "Buenos días" appearing 3 times in a row for the same user by excluding recently-seen variants from selection pool. Service uses in-memory storage (dict + deque) with TTL auto-cleanup, ~200 bytes per active user, no database dependency.

---

## Tasks

### Task 1: Create SessionHistoryEntry Dataclass

**File:** `bot/services/message/session_history.py`

**Requirements:**
- Use `@dataclass(slots=True)` for 40% memory reduction
- Fields: `method_name: str`, `variant_index: int`, `timestamp: float`
- Import `time` module for timestamps
- Import `typing` for type hints
- Import `collections.deque` for session storage

**Acceptance Criteria:**
- [x] Dataclass created with slots=True
- [x] Three fields defined with correct types
- [x] Default factory for timestamp using `time.time`
- [x] Docstring explaining purpose (lightweight record for tracking)

**Implementation Notes:**
```python
@dataclass(slots=True)
class SessionHistoryEntry:
    """Single message entry in session history.

    Lightweight record for tracking recent messages per user.
    Uses slots for 40% memory reduction vs regular dataclass.
    """
    method_name: str      # Which message method (e.g., "greeting")
    variant_index: int    # Which variant was selected (0, 1, 2)
    timestamp: float = field(default_factory=time.time)
```

---

### Task 2: Implement SessionMessageHistory Class

**File:** `bot/services/message/session_history.py`

**Requirements:**
- `__init__(self, ttl_seconds: int = 300, max_entries: int = 5)`
  - Store TTL and max_entries as instance variables
  - Initialize `_sessions: Dict[int, Deque[SessionHistoryEntry]] = {}`
- `add_entry(self, user_id: int, method_name: str, variant_index: int) -> None`
  - Lazy cleanup: Remove expired entries occasionally (~10% of calls)
  - Get or create user's session deque with maxlen=max_entries
  - Append new SessionHistoryEntry
  - Log debug message: `f"Session: user={user_id} method={method_name} variant={variant_index}"`
- `get_recent_variants(self, user_id: int, method_name: str, limit: int = 3) -> List[int]`
  - Return empty list if user_id not in _sessions
  - Iterate in reverse (most recent first)
  - Filter by method_name AND TTL (now - timestamp < ttl_seconds)
  - Stop when limit reached
  - Return list of variant indices (most recent first)
- `_cleanup_user(self, user_id: int) -> None`
  - Remove expired entries for specific user
  - Delete session if empty after cleanup
- `cleanup_all(self) -> int`
  - Remove expired entries from all sessions
  - Log info message with count removed
  - Return count of removed entries
- `get_stats(self) -> Dict[str, int]`
  - Return dict with keys: total_users, total_entries, active_entries
  - Count active entries (non-expired) separately

**Acceptance Criteria:**
- [x] All methods implemented with correct signatures
- [x] Lazy cleanup in add_entry (hash-based 10% probability)
- [x] get_recent_variants filters by both method_name AND TTL
- [x] cleanup_all returns accurate count
- [x] get_stats distinguishes total vs active entries
- [x] Logging at appropriate levels (debug for operations, info for cleanup)

**Implementation Notes:**
- Use `hash(user_id) % 10 == 0` for lazy cleanup trigger
- Use `deque(maxlen=max_entries)` for automatic size management
- TTL check: `now - entry.timestamp <= self._ttl_seconds`

---

### Task 3: Enhance BaseMessageProvider._choose_variant

**File:** `bot/services/message/base.py`

**Current Signature:**
```python
def _choose_variant(
    self,
    variants: list[str],
    weights: Optional[list[float]] = None
) -> str:
```

**New Signature:**
```python
def _choose_variant(
    self,
    variants: list[str],
    weights: Optional[list[float]] = None,
    user_id: Optional[int] = None,
    method_name: Optional[str] = None,
    session_history: Optional["SessionMessageHistory"] = None
) -> str:
```

**Requirements:**
1. Keep existing behavior when no session context:
   - If `session_history is None or user_id is None or method_name is None`:
     - Use existing random selection logic

2. Add session-aware selection when context provided:
   - Call `session_history.get_recent_variants(user_id, method_name, limit=2)`
   - Build `available_indices` excluding recent variants
   - If all variants would be excluded (available_indices empty), fall back to random
   - Select from available_indices using random.choice or random.choices with weights
   - Call `session_history.add_entry(user_id, method_name, selected_idx)`

**Acceptance Criteria:**
- [x] Backward compatible: works without session_history parameter
- [x] Excludes last 2 variants when session context provided
- [x] Falls back to random if all variants would be excluded
- [x] Adjusts weights when selecting from available subset
- [x] Records selection in session history
- [x] Updated docstring with Voice Rationale explaining session context

**Implementation Notes:**
```python
# Get recent variants to exclude
recent_indices = session_history.get_recent_variants(
    user_id, method_name, limit=2
)

# Build available indices (excluding recent)
available_indices = [
    i for i in range(len(variants))
    if i not in recent_indices
]

# If all variants would be excluded, include all
if not available_indices:
    available_indices = list(range(len(variants)))

# Select from available
if weights is None:
    selected_idx = random.choice(available_indices)
else:
    available_weights = [weights[i] for i in available_indices]
    selected_idx = random.choices(
        available_indices,
        weights=available_weights,
        k=1
    )[0]

# Record selection
session_history.add_entry(user_id, method_name, selected_idx)
```

---

### Task 4: Write Tests for SessionMessageHistory

**File:** `tests/test_session_history.py`

**Test Cases:**

1. **test_add_entry_stores_message**
   - Create history with TTL=300
   - Add entry for user 12345, method "greeting", variant 0
   - Verify entry stored in _sessions

2. **test_get_recent_variants_returns_empty_for_new_user**
   - Create history
   - Call get_recent_variants for non-existent user
   - Assert returns []

3. **test_get_recent_variants_filters_by_method**
   - Add 3 entries: greeting(0), success(1), greeting(2)
   - Call get_recent_variants for "greeting"
   - Assert returns [2, 0] (most recent first)

4. **test_get_recent_variants_respects_limit**
   - Add 5 entries for same method
   - Call get_recent_variants with limit=2
   - Assert returns only 2 most recent

5. **test_get_recent_variants_filters_expired**
   - Add entry, then advance time past TTL
   - Call get_recent_variants
   - Assert returns []

6. **test_cleanup_user_removes_expired**
   - Add expired and valid entries
   - Call cleanup_all
   - Assert expired removed, valid remain

7. **test_get_stats_counts_correctly**
   - Add multiple entries for multiple users
   - Call get_stats
   - Assert total_users, total_entries, active_entries accurate

8. **test_maxlen_enforced**
   - Create history with max_entries=3
   - Add 5 entries for same user
   - Assert user session has max 3 entries
   - Assert oldest entries removed

**Acceptance Criteria:**
- [x] All 8 test cases implemented
- [x] Tests use pytest fixtures (event_loop)
- [x] Tests verify both success and edge cases
- [x] Tests use semantic assertions (not exact string matching)

---

### Task 5: Integration Test with BaseMessageProvider

**File:** `tests/test_session_history.py` (append)

**Test Case:** `test_choose_variant_excludes_recent`

**Requirements:**
- Create SessionMessageHistory
- Create BaseMessageProvider instance
- Define 3 variants: ["Buenos días", "Buenas tardes", "Buenas noches"]
- Call _choose_variant with session context 3 times
- Verify no variant repeats consecutively
- Verify all 3 variants appear in distribution

**Acceptance Criteria:**
- [x] Integration test demonstrates session-aware selection
- [x] No variant appears more than 2 times in 10 calls
- [x] All variants appear at least once in 30 calls (weighted distribution)

---

## Verification Criteria

1. **SessionMemoryFootprint:** ~200 bytes per active user (validate with get_stats on 100 users)
2. **AddEntryPerformance:** O(1) amortized (deque append is constant time)
3. **GetRecentVariantsPerformance:** O(n) where n=5 (constant due to max_entries=5)
4. **TTLExpiry:** Entries older than 300 seconds not returned by get_recent_variants
5. **BackwardCompatibility:** Existing _choose_variant calls without session_context still work
6. **RepetitionPrevention:** In 30 message generations, no variant repeats more than 2 times consecutively

---

## Must Haves (Goal-Backward Verification)

**Goal:** Prevent message repetition fatigue by excluding recently-seen variants

1. **Must track last 5 messages per user:**
   - SessionMessageHistory._sessions dict user_id -> deque(maxlen=5)
   - Verified by test_maxlen_enforced

2. **Must exclude last 2 variants from selection:**
   - _choose_variant calls get_recent_variants(limit=2)
   - Verified by test_choose_variant_excludes_recent

3. **Must auto-expire entries after 5 minutes:**
   - TTL default 300 seconds
   - Verified by test_get_recent_variants_filters_expired

4. **Must be memory-efficient:**
   - @dataclass(slots=True) for 40% memory reduction
   - deque(maxlen=5) caps memory per user
   - Verified by test_get_stats_counts_correctly

5. **Must not break existing code:**
   - session_history parameter optional in _choose_variant
   - Verified by all existing tests still passing

---

## Implementation Notes

- **Memory Management:** Lazy cleanup in add_entry (10% probability) avoids background thread complexity
- **Session Loss:** Acceptable - this is convenience feature, not critical data
- **No Database:** In-memory only - avoids query latency and schema changes
- **Thread Safety:** Not required - bot is single-threaded async event loop
- **Logging:** Debug level for normal operations, Info for cleanup events

---

## Open Questions

1. **Q:** Should we increase exclusion window from 2 to 3 variants?
   **A:** Start with 2, measure user feedback in Phase 4 deployment

2. **Q:** Should we add weighted re-selection (recent variants less likely but possible)?
   **A:** No - current design excludes recent entirely, simpler and prevents repetition

3. **Q:** Should we persist sessions to database?
   **A:** No - in-memory sufficient, adds complexity without clear benefit

---

## Success Metrics

- **Session tracking active:** 100% of user-facing message methods opt-in to session context
- **Repetition reduction:** <5% of users report repetitive messages (vs ~15% baseline)
- **Memory overhead:** <50KB for 100 active users (500 bytes per user worst case)
- **Performance impact:** <1ms additional latency per message generation

---

**Status:** READY FOR EXECUTION
**Confidence:** HIGH (stdlib-only, proven pattern, no external dependencies)

---
phase: 20-reaction-system
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - bot/database/models.py
  - bot/database/enums.py
  - bot/services/reaction.py
  - alembic/versions/
autonomous: true

must_haves:
  truths:
    - UserReaction model exists with proper fields and indexes
    - ReactionService can track reactions with deduplication
    - ReactionService enforces rate limiting (30s cooldown)
    - ReactionService enforces daily reaction limits
    - ReactionService validates content access (VIP check)
  artifacts:
    - path: bot/database/models.py
      provides: UserReaction model
      contains: class UserReaction with user_id, content_id, emoji, created_at
    - path: bot/services/reaction.py
      provides: ReactionService with core business logic
      exports: [ReactionService]
    - path: alembic/versions/
      provides: Migration for user_reactions table
  key_links:
    - from: ReactionService
      to: WalletService
      via: container.wallet.earn_besitos()
      pattern: earn_besitos.*EARN_REACTION
---

<objective>
Create the database foundation and ReactionService for the reaction system. This includes the UserReaction model for tracking reactions and the core ReactionService with deduplication, rate limiting, and access validation.

Purpose: Enable tracking of user reactions to channel content with proper constraints (one per user/content/emoji, cooldown, daily limits, VIP access control).
Output: UserReaction model, ReactionService with core methods, Alembic migration.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@bot/database/models.py
@bot/database/enums.py
@bot/services/wallet.py
@bot/services/container.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create UserReaction model</name>
  <files>bot/database/models.py</files>
  <action>
Create the UserReaction model after the Transaction model:

```python
class UserReaction(Base):
    """
    Registro de reacciones de usuario a contenido de canales.

    Cada reacci√≥n:
    - Se vincula a un usuario y un mensaje de canal espec√≠fico
    - Usa un emoji espec√≠fico (no duplicados por usuario/contenido/emoji)
    - Registra timestamp para rate limiting y an√°lisis

    Attributes:
        id: ID √∫nico de la reacci√≥n
        user_id: ID del usuario que reaccion√≥
        content_id: ID del mensaje de canal al que se reaccion√≥
        emoji: Emoji usado para la reacci√≥n (ej: "‚ù§Ô∏è", "üî•")
        channel_id: ID del canal donde est√° el contenido
        created_at: Timestamp de la reacci√≥n

    Constraints:
        - Un usuario solo puede reaccionar una vez con cada emoji a un contenido
        - Rate limiting: 30 segundos entre reacciones del mismo usuario
        - L√≠mite diario: configurable (default 20 reacciones/d√≠a)
    """

    __tablename__ = "user_reactions"

    id = Column(Integer, primary_key=True, autoincrement=True)

    # User who reacted
    user_id = Column(
        BigInteger,
        ForeignKey("users.user_id", ondelete="CASCADE"),
        nullable=False,
        index=True
    )

    # Content being reacted to (Telegram message ID in channel)
    content_id = Column(BigInteger, nullable=False, index=True)
    channel_id = Column(String(50), nullable=False, index=True)

    # Reaction details
    emoji = Column(String(10), nullable=False)  # Emoji used

    # Timestamp
    created_at = Column(DateTime, nullable=False, default=datetime.utcnow, index=True)

    # Indexes for efficient queries
    __table_args__ = (
        # Unique constraint: one reaction per user/content/emoji combination
        Index('idx_user_content_emoji', 'user_id', 'content_id', 'emoji', unique=True),
        # Index for "user's recent reactions" queries (rate limiting)
        Index('idx_user_reactions_recent', 'user_id', 'created_at'),
        # Index for "reactions to content" queries
        Index('idx_content_reactions', 'channel_id', 'content_id', 'emoji'),
    )

    def __repr__(self) -> str:
        return (
            f"<UserReaction(id={self.id}, user_id={self.user_id}, "
            f"content_id={self.content_id}, emoji={self.emoji})>"
        )
```

Add to imports if needed. Ensure proper relationships are NOT added (keep it simple, no backref needed).
  </action>
  <verify>Grep for "class UserReaction" in bot/database/models.py</verify>
  <done>UserReaction model exists with all fields, indexes, and unique constraint on (user_id, content_id, emoji)</done>
</task>

<task type="auto">
  <name>Task 2: Create ReactionService foundation</name>
  <files>bot/services/reaction.py</files>
  <action>
Create bot/services/reaction.py with ReactionService class:

```python
"""
Reaction Service - Gesti√≥n de reacciones a contenido de canales.

Responsabilidades:
- Registrar reacciones de usuarios a contenido
- Prevenir reacciones duplicadas (mismo emoji al mismo contenido)
- Rate limiting (30 segundos entre reacciones)
- L√≠mite diario de reacciones por usuario
- Validar acceso al contenido (VIP solo para VIP)
- Otorgar besitos por reacciones v√°lidas

Patrones:
- Atomic operations para evitar race conditions
- Deduplication via unique constraint en DB
- Rate limiting basado en timestamp de √∫ltima reacci√≥n
"""
import logging
from datetime import datetime, timedelta
from typing import Dict, List, Optional, Tuple

from sqlalchemy import select, func, and_
from sqlalchemy.ext.asyncio import AsyncSession

from bot.database.models import UserReaction, BotConfig
from bot.database.enums import TransactionType, ContentCategory, UserRole

logger = logging.getLogger(__name__)


class ReactionService:
    """
    Service para gestionar reacciones a contenido de canales.

    Flujo t√≠pico:
    1. Usuario toca bot√≥n de reacci√≥n ‚Üí add_reaction()
    2. Validar acceso al contenido (VIP check)
    3. Validar rate limiting (30s cooldown)
    4. Validar l√≠mite diario
    5. Verificar duplicado
    6. Guardar reacci√≥n + otorgar besitos
    """

    # Configuraci√≥n de rate limiting y l√≠mites
    REACTION_COOLDOWN_SECONDS = 30

    def __init__(self, session: AsyncSession, wallet_service=None):
        """
        Inicializa el ReactionService.

        Args:
            session: Sesi√≥n de base de datos async
            wallet_service: WalletService opcional para otorgar besitos
        """
        self.session = session
        self.wallet = wallet_service
        self.logger = logging.getLogger(__name__)

    async def _get_config_value(self, key: str, default: int) -> int:
        """
        Obtiene un valor de configuraci√≥n de BotConfig.

        Args:
            key: Nombre del campo de configuraci√≥n
            default: Valor por defecto si no est√° configurado

        Returns:
            Valor configurado o default
        """
        result = await self.session.execute(
            select(getattr(BotConfig, key)).where(BotConfig.id == 1)
        )
        value = result.scalar_one_or_none()
        return value if value is not None else default

    async def _check_rate_limit(self, user_id: int) -> Tuple[bool, int]:
        """
        Verifica si el usuario est√° en cooldown entre reacciones.

        Args:
            user_id: ID del usuario

        Returns:
            Tuple[bool, int]: (puede_reaccionar, segundos_restantes)
            - True, 0: Puede reaccionar
            - False, N: Debe esperar N segundos
        """
        # Buscar √∫ltima reacci√≥n del usuario
        result = await self.session.execute(
            select(UserReaction.created_at)
            .where(UserReaction.user_id == user_id)
            .order_by(UserReaction.created_at.desc())
            .limit(1)
        )
        last_reaction = result.scalar_one_or_none()

        if last_reaction is None:
            # Nunca ha reaccionado, puede hacerlo
            return True, 0

        # Calcular tiempo transcurrido
        elapsed = (datetime.utcnow() - last_reaction).total_seconds()

        if elapsed < self.REACTION_COOLDOWN_SECONDS:
            remaining = int(self.REACTION_COOLDOWN_SECONDS - elapsed)
            return False, remaining

        return True, 0

    async def _check_daily_limit(self, user_id: int) -> Tuple[bool, int, int]:
        """
        Verifica si el usuario ha alcanzado el l√≠mite diario de reacciones.

        Args:
            user_id: ID del usuario

        Returns:
            Tuple[bool, int, int]: (puede_reaccionar, usadas_hoy, l√≠mite)
        """
        # Obtener l√≠mite configurado
        limit = await self._get_config_value('max_reactions_per_day', 20)

        # Contar reacciones de hoy
        today_start = datetime.utcnow().replace(hour=0, minute=0, second=0, microsecond=0)

        result = await self.session.execute(
            select(func.count(UserReaction.id))
            .where(
                UserReaction.user_id == user_id,
                UserReaction.created_at >= today_start
            )
        )
        count_today = result.scalar_one_or_none() or 0

        if count_today >= limit:
            return False, count_today, limit

        return True, count_today, limit

    async def _is_duplicate_reaction(
        self,
        user_id: int,
        content_id: int,
        emoji: str
    ) -> bool:
        """
        Verifica si el usuario ya reaccion√≥ con este emoji a este contenido.

        Args:
            user_id: ID del usuario
            content_id: ID del contenido
            emoji: Emoji de la reacci√≥n

        Returns:
            True si ya existe reacci√≥n id√©ntica
        """
        result = await self.session.execute(
            select(UserReaction.id)
            .where(
                UserReaction.user_id == user_id,
                UserReaction.content_id == content_id,
                UserReaction.emoji == emoji
            )
            .limit(1)
        )
        return result.scalar_one_or_none() is not None

    async def validate_content_access(
        self,
        user_id: int,
        channel_id: str,
        content_category: Optional[ContentCategory] = None
    ) -> Tuple[bool, str]:
        """
        Valida si el usuario tiene acceso al contenido para reaccionar.

        Args:
            user_id: ID del usuario
            channel_id: ID del canal
            content_category: Categor√≠a del contenido (VIP_CONTENT, FREE_CONTENT, etc)

        Returns:
            Tuple[bool, str]: (tiene_acceso, mensaje_error)
        """
        # Si es contenido VIP, verificar suscripci√≥n
        if content_category == ContentCategory.VIP_CONTENT:
            from bot.database.models import VIPSubscriber

            result = await self.session.execute(
                select(VIPSubscriber)
                .where(
                    VIPSubscriber.user_id == user_id,
                    VIPSubscriber.status == "active"
                )
            )
            subscriber = result.scalar_one_or_none()

            if subscriber is None or subscriber.is_expired():
                return False, "Este contenido es exclusivo para suscriptores VIP."

        # Contenido Free o sin categor√≠a espec√≠fica: permitir
        return True, ""

    async def add_reaction(
        self,
        user_id: int,
        content_id: int,
        channel_id: str,
        emoji: str,
        content_category: Optional[ContentCategory] = None
    ) -> Tuple[bool, str, Optional[Dict]]:
        """
        Agrega una reacci√≥n al contenido si pasa todas las validaciones.

        Args:
            user_id: ID del usuario que reacciona
            content_id: ID del mensaje de canal
            channel_id: ID del canal
            emoji: Emoji de la reacci√≥n
            content_category: Categor√≠a del contenido para validar acceso

        Returns:
            Tuple[bool, str, Optional[Dict]]:
                - bool: True si √©xito
                - str: Mensaje descriptivo (c√≥digo o texto)
                - Dict: Datos adicionales (besitos ganados, etc)

        C√≥digos de retorno:
            - "success": Reacci√≥n registrada, besitos otorgados
            - "duplicate": Ya reaccion√≥ con este emoji a este contenido
            - "rate_limited": Debe esperar N segundos
            - "daily_limit_reached": L√≠mite diario alcanzado
            - "no_access": No tiene acceso al contenido (VIP)
        """
        # 1. Validar acceso al contenido
        has_access, error_msg = await self.validate_content_access(
            user_id, channel_id, content_category
        )
        if not has_access:
            return False, "no_access", {"error": error_msg}

        # 2. Validar rate limiting
        can_react, remaining = await self._check_rate_limit(user_id)
        if not can_react:
            return False, "rate_limited", {"seconds_remaining": remaining}

        # 3. Validar l√≠mite diario
        can_react_daily, used_today, limit = await self._check_daily_limit(user_id)
        if not can_react_daily:
            return False, "daily_limit_reached", {"used": used_today, "limit": limit}

        # 4. Verificar duplicado
        if await self._is_duplicate_reaction(user_id, content_id, emoji):
            return False, "duplicate", None

        try:
            # 5. Crear reacci√≥n
            reaction = UserReaction(
                user_id=user_id,
                content_id=content_id,
                channel_id=channel_id,
                emoji=emoji
            )
            self.session.add(reaction)
            await self.session.flush()

            # 6. Otorgar besitos si wallet service est√° disponible
            besitos_earned = 0
            if self.wallet:
                besitos_per_reaction = await self._get_config_value(
                    'besitos_per_reaction', 5
                )

                success, msg, tx = await self.wallet.earn_besitos(
                    user_id=user_id,
                    amount=besitos_per_reaction,
                    transaction_type=TransactionType.EARN_REACTION,
                    reason=f"Reacci√≥n {emoji} al contenido {content_id}",
                    metadata={
                        "content_id": content_id,
                        "channel_id": channel_id,
                        "emoji": emoji
                    }
                )

                if success:
                    besitos_earned = besitos_per_reaction
                    self.logger.info(
                        f"‚úÖ User {user_id} earned {besitos_earned} besitos for reaction {emoji}"
                    )

            return True, "success", {
                "besitos_earned": besitos_earned,
                "reactions_today": used_today + 1,
                "daily_limit": limit
            }

        except Exception as e:
            self.logger.error(f"‚ùå Error adding reaction for user {user_id}: {e}")
            return False, "error", {"error": str(e)}

    async def get_content_reactions(
        self,
        content_id: int,
        channel_id: str
    ) -> Dict[str, int]:
        """
        Obtiene el conteo de reacciones por emoji para un contenido.

        Args:
            content_id: ID del contenido
            channel_id: ID del canal

        Returns:
            Dict[emoji, count]: Conteo de cada emoji
        """
        result = await self.session.execute(
            select(UserReaction.emoji, func.count(UserReaction.id))
            .where(
                UserReaction.content_id == content_id,
                UserReaction.channel_id == channel_id
            )
            .group_by(UserReaction.emoji)
        )

        counts = {}
        for row in result.all():
            counts[row[0]] = row[1]

        return counts

    async def get_user_reactions_today(self, user_id: int) -> Tuple[int, int]:
        """
        Obtiene estad√≠sticas de reacciones del usuario hoy.

        Args:
            user_id: ID del usuario

        Returns:
            Tuple[int, int]: (reacciones_hoy, l√≠mite_diario)
        """
        limit = await self._get_config_value('max_reactions_per_day', 20)

        today_start = datetime.utcnow().replace(hour=0, minute=0, second=0, microsecond=0)

        result = await self.session.execute(
            select(func.count(UserReaction.id))
            .where(
                UserReaction.user_id == user_id,
                UserReaction.created_at >= today_start
            )
        )
        count_today = result.scalar_one_or_none() or 0

        return count_today, limit
```
  </action>
  <verify>File bot/services/reaction.py exists and contains ReactionService class with all core methods</verify>
  <done>ReactionService exists with _check_rate_limit, _check_daily_limit, _is_duplicate_reaction, validate_content_access, add_reaction, get_content_reactions, get_user_reactions_today methods</done>
</task>

<task type="auto">
  <name>Task 3: Export ReactionService and create migration</name>
  <files>
    bot/services/__init__.py
    alembic/versions/
  </files>
  <action>
1. Add to bot/services/__init__.py:
   - Import ReactionService
   - Add to __all__ list

2. Create Alembic migration for user_reactions table:
   ```bash
   alembic revision -m "add user_reactions table for reaction system"
   ```

   Migration should create table with:
   - id (PK)
   - user_id (FK to users, CASCADE)
   - content_id (BigInteger)
   - channel_id (String 50)
   - emoji (String 10)
   - created_at (DateTime)
   - All indexes defined in model

   Verify migration runs: alembic upgrade head, then downgrade, then upgrade again.
  </action>
  <verify>
   - Grep for "ReactionService" in bot/services/__init__.py
   - alembic history shows new migration
   - alembic upgrade head runs without errors
  </verify>
  <done>ReactionService exported and migration created and tested</done>
</task>

</tasks>

<verification>
- UserReaction model has all required fields and indexes
- ReactionService has all validation methods (rate limit, daily limit, duplicate check, access check)
- add_reaction returns correct status codes (success, duplicate, rate_limited, daily_limit_reached, no_access)
- Migration runs without errors (test upgrade/downgrade/upgrade)
- ReactionService is exported from services package
</verification>

<success_criteria>
1. UserReaction model exists with unique constraint on (user_id, content_id, emoji)
2. ReactionService validates rate limiting (30s cooldown)
3. ReactionService validates daily reaction limit
4. ReactionService prevents duplicate reactions
5. ReactionService validates VIP content access
6. Migration created and tested
</success_criteria>

<output>
After completion, create `.planning/phases/20-reaction-system/20-01-SUMMARY.md`
</output>

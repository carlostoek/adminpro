---
phase: 20-reaction-system
plan: 02
type: execute
wave: 2
depends_on: ["20-01-PLAN.md"]
files_modified:
  - bot/services/container.py
  - bot/utils/keyboards.py
autonomous: true

must_haves:
  truths:
    - ServiceContainer exposes reaction property with lazy loading
    - ReactionService is instantiated with wallet_service injected
    - Keyboard utility can generate reaction inline keyboards
    - Reaction buttons have proper callback data format
  artifacts:
    - path: bot/services/container.py
      provides: reaction property in ServiceContainer
      contains: @property def reaction(self) -> ReactionService
    - path: bot/utils/keyboards.py
      provides: get_reaction_keyboard function
      exports: [get_reaction_keyboard]
  key_links:
    - from: ServiceContainer.reaction
      to: WalletService
      via: self._wallet_service passed to ReactionService
      pattern: ReactionService.*self._session.*wallet_service
---

<objective>
Integrate ReactionService into the ServiceContainer and create keyboard utilities for reaction buttons. This enables the reaction system to be accessed throughout the bot and provides the inline keyboard generation for channel messages.

Purpose: Make ReactionService available via dependency injection and create reusable keyboard components for reaction buttons.
Output: Updated ServiceContainer with reaction property, keyboard utility for reaction buttons.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@bot/services/container.py
@bot/utils/keyboards.py
@bot/services/reaction.py (from 20-01)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add ReactionService to ServiceContainer</name>
  <files>bot/services/container.py</files>
  <action>
Update bot/services/container.py to add ReactionService:

1. In __init__, add:
   ```python
   self._reaction_service = None
   ```

2. Add the reaction property (after wallet property for logical grouping):
   ```python
   # ===== REACTION SERVICE =====

   @property
   def reaction(self):
       """
       Service de gesti贸n de reacciones a contenido.

       Se carga lazy (solo en primer acceso).

       Returns:
           ReactionService: Instancia del service

       Usage:
           # Add reaction
           success, code, data = await container.reaction.add_reaction(
               user_id=123,
               content_id=456,
               channel_id="-1001234567890",
               emoji="わ",
               content_category=ContentCategory.VIP_CONTENT
           )

           # Get content reaction counts
           counts = await container.reaction.get_content_reactions(
               content_id=456,
               channel_id="-1001234567890"
           )
       """
       if self._reaction_service is None:
           from bot.services.reaction import ReactionService
           logger.debug(" Lazy loading: ReactionService")
           # Inject wallet service for besitos earning
           self._reaction_service = ReactionService(
               self._session,
               wallet_service=self.wallet
           )

       return self._reaction_service
   ```

3. Update get_loaded_services() to include "reaction":
   ```python
   if self._reaction_service is not None:
       loaded.append("reaction")
   ```

4. Update preload_critical_services() if needed (reaction is not critical, don't preload).
  </action>
  <verify>Grep for "_reaction_service" and "def reaction" in bot/services/container.py</verify>
  <done>ServiceContainer has reaction property with lazy loading, wallet_service injection, and appears in get_loaded_services()</done>
</task>

<task type="auto">
  <name>Task 2: Create reaction keyboard utility</name>
  <files>bot/utils/keyboards.py</files>
  <action>
Update bot/utils/keyboards.py to add reaction keyboard generation:

1. Add import at top if not exists:
   ```python
   from typing import List, Optional
   from aiogram.types import InlineKeyboardButton, InlineKeyboardMarkup
   ```

2. Add the function (after existing keyboard functions):
   ```python
   def get_reaction_keyboard(
       content_id: int,
       channel_id: str,
       reactions: Optional[List[str]] = None,
       current_counts: Optional[dict] = None
   ) -> InlineKeyboardMarkup:
       """
       Genera teclado inline con botones de reacci贸n.

       Args:
           content_id: ID del mensaje/contenido
           channel_id: ID del canal
           reactions: Lista de emojis a mostrar (default: ["わ", "", "", ""])
           current_counts: Dict {emoji: count} con conteos actuales

       Returns:
           InlineKeyboardMarkup con botones de reacci贸n

       Example:
           keyboard = get_reaction_keyboard(
               content_id=message.message_id,
               channel_id="-1001234567890",
               current_counts={"わ": 5, "": 3}
           )
       """
       if reactions is None:
           reactions = ["わ", "", "", ""]

       if current_counts is None:
           current_counts = {}

       # Build buttons row
       buttons = []
       for emoji in reactions:
           count = current_counts.get(emoji, 0)
           # Format: "わ 5" or just "わ" if no reactions
           text = f"{emoji} {count}" if count > 0 else emoji

           # Callback data format: react:{channel_id}:{content_id}:{emoji}
           # Note: channel_id may contain -100 prefix, keep as-is
           callback_data = f"react:{channel_id}:{content_id}:{emoji}"

           # Telegram callback_data limit is 64 bytes
           # If too long, use hash or shorter format
           if len(callback_data.encode('utf-8')) > 64:
               # Fallback: use shortened format
               callback_data = f"r:{content_id}:{emoji}"

           buttons.append(
               InlineKeyboardButton(text=text, callback_data=callback_data)
           )

       # Arrange in rows of 4 buttons
       keyboard = []
       for i in range(0, len(buttons), 4):
           keyboard.append(buttons[i:i+4])

       return InlineKeyboardMarkup(inline_keyboard=keyboard)


   def get_reaction_keyboard_with_counts(
       content_id: int,
       channel_id: str,
       reactions: List[str],
       user_reactions: List[str]  # Emojis the user already reacted with
   ) -> InlineKeyboardMarkup:
       """
       Genera teclado mostrando qu茅 reacciones ya hizo el usuario.

       Args:
           content_id: ID del mensaje/contenido
           channel_id: ID del canal
           reactions: Lista de emojis disponibles
           user_reactions: Lista de emojis que el usuario ya us贸

       Returns:
           InlineKeyboardMarkup con indicaci贸n visual de reacciones del usuario
       """
       buttons = []
       for emoji in reactions:
           # Mark user reactions with checkmark
           if emoji in user_reactions:
               text = f"{emoji}"
           else:
               text = emoji

           callback_data = f"react:{channel_id}:{content_id}:{emoji}"

           # Handle length limit
           if len(callback_data.encode('utf-8')) > 64:
               callback_data = f"r:{content_id}:{emoji}"

           buttons.append(
               InlineKeyboardButton(text=text, callback_data=callback_data)
           )

       keyboard = []
       for i in range(0, len(buttons), 4):
           keyboard.append(buttons[i:i+4])

       return InlineKeyboardMarkup(inline_keyboard=keyboard)
   ```

3. Ensure functions are exported if __all__ exists.
  </action>
  <verify>Grep for "get_reaction_keyboard" in bot/utils/keyboards.py</verify>
  <done>Keyboard utility has get_reaction_keyboard and get_reaction_keyboard_with_counts functions with proper callback data format</done>
</task>

<task type="auto">
  <name>Task 3: Add ReactionService tests</name>
  <files>tests/services/test_reaction_service.py</files>
  <action>
Create tests/services/test_reaction_service.py with core tests:

```python
"""
Tests for ReactionService.

Validates:
- Rate limiting (30s cooldown)
- Daily limit enforcement
- Duplicate prevention
- Content access validation
- Besitos earning integration
"""
import pytest
from datetime import datetime, timedelta

from bot.services.reaction import ReactionService
from bot.database.models import UserReaction
from bot.database.enums import ContentCategory, TransactionType


@pytest.fixture
def reaction_service(db_session):
    """Fixture for ReactionService with mocked wallet."""
    return ReactionService(db_session, wallet_service=None)


class TestRateLimiting:
    """Test rate limiting functionality."""

    async def test_first_reaction_allowed(self, reaction_service, db_session):
        """First reaction should always be allowed."""
        can_react, remaining = await reaction_service._check_rate_limit(12345)

        assert can_react is True
        assert remaining == 0

    async def test_reaction_within_cooldown_blocked(
        self, reaction_service, db_session, test_user
    ):
        """Reaction within 30s should be blocked."""
        # Create recent reaction
        reaction = UserReaction(
            user_id=test_user.user_id,
            content_id=1,
            channel_id="-100123",
            emoji="わ",
            created_at=datetime.utcnow()
        )
        db_session.add(reaction)
        await db_session.commit()

        can_react, remaining = await reaction_service._check_rate_limit(test_user.user_id)

        assert can_react is False
        assert remaining > 0
        assert remaining <= 30

    async def test_reaction_after_cooldown_allowed(
        self, reaction_service, db_session, test_user
    ):
        """Reaction after 30s should be allowed."""
        # Create old reaction
        reaction = UserReaction(
            user_id=test_user.user_id,
            content_id=1,
            channel_id="-100123",
            emoji="わ",
            created_at=datetime.utcnow() - timedelta(seconds=31)
        )
        db_session.add(reaction)
        await db_session.commit()

        can_react, remaining = await reaction_service._check_rate_limit(test_user.user_id)

        assert can_react is True
        assert remaining == 0


class TestDailyLimit:
    """Test daily reaction limit."""

    async def test_daily_limit_not_reached(self, reaction_service, db_session, test_user):
        """User under limit should be allowed."""
        can_react, used, limit = await reaction_service._check_daily_limit(test_user.user_id)

        assert can_react is True
        assert used == 0
        assert limit == 20  # Default

    async def test_daily_limit_reached(self, reaction_service, db_session, test_user):
        """User at limit should be blocked."""
        # Create max reactions for today
        for i in range(20):
            reaction = UserReaction(
                user_id=test_user.user_id,
                content_id=i,
                channel_id="-100123",
                emoji="わ",
                created_at=datetime.utcnow()
            )
            db_session.add(reaction)
        await db_session.commit()

        can_react, used, limit = await reaction_service._check_daily_limit(test_user.user_id)

        assert can_react is False
        assert used == 20
        assert limit == 20


class TestDuplicateDetection:
    """Test duplicate reaction detection."""

    async def test_no_duplicate(self, reaction_service, db_session, test_user):
        """New reaction should not be duplicate."""
        is_dup = await reaction_service._is_duplicate_reaction(
            test_user.user_id, 1, "わ"
        )
        assert is_dup is False

    async def test_duplicate_detected(self, reaction_service, db_session, test_user):
        """Same emoji on same content should be duplicate."""
        # Create existing reaction
        reaction = UserReaction(
            user_id=test_user.user_id,
            content_id=1,
            channel_id="-100123",
            emoji="わ"
        )
        db_session.add(reaction)
        await db_session.commit()

        is_dup = await reaction_service._is_duplicate_reaction(
            test_user.user_id, 1, "わ"
        )
        assert is_dup is True

    async def test_different_emoji_not_duplicate(
        self, reaction_service, db_session, test_user
    ):
        """Different emoji on same content should not be duplicate."""
        # Create existing reaction
        reaction = UserReaction(
            user_id=test_user.user_id,
            content_id=1,
            channel_id="-100123",
            emoji="わ"
        )
        db_session.add(reaction)
        await db_session.commit()

        is_dup = await reaction_service._is_duplicate_reaction(
            test_user.user_id, 1, ""
        )
        assert is_dup is False


class TestContentAccess:
    """Test content access validation."""

    async def test_free_content_accessible(self, reaction_service, test_user):
        """Free content should be accessible to all."""
        has_access, error = await reaction_service.validate_content_access(
            test_user.user_id,
            "-100123",
            ContentCategory.FREE_CONTENT
        )
        assert has_access is True
        assert error == ""

    async def test_vip_content_blocked_for_non_vip(
        self, reaction_service, test_user
    ):
        """VIP content should be blocked for non-VIP users."""
        has_access, error = await reaction_service.validate_content_access(
            test_user.user_id,
            "-100123",
            ContentCategory.VIP_CONTENT
        )
        assert has_access is False
        assert "VIP" in error


class TestAddReaction:
    """Test full add_reaction flow."""

    async def test_successful_reaction(self, reaction_service, test_user):
        """Valid reaction should succeed."""
        success, code, data = await reaction_service.add_reaction(
            user_id=test_user.user_id,
            content_id=1,
            channel_id="-100123",
            emoji="わ",
            content_category=ContentCategory.FREE_CONTENT
        )

        assert success is True
        assert code == "success"
        assert data["reactions_today"] == 1

    async def test_duplicate_reaction_fails(self, reaction_service, db_session, test_user):
        """Duplicate reaction should fail."""
        # First reaction
        await reaction_service.add_reaction(
            user_id=test_user.user_id,
            content_id=1,
            channel_id="-100123",
            emoji="わ",
            content_category=ContentCategory.FREE_CONTENT
        )
        await db_session.commit()

        # Second reaction (duplicate)
        success, code, data = await reaction_service.add_reaction(
            user_id=test_user.user_id,
            content_id=1,
            channel_id="-100123",
            emoji="わ",
            content_category=ContentCategory.FREE_CONTENT
        )

        assert success is False
        assert code == "duplicate"

    async def test_rate_limited_reaction_fails(self, reaction_service, db_session, test_user):
        """Rate limited reaction should fail."""
        # First reaction
        await reaction_service.add_reaction(
            user_id=test_user.user_id,
            content_id=1,
            channel_id="-100123",
            emoji="わ",
            content_category=ContentCategory.FREE_CONTENT
        )
        await db_session.commit()

        # Immediate second reaction (rate limited)
        success, code, data = await reaction_service.add_reaction(
            user_id=test_user.user_id,
            content_id=2,
            channel_id="-100123",
            emoji="",
            content_category=ContentCategory.FREE_CONTENT
        )

        assert success is False
        assert code == "rate_limited"
        assert data["seconds_remaining"] > 0
```

Ensure test fixtures exist (test_user, db_session) from existing test infrastructure.
  </action>
  <verify>pytest tests/services/test_reaction_service.py -v runs successfully</verify>
  <done>ReactionService tests pass covering rate limiting, daily limits, duplicate detection, and content access</done>
</task>

</tasks>

<verification>
- ServiceContainer.reaction property returns ReactionService
- ReactionService is instantiated with wallet_service injected
- get_reaction_keyboard generates proper inline keyboards
- Callback data format is react:{channel_id}:{content_id}:{emoji}
- All tests pass
</verification>

<success_criteria>
1. ServiceContainer has reaction property with lazy loading
2. ReactionService receives wallet_service injection
3. get_reaction_keyboard utility exists and works
4. ReactionService tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/20-reaction-system/20-02-SUMMARY.md`
</output>

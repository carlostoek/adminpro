---
phase: 20-reaction-system
plan: 03
type: execute
wave: 3
depends_on: ["20-02-PLAN.md"]
files_modified:
  - bot/handlers/user/reactions.py
  - bot/handlers/user/__init__.py
  - bot/handlers/callbacks.py
autonomous: true

must_haves:
  truths:
    - Callback handler exists for reaction button presses
    - Handler validates user and shows appropriate feedback
    - Handler integrates with ReactionService for processing
    - Handler updates keyboard with reaction counts after successful reaction
    - Different feedback messages for each reaction result (success, duplicate, rate_limited, etc.)
  artifacts:
    - path: bot/handlers/user/reactions.py
      provides: Reaction callback handler
      exports: [register_reaction_handlers]
    - path: bot/handlers/callbacks.py
      provides: Callback router for reaction callbacks
      contains: pattern="react:" or prefix="r:"
  key_links:
    - from: Callback handler
      to: ReactionService
      via: container.reaction.add_reaction()
      pattern: add_reaction.*user_id.*content_id.*emoji
    - from: Callback handler
      to: Keyboard utility
      via: get_reaction_keyboard() or edit_message_reply_markup
      pattern: edit_message_reply_markup.*inline_keyboard
---

<objective>
Create callback handlers for reaction button presses. When users tap reaction buttons on channel messages, these handlers process the reaction, provide feedback, and update the keyboard display.

Purpose: Enable users to interact with reaction buttons and receive immediate feedback on their actions.
Output: Reaction callback handlers with proper feedback messages and keyboard updates.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@bot/services/reaction.py
@bot/utils/keyboards.py
@bot/handlers/callbacks.py (if exists)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create reaction callback handler</name>
  <files>bot/handlers/user/reactions.py</files>
  <action>
Create bot/handlers/user/reactions.py with callback handlers:

```python
"""
Reaction Handlers - Gesti√≥n de reacciones a contenido de canales.

Handlers:
- handle_reaction_callback: Procesa toques en botones de reacci√≥n
"""
import logging
from typing import Optional

from aiogram import Router, F, Bot
from aiogram.types import CallbackQuery
from aiogram.exceptions import TelegramBadRequest

from bot.services.container import ServiceContainer
from bot.database.enums import ContentCategory
from bot.utils.keyboards import get_reaction_keyboard

logger = logging.getLogger(__name__)
router = Router()


# Callback data format: react:{channel_id}:{content_id}:{emoji}
# Fallback format: r:{content_id}:{emoji}


@router.callback_query(F.data.startswith("react:"))
async def handle_reaction_callback(
    callback: CallbackQuery,
    container: ServiceContainer,
    bot: Bot
) -> None:
    """
    Procesa un toque en bot√≥n de reacci√≥n.

    Args:
        callback: Callback query del bot√≥n presionado
        container: ServiceContainer con servicios
        bot: Instancia del bot
    """
    # Parse callback data
    # Format: react:{channel_id}:{content_id}:{emoji}
    parts = callback.data.split(":")

    if len(parts) != 4:
        logger.warning(f"Invalid callback data format: {callback.data}")
        await callback.answer("Error: formato inv√°lido", show_alert=True)
        return

    _, channel_id, content_id_str, emoji = parts

    try:
        content_id = int(content_id_str)
    except ValueError:
        logger.warning(f"Invalid content_id in callback: {content_id_str}")
        await callback.answer("Error: contenido inv√°lido", show_alert=True)
        return

    user_id = callback.from_user.id

    logger.info(
        f"Reaction callback: user={user_id}, content={content_id}, "
        f"channel={channel_id}, emoji={emoji}"
    )

    # Determine content category based on channel
    # This requires knowing if the channel is VIP or Free
    content_category = await _get_content_category(container, channel_id)

    # Process reaction through service
    success, code, data = await container.reaction.add_reaction(
        user_id=user_id,
        content_id=content_id,
        channel_id=channel_id,
        emoji=emoji,
        content_category=content_category
    )

    # Handle result
    if success:
        await _handle_success(callback, data, emoji)
    else:
        await _handle_failure(callback, code, data)

    # Update keyboard with new counts (if message exists and we can edit)
    await _update_keyboard(callback, container, content_id, channel_id, user_id)


async def _get_content_category(
    container: ServiceContainer,
    channel_id: str
) -> Optional[ContentCategory]:
    """
    Determina la categor√≠a del contenido basado en el canal.

    Args:
        container: ServiceContainer
        channel_id: ID del canal

    Returns:
        ContentCategory o None
    """
    config = await container.config.get_config()

    if channel_id == config.vip_channel_id:
        return ContentCategory.VIP_CONTENT
    elif channel_id == config.free_channel_id:
        return ContentCategory.FREE_CONTENT

    return None


async def _handle_success(
    callback: CallbackQuery,
    data: dict,
    emoji: str
) -> None:
    """
    Maneja reacci√≥n exitosa.

    Args:
        callback: Callback query
        data: Datos de la reacci√≥n (besitos_earned, reactions_today, daily_limit)
        emoji: Emoji reaccionado
    """
    besitos = data.get("besitos_earned", 0)
    today = data.get("reactions_today", 0)
    limit = data.get("daily_limit", 20)

    if besitos > 0:
        message = f"{emoji} ¬°Reacci√≥n guardada! +{besitos} besitos ({today}/{limit})"
    else:
        message = f"{emoji} ¬°Reacci√≥n guardada! ({today}/{limit})"

    await callback.answer(message, show_alert=False)


async def _handle_failure(
    callback: CallbackQuery,
    code: str,
    data: dict
) -> None:
    """
    Maneja fallo en reacci√≥n.

    Args:
        callback: Callback query
        code: C√≥digo de error
        data: Datos adicionales del error
    """
    messages = {
        "duplicate": "Ya reaccionaste con este emoji üëÜ",
        "rate_limited": f"Espera {data.get('seconds_remaining', 30)}s entre reacciones ‚è±",
        "daily_limit_reached": f"L√≠mite diario alcanzado ({data.get('used', 20)}/{data.get('limit', 20)}) üìä",
        "no_access": data.get("error", "No tienes acceso a este contenido üîí"),
        "error": "Error al guardar reacci√≥n ‚ùå"
    }

    message = messages.get(code, "Error desconocido")
    await callback.answer(message, show_alert=True)


async def _update_keyboard(
    callback: CallbackQuery,
    container: ServiceContainer,
    content_id: int,
    channel_id: str,
    user_id: int
) -> None:
    """
    Actualiza el teclado con conteos actualizados.

    Args:
        callback: Callback query
        container: ServiceContainer
        content_id: ID del contenido
        channel_id: ID del canal
        user_id: ID del usuario (para marcar sus reacciones)
    """
    try:
        # Get updated reaction counts
        counts = await container.reaction.get_content_reactions(content_id, channel_id)

        # Get user's reactions to mark them
        # This would require a new method in ReactionService
        # For now, just show counts

        # Build new keyboard
        keyboard = get_reaction_keyboard(
            content_id=content_id,
            channel_id=channel_id,
            current_counts=counts
        )

        # Try to update the message
        # Note: This may fail if the message is too old or bot lacks permissions
        await callback.message.edit_reply_markup(reply_markup=keyboard)

    except TelegramBadRequest as e:
        # Message might be unchanged or too old
        if "message is not modified" in str(e).lower():
            pass  # OK, no change needed
        else:
            logger.debug(f"Could not update keyboard: {e}")
    except Exception as e:
        logger.error(f"Error updating reaction keyboard: {e}")


def register_reaction_handlers(dp) -> None:
    """
    Registra los handlers de reacciones en el dispatcher.

    Args:
        dp: Dispatcher de aiogram
    """
    dp.include_router(router)
    logger.info("‚úÖ Reaction handlers registered")
```

Add fallback handler for short format:

```python
@router.callback_query(F.data.startswith("r:"))
async def handle_short_reaction_callback(
    callback: CallbackQuery,
    container: ServiceContainer,
    bot: Bot
) -> None:
    """
    Procesa callback en formato corto.

    Format: r:{content_id}:{emoji}
    Channel must be determined from message context.
    """
    parts = callback.data.split(":")

    if len(parts) != 3:
        await callback.answer("Error: formato inv√°lido", show_alert=True)
        return

    _, content_id_str, emoji = parts

    try:
        content_id = int(content_id_str)
    except ValueError:
        await callback.answer("Error: contenido inv√°lido", show_alert=True)
        return

    # Get channel from message
    if callback.message and callback.message.chat:
        channel_id = str(callback.message.chat.id)
    else:
        await callback.answer("Error: no se pudo determinar el canal", show_alert=True)
        return

    # Delegate to main handler logic
    user_id = callback.from_user.id
    content_category = await _get_content_category(container, channel_id)

    success, code, data = await container.reaction.add_reaction(
        user_id=user_id,
        content_id=content_id,
        channel_id=channel_id,
        emoji=emoji,
        content_category=content_category
    )

    if success:
        await _handle_success(callback, data, emoji)
    else:
        await _handle_failure(callback, code, data)

    await _update_keyboard(callback, container, content_id, channel_id, user_id)
```
  </action>
  <verify>Grep for "handle_reaction_callback" and "register_reaction_handlers" in bot/handlers/user/reactions.py</verify>
  <done>Reaction callback handlers exist with proper parsing, validation, feedback messages, and keyboard updates</done>
</task>

<task type="auto">
  <name>Task 2: Register reaction handlers</name>
  <files>bot/handlers/user/__init__.py</files>
  <action>
Update bot/handlers/user/__init__.py to register reaction handlers:

1. Import the register function:
   ```python
   from bot.handlers.user.reactions import register_reaction_handlers
   ```

2. In the register function (or main handler registration), add:
   ```python
   register_reaction_handlers(dp)
   ```

3. Ensure the router or handlers are properly included in the main dispatcher.

If there's a different pattern for registering handlers (e.g., direct router inclusion), update accordingly.
  </action>
  <verify>Grep for "register_reaction_handlers" in bot/handlers/user/__init__.py</verify>
  <done>Reaction handlers are registered in the user handlers module</done>
</task>

<task type="auto">
  <name>Task 3: Add method to get user's reactions for content</name>
  <files>bot/services/reaction.py</files>
  <action>
Add method to ReactionService to get user's reactions for specific content (needed for marking user reactions in keyboard):

```python
async def get_user_reactions_for_content(
    self,
    user_id: int,
    content_id: int,
    channel_id: str
) -> List[str]:
    """
    Obtiene lista de emojis que el usuario us√≥ en un contenido.

    Args:
        user_id: ID del usuario
        content_id: ID del contenido
        channel_id: ID del canal

    Returns:
        Lista de emojis (ej: ["‚ù§Ô∏è", "üî•"])
    """
    result = await self.session.execute(
        select(UserReaction.emoji)
        .where(
            UserReaction.user_id == user_id,
            UserReaction.content_id == content_id,
            UserReaction.channel_id == channel_id
        )
    )

    return [row[0] for row in result.all()]
```

Update _update_keyboard in handler to use this method for marking user reactions.
  </action>
  <verify>Grep for "get_user_reactions_for_content" in bot/services/reaction.py</verify>
  <done>Method exists to get user's reactions for marking in keyboard</done>
</task>

<task type="auto">
  <name>Task 4: Create integration tests for reaction handlers</name>
  <files>tests/handlers/test_reaction_handlers.py</files>
  <action>
Create tests/handlers/test_reaction_handlers.py:

```python
"""
Integration tests for reaction handlers.

Tests the full flow from callback query to reaction recording.
"""
import pytest
from unittest.mock import AsyncMock, MagicMock

from bot.handlers.user.reactions import (
    handle_reaction_callback,
    _get_content_category,
    _handle_success,
    _handle_failure
)
from bot.database.enums import ContentCategory


@pytest.fixture
def mock_callback():
    """Create a mock callback query."""
    callback = MagicMock()
    callback.data = "react:-1001234567890:100:‚ù§Ô∏è"
    callback.from_user.id = 12345
    callback.answer = AsyncMock()
    callback.message = MagicMock()
    callback.message.edit_reply_markup = AsyncMock()
    callback.message.chat = MagicMock()
    callback.message.chat.id = -1001234567890
    return callback


@pytest.fixture
def mock_container():
    """Create a mock service container."""
    container = MagicMock()
    container.reaction.add_reaction = AsyncMock()
    container.reaction.get_content_reactions = AsyncMock(return_value={"‚ù§Ô∏è": 5})
    container.config.get_config = AsyncMock()
    return container


class TestHandleReactionCallback:
    """Test reaction callback handler."""

    async def test_successful_reaction(self, mock_callback, mock_container):
        """Handler should process successful reaction."""
        mock_container.reaction.add_reaction.return_value = (
            True, "success", {"besitos_earned": 5, "reactions_today": 3, "daily_limit": 20}
        )

        await handle_reaction_callback(mock_callback, mock_container, MagicMock())

        mock_container.reaction.add_reaction.assert_called_once()
        mock_callback.answer.assert_called_once()
        # Should contain besitos info
        call_args = mock_callback.answer.call_args
        assert "+5 besitos" in call_args[0][0] or "5 besitos" in call_args[0][0]

    async def test_duplicate_reaction(self, mock_callback, mock_container):
        """Handler should show duplicate message."""
        mock_container.reaction.add_reaction.return_value = (
            False, "duplicate", None
        )

        await handle_reaction_callback(mock_callback, mock_container, MagicMock())

        mock_callback.answer.assert_called_once()
        call_args = mock_callback.answer.call_args
        assert "Ya reaccionaste" in call_args[0][0]
        assert call_args[1].get("show_alert") is True

    async def test_rate_limited(self, mock_callback, mock_container):
        """Handler should show rate limit message."""
        mock_container.reaction.add_reaction.return_value = (
            False, "rate_limited", {"seconds_remaining": 15}
        )

        await handle_reaction_callback(mock_callback, mock_container, MagicMock())

        mock_callback.answer.assert_called_once()
        call_args = mock_callback.answer.call_args
        assert "15s" in call_args[0][0] or "Espera" in call_args[0][0]

    async def test_daily_limit_reached(self, mock_callback, mock_container):
        """Handler should show daily limit message."""
        mock_container.reaction.add_reaction.return_value = (
            False, "daily_limit_reached", {"used": 20, "limit": 20}
        )

        await handle_reaction_callback(mock_callback, mock_container, MagicMock())

        mock_callback.answer.assert_called_once()
        call_args = mock_callback.answer.call_args
        assert "L√≠mite" in call_args[0][0] or "20/20" in call_args[0][0]

    async def test_invalid_callback_format(self, mock_callback, mock_container):
        """Handler should handle invalid callback data."""
        mock_callback.data = "react:invalid"

        await handle_reaction_callback(mock_callback, mock_container, MagicMock())

        mock_callback.answer.assert_called_once()
        call_args = mock_callback.answer.call_args
        assert "formato inv√°lido" in call_args[0][0].lower()


class TestGetContentCategory:
    """Test content category detection."""

    async def test_vip_channel(self):
        """Should return VIP_CONTENT for VIP channel."""
        container = MagicMock()
        config = MagicMock()
        config.vip_channel_id = "-100123"
        config.free_channel_id = "-100456"
        container.config.get_config.return_value = config

        result = await _get_content_category(container, "-100123")

        assert result == ContentCategory.VIP_CONTENT

    async def test_free_channel(self):
        """Should return FREE_CONTENT for Free channel."""
        container = MagicMock()
        config = MagicMock()
        config.vip_channel_id = "-100123"
        config.free_channel_id = "-100456"
        container.config.get_config.return_value = config

        result = await _get_content_category(container, "-100456")

        assert result == ContentCategory.FREE_CONTENT

    async def test_unknown_channel(self):
        """Should return None for unknown channel."""
        container = MagicMock()
        config = MagicMock()
        config.vip_channel_id = "-100123"
        config.free_channel_id = "-100456"
        container.config.get_config.return_value = config

        result = await _get_content_category(container, "-100999")

        assert result is None
```
  </action>
  <verify>pytest tests/handlers/test_reaction_handlers.py -v runs successfully</verify>
  <done>Reaction handler tests pass covering success, duplicate, rate limit, and daily limit cases</done>
</task>

</tasks>

<verification>
- Reaction callback handlers exist and are registered
- Callback data parsing works for both formats (react: and r:)
- Feedback messages are appropriate for each result type
- Keyboard updates with new counts after successful reaction
- All tests pass
</verification>

<success_criteria>
1. Reaction callback handlers process button presses
2. Proper feedback shown for each result type (success, duplicate, rate_limited, daily_limit_reached, no_access)
3. Keyboard updates with reaction counts
4. Handlers are registered in the bot
5. All tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/20-reaction-system/20-03-SUMMARY.md`
</output>

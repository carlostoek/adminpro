---
phase: 20-reaction-system
plan: 04
type: execute
wave: 4
depends_on: ["20-03-PLAN.md"]
files_modified:
  - bot/services/channel.py
  - bot/handlers/admin/content.py
  - tests/services/test_reaction_integration.py
autonomous: true

must_haves:
  truths:
    - ChannelService can send messages with reaction keyboards attached
    - Admin content posting flow includes reaction buttons automatically
    - All 7 REACT requirements are satisfied
    - Integration tests verify end-to-end reaction flow
  artifacts:
    - path: bot/services/channel.py
      provides: send_to_channel with reaction_keyboard parameter
      contains: reply_markup=get_reaction_keyboard
    - path: tests/services/test_reaction_integration.py
      provides: End-to-end reaction system tests
      contains: test_reaction_flow or similar
  key_links:
    - from: ChannelService.send_to_channel
      to: get_reaction_keyboard
      via: reply_markup parameter
      pattern: get_reaction_keyboard.*content_id.*channel_id
---

<objective>
Integrate reaction system with channel message posting. When admin posts content to channels, reaction buttons are automatically attached. This completes the reaction system by connecting it to the content publishing flow.

Purpose: Ensure all channel messages have reaction buttons and verify the complete reaction system works end-to-end.
Output: Updated ChannelService with reaction keyboard support, integration tests verifying all REACT requirements.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@bot/services/channel.py
@bot/utils/keyboards.py
@bot/handlers/admin/content.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Update ChannelService to support reaction keyboards</name>
  <files>bot/services/channel.py</files>
  <action>
Update bot/services/channel.py to add reaction keyboard support to send_to_channel:

1. Add import:
   ```python
   from bot.utils.keyboards import get_reaction_keyboard
   ```

2. Update send_to_channel signature and implementation:
   ```python
   async def send_to_channel(
       self,
       channel_id: str,
       text: Optional[str] = None,
       photo: Optional[str] = None,
       video: Optional[str] = None,
       add_reactions: bool = True,  # NEW PARAMETER
       **kwargs
   ) -> Tuple[bool, str, Optional[Message]]:
       """
       Env√≠a un mensaje al canal especificado.

       Soporta:
       - Solo texto
       - Solo foto (con caption opcional)
       - Solo video (con caption opcional)
       - Botones de reacci√≥n inline (opcional, default True)

       Args:
           channel_id: ID del canal
           text: Texto del mensaje
           photo: File ID o URL de foto
           video: File ID o URL de video
           add_reactions: Si agregar botones de reacci√≥n (default True)
           **kwargs: Par√°metros adicionales (parse_mode, etc)

       Returns:
           Tuple[bool, str, Optional[Message]]:
               - bool: √©xito
               - str: mensaje descriptivo
               - Optional[Message]: mensaje enviado (si √©xito)
       """
       try:
           sent_message = None

           # Prepare reaction keyboard if enabled
           # Note: We need the message_id to create proper callback data
           # But we don't have it until after sending...
           # Solution: Send first, then edit to add keyboard

           # Determine tipo de mensaje
           if photo:
               sent_message = await self.bot.send_photo(
                   chat_id=channel_id,
                   photo=photo,
                   caption=text,
                   **kwargs
               )
           elif video:
               sent_message = await self.bot.send_video(
                   chat_id=channel_id,
                   video=video,
                   caption=text,
                   **kwargs
               )
           elif text:
               sent_message = await self.bot.send_message(
                   chat_id=channel_id,
                   text=text,
                   **kwargs
               )
           else:
               return False, "‚ùå Debes proporcionar texto, foto o video", None

           # Add reaction keyboard if requested
           if add_reactions and sent_message:
               keyboard = get_reaction_keyboard(
                   content_id=sent_message.message_id,
                   channel_id=channel_id
               )
               await sent_message.edit_reply_markup(reply_markup=keyboard)

           logger.info(f"‚úÖ Mensaje enviado al canal {channel_id}")
           return True, "‚úÖ Publicaci√≥n enviada correctamente", sent_message

       except TelegramForbiddenError:
           return False, "‚ùå Bot no tiene permiso para publicar en el canal", None
       except TelegramBadRequest as e:
           return False, f"‚ùå Error al enviar: {str(e)}", None
       except Exception as e:
           logger.error(f"Error al enviar mensaje a {channel_id}: {e}")
           return False, f"‚ùå Error inesperado: {str(e)}", None
   ```

3. Also update copy_to_channel to support reactions:
   ```python
   async def copy_to_channel_with_reactions(
       self,
       channel_id: str,
       from_chat_id: int,
       message_id: int
   ) -> Tuple[bool, str, Optional[Message]]:
       """
       Copia un mensaje a un canal y agrega botones de reacci√≥n.

       Args:
           channel_id: ID del canal destino
           from_chat_id: ID del chat origen
           message_id: ID del mensaje a copiar

       Returns:
           Tuple[bool, str, Optional[Message]]: (√©xito, mensaje, mensaje_enviado)
       """
       try:
           sent_message = await self.bot.copy_message(
               chat_id=channel_id,
               from_chat_id=from_chat_id,
               message_id=message_id
           )

           # Add reaction keyboard
           keyboard = get_reaction_keyboard(
               content_id=sent_message.message_id,
               channel_id=channel_id
           )
           await sent_message.edit_reply_markup(reply_markup=keyboard)

           logger.info(f"‚úÖ Mensaje copiado al canal {channel_id} con reacciones")
           return True, "‚úÖ Mensaje copiado con botones de reacci√≥n", sent_message

       except TelegramForbiddenError:
           return False, "‚ùå Bot no tiene permiso para publicar en el canal", None
       except Exception as e:
           logger.error(f"Error al copiar a {channel_id}: {e}")
           return False, f"‚ùå Error: {str(e)}", None
   ```
  </action>
  <verify>Grep for "add_reactions" and "get_reaction_keyboard" in bot/services/channel.py</verify>
  <done>ChannelService.send_to_channel has add_reactions parameter and attaches reaction keyboards</done>
</task>

<task type="auto">
  <name>Task 2: Update admin content handlers to use reactions</name>
  <files>bot/handlers/admin/content.py</files>
  <action>
Update admin content posting handlers to ensure reactions are enabled:

1. Find where content is posted to channels (likely in content.py or similar)

2. Ensure add_reactions=True is passed or default behavior includes reactions:
   ```python
   # When posting to VIP channel
   success, msg, sent = await container.channel.send_to_channel(
       channel_id=vip_channel_id,
       text=content_text,
       photo=photo_id,
       add_reactions=True  # Explicitly enable
   )

   # Or when copying
   success, msg, sent = await container.channel.copy_to_channel_with_reactions(
       channel_id=vip_channel_id,
       from_chat_id=admin_chat_id,
       message_id=message_id
   )
   ```

3. If there's a content publishing flow, ensure reactions are enabled by default.

4. Document that all channel content should have reactions enabled.
  </action>
  <verify>Grep for "add_reactions" or "copy_to_channel_with_reactions" in admin handlers</verify>
  <done>Admin content posting uses reaction-enabled methods</done>
</task>

<task type="auto">
  <name>Task 3: Create comprehensive integration tests</name>
  <files>tests/services/test_reaction_integration.py</files>
  <action>
Create tests/services/test_reaction_integration.py covering all REACT requirements:

```python
"""
Integration tests for Reaction System.

Validates all REACT requirements:
- REACT-01: Channel messages display inline reaction buttons
- REACT-02: User can react via inline buttons
- REACT-03: System deduplicates reactions
- REACT-04: Rate limiting (30s cooldown)
- REACT-05: User earns besitos for valid reactions
- REACT-06: Daily reaction limit per user
- REACT-07: Only accessible content can be reacted to
"""
import pytest
from datetime import datetime, timedelta
from unittest.mock import AsyncMock, MagicMock, patch

from bot.services.reaction import ReactionService
from bot.services.wallet import WalletService
from bot.database.models import UserReaction, UserGamificationProfile
from bot.database.enums import ContentCategory, TransactionType, UserRole


@pytest.fixture
async def wallet_service(db_session):
    """Create a real WalletService for integration testing."""
    return WalletService(db_session)


@pytest.fixture
async def reaction_service(db_session, wallet_service):
    """Create ReactionService with real WalletService."""
    return ReactionService(db_session, wallet_service=wallet_service)


class TestREACT01_InlineButtons:
    """REACT-01: Channel messages display inline reaction buttons."""

    async def test_reaction_keyboard_generated(self):
        """Keyboard utility should generate reaction buttons."""
        from bot.utils.keyboards import get_reaction_keyboard

        keyboard = get_reaction_keyboard(
            content_id=100,
            channel_id="-1001234567890"
        )

        assert keyboard is not None
        assert len(keyboard.inline_keyboard) > 0
        # Should have 4 reaction buttons in first row
        assert len(keyboard.inline_keyboard[0]) == 4

    async def test_reaction_keyboard_has_callback_data(self):
        """Each button should have proper callback data."""
        from bot.utils.keyboards import get_reaction_keyboard

        keyboard = get_reaction_keyboard(
            content_id=100,
            channel_id="-1001234567890"
        )

        button = keyboard.inline_keyboard[0][0]
        assert button.callback_data.startswith("react:")
        assert "100" in button.callback_data


class TestREACT02_UserCanReact:
    """REACT-02: User can react to content via inline buttons."""

    async def test_user_can_add_reaction(
        self, reaction_service, db_session, test_user
    ):
        """User should be able to add a reaction."""
        success, code, data = await reaction_service.add_reaction(
            user_id=test_user.user_id,
            content_id=100,
            channel_id="-100123",
            emoji="‚ù§Ô∏è",
            content_category=ContentCategory.FREE_CONTENT
        )

        assert success is True
        assert code == "success"

        # Verify reaction was saved
        result = await db_session.execute(
            select(UserReaction).where(
                UserReaction.user_id == test_user.user_id,
                UserReaction.content_id == 100,
                UserReaction.emoji == "‚ù§Ô∏è"
            )
        )
        reaction = result.scalar_one_or_none()
        assert reaction is not None


class TestREACT03_Deduplication:
    """REACT-03: System deduplicates reactions."""

    async def test_cannot_react_twice_with_same_emoji(
        self, reaction_service, db_session, test_user
    ):
        """User cannot react twice with same emoji to same content."""
        # First reaction
        success1, _, _ = await reaction_service.add_reaction(
            user_id=test_user.user_id,
            content_id=100,
            channel_id="-100123",
            emoji="‚ù§Ô∏è",
            content_category=ContentCategory.FREE_CONTENT
        )
        assert success1 is True
        await db_session.commit()

        # Second reaction (duplicate)
        success2, code, _ = await reaction_service.add_reaction(
            user_id=test_user.user_id,
            content_id=100,
            channel_id="-100123",
            emoji="‚ù§Ô∏è",
            content_category=ContentCategory.FREE_CONTENT
        )

        assert success2 is False
        assert code == "duplicate"

    async def test_can_react_with_different_emojis(
        self, reaction_service, db_session, test_user
    ):
        """User can react with different emojis to same content."""
        # First reaction
        await reaction_service.add_reaction(
            user_id=test_user.user_id,
            content_id=100,
            channel_id="-100123",
            emoji="‚ù§Ô∏è",
            content_category=ContentCategory.FREE_CONTENT
        )
        await db_session.commit()

        # Wait for rate limit
        import asyncio
        await asyncio.sleep(31)

        # Second reaction with different emoji
        success, code, _ = await reaction_service.add_reaction(
            user_id=test_user.user_id,
            content_id=100,
            channel_id="-100123",
            emoji="üî•",
            content_category=ContentCategory.FREE_CONTENT
        )

        assert success is True


class TestREACT04_RateLimiting:
    """REACT-04: Rate limiting prevents reaction spam."""

    async def test_rate_limit_enforced(
        self, reaction_service, db_session, test_user
    ):
        """User cannot react within 30 seconds of previous reaction."""
        # First reaction
        await reaction_service.add_reaction(
            user_id=test_user.user_id,
            content_id=100,
            channel_id="-100123",
            emoji="‚ù§Ô∏è",
            content_category=ContentCategory.FREE_CONTENT
        )
        await db_session.commit()

        # Immediate second reaction
        success, code, data = await reaction_service.add_reaction(
            user_id=test_user.user_id,
            content_id=101,
            channel_id="-100123",
            emoji="üî•",
            content_category=ContentCategory.FREE_CONTENT
        )

        assert success is False
        assert code == "rate_limited"
        assert data["seconds_remaining"] > 0


class TestREACT05_BesitosEarning:
    """REACT-05: User earns besitos for valid reactions."""

    async def test_reaction_earns_besitos(
        self, reaction_service, wallet_service, db_session, test_user
    ):
        """Valid reaction should earn besitos."""
        success, code, data = await reaction_service.add_reaction(
            user_id=test_user.user_id,
            content_id=100,
            channel_id="-100123",
            emoji="‚ù§Ô∏è",
            content_category=ContentCategory.FREE_CONTENT
        )

        assert success is True
        assert data["besitos_earned"] > 0

        # Verify balance increased
        balance = await wallet_service.get_balance(test_user.user_id)
        assert balance == data["besitos_earned"]

    async def test_reaction_creates_transaction(
        self, reaction_service, db_session, test_user
    ):
        """Reaction should create EARN_REACTION transaction."""
        from bot.database.models import Transaction

        await reaction_service.add_reaction(
            user_id=test_user.user_id,
            content_id=100,
            channel_id="-100123",
            emoji="‚ù§Ô∏è",
            content_category=ContentCategory.FREE_CONTENT
        )
        await db_session.commit()

        # Verify transaction exists
        result = await db_session.execute(
            select(Transaction).where(
                Transaction.user_id == test_user.user_id,
                Transaction.type == TransactionType.EARN_REACTION
            )
        )
        transaction = result.scalar_one_or_none()
        assert transaction is not None
        assert transaction.amount > 0


class TestREACT06_DailyLimit:
    """REACT-06: Daily reaction limit per user."""

    async def test_daily_limit_enforced(
        self, reaction_service, db_session, test_user
    ):
        """User cannot exceed daily reaction limit."""
        # Create reactions up to limit
        for i in range(20):
            reaction = UserReaction(
                user_id=test_user.user_id,
                content_id=i,
                channel_id="-100123",
                emoji="‚ù§Ô∏è",
                created_at=datetime.utcnow()
            )
            db_session.add(reaction)
        await db_session.commit()

        # Try to add one more
        success, code, data = await reaction_service.add_reaction(
            user_id=test_user.user_id,
            content_id=999,
            channel_id="-100123",
            emoji="üî•",
            content_category=ContentCategory.FREE_CONTENT
        )

        assert success is False
        assert code == "daily_limit_reached"


class TestREACT07_VIPAccessControl:
    """REACT-07: Only accessible content can be reacted to."""

    async def test_vip_content_blocked_for_free_user(
        self, reaction_service, test_user
    ):
        """Free user cannot react to VIP content."""
        success, code, data = await reaction_service.add_reaction(
            user_id=test_user.user_id,
            content_id=100,
            channel_id="-100123",
            emoji="‚ù§Ô∏è",
            content_category=ContentCategory.VIP_CONTENT
        )

        assert success is False
        assert code == "no_access"

    async def test_vip_content_allowed_for_vip_user(
        self, reaction_service, db_session, test_user
    ):
        """VIP user can react to VIP content."""
        # Make user VIP
        from bot.database.models import VIPSubscriber

        test_user.role = UserRole.VIP
        subscriber = VIPSubscriber(
            user_id=test_user.user_id,
            expiry_date=datetime.utcnow() + timedelta(days=30),
            status="active",
            token_id=1
        )
        db_session.add(subscriber)
        await db_session.commit()

        success, code, _ = await reaction_service.add_reaction(
            user_id=test_user.user_id,
            content_id=100,
            channel_id="-100123",
            emoji="‚ù§Ô∏è",
            content_category=ContentCategory.VIP_CONTENT
        )

        assert success is True


class TestEndToEndFlow:
    """End-to-end integration tests."""

    async def test_full_reaction_flow(
        self, reaction_service, wallet_service, db_session, test_user
    ):
        """
        Complete flow: User reacts, earns besitos, sees updated counts.
        """
        # 1. User adds reaction
        success, code, data = await reaction_service.add_reaction(
            user_id=test_user.user_id,
            content_id=100,
            channel_id="-100123",
            emoji="‚ù§Ô∏è",
            content_category=ContentCategory.FREE_CONTENT
        )

        assert success is True
        besitos_earned = data["besitos_earned"]

        # 2. Verify besitos earned
        balance = await wallet_service.get_balance(test_user.user_id)
        assert balance == besitos_earned

        # 3. Verify reaction counts
        counts = await reaction_service.get_content_reactions(100, "-100123")
        assert counts["‚ù§Ô∏è"] == 1

        # 4. Verify daily stats
        today_count, limit = await reaction_service.get_user_reactions_today(
            test_user.user_id
        )
        assert today_count == 1
        assert limit == 20
```
  </action>
  <verify>pytest tests/services/test_reaction_integration.py -v runs successfully</verify>
  <done>All 7 REACT requirements have passing integration tests</done>
</task>

<task type="auto">
  <name>Task 4: Create REACT requirements verification test</name>
  <files>tests/requirements/test_react_requirements.py</files>
  <action>
Create tests/requirements/test_react_requirements.py for explicit requirement verification:

```python
"""
REACT Requirements Verification Tests.

Each test maps directly to a REACT requirement from the roadmap.
Run with: pytest tests/requirements/test_react_requirements.py -v
"""
import pytest


class TestREACT01_InlineButtons:
    """REACT-01: Channel messages display inline reaction buttons (‚ù§Ô∏è, üî•, üíã, üòà)."""

    def test_react_01_keyboard_has_four_emojis(self):
        """Reaction keyboard must have 4 default emojis."""
        from bot.utils.keyboards import get_reaction_keyboard

        keyboard = get_reaction_keyboard(content_id=1, channel_id="-100123")
        buttons = keyboard.inline_keyboard[0]

        assert len(buttons) == 4
        # Check default emojis are present
        emojis = [btn.text for btn in buttons]
        assert "‚ù§Ô∏è" in emojis or "‚ù§Ô∏è " in " ".join(emojis)
        assert "üî•" in emojis or "üî• " in " ".join(emojis)

    def test_react_01_callback_data_format(self):
        """Reaction buttons must have proper callback data."""
        from bot.utils.keyboards import get_reaction_keyboard

        keyboard = get_reaction_keyboard(content_id=100, channel_id="-100123")
        button = keyboard.inline_keyboard[0][0]

        assert button.callback_data.startswith("react:")
        parts = button.callback_data.split(":")
        assert len(parts) == 4  # react, channel_id, content_id, emoji


class TestREACT02_UserCanReact:
    """REACT-02: User can react to content via inline buttons."""

    async def test_react_02_reaction_saved_to_db(self, db_session, test_user):
        """Tapping reaction button must save reaction to database."""
        from bot.services.reaction import ReactionService

        service = ReactionService(db_session, wallet_service=None)

        success, code, _ = await service.add_reaction(
            user_id=test_user.user_id,
            content_id=100,
            channel_id="-100123",
            emoji="‚ù§Ô∏è",
            content_category=None
        )

        assert success is True, f"Reaction failed with code: {code}"

        # Verify in database
        from bot.database.models import UserReaction
        from sqlalchemy import select

        result = await db_session.execute(
            select(UserReaction).where(
                UserReaction.user_id == test_user.user_id,
                UserReaction.content_id == 100
            )
        )
        assert result.scalar_one_or_none() is not None


class TestREACT03_Deduplication:
    """REACT-03: System deduplicates reactions (one per user per content per emoji)."""

    async def test_react_03_duplicate_blocked(self, db_session, test_user):
        """Same user cannot react twice with same emoji to same content."""
        from bot.services.reaction import ReactionService
        from bot.database.models import UserReaction

        service = ReactionService(db_session, wallet_service=None)

        # First reaction
        await service.add_reaction(
            user_id=test_user.user_id,
            content_id=100,
            channel_id="-100123",
            emoji="‚ù§Ô∏è"
        )
        await db_session.commit()

        # Second reaction (should fail)
        success, code, _ = await service.add_reaction(
            user_id=test_user.user_id,
            content_id=100,
            channel_id="-100123",
            emoji="‚ù§Ô∏è"
        )

        assert success is False
        assert code == "duplicate"


class TestREACT04_RateLimiting:
    """REACT-04: Rate limiting prevents reaction spam (30s cooldown)."""

    async def test_react_04_cooldown_enforced(self, db_session, test_user):
        """User must wait 30 seconds between reactions."""
        from bot.services.reaction import ReactionService
        from datetime import datetime

        service = ReactionService(db_session, wallet_service=None)

        # First reaction
        await service.add_reaction(
            user_id=test_user.user_id,
            content_id=100,
            channel_id="-100123",
            emoji="‚ù§Ô∏è"
        )
        await db_session.commit()

        # Immediate second reaction
        success, code, data = await service.add_reaction(
            user_id=test_user.user_id,
            content_id=101,
            channel_id="-100123",
            emoji="üî•"
        )

        assert success is False
        assert code == "rate_limited"
        assert data["seconds_remaining"] <= 30


class TestREACT05_BesitosEarning:
    """REACT-05: User earns besitos for valid reactions (configurable amount)."""

    async def test_react_05_besitos_earned(self, db_session, test_user):
        """Valid reaction must earn besitos."""
        from bot.services.reaction import ReactionService
        from bot.services.wallet import WalletService

        wallet = WalletService(db_session)
        service = ReactionService(db_session, wallet_service=wallet)

        success, code, data = await service.add_reaction(
            user_id=test_user.user_id,
            content_id=100,
            channel_id="-100123",
            emoji="‚ù§Ô∏è"
        )

        assert success is True
        assert data["besitos_earned"] > 0

        # Verify balance
        balance = await wallet.get_balance(test_user.user_id)
        assert balance == data["besitos_earned"]


class TestREACT06_DailyLimit:
    """REACT-06: Daily reaction limit per user (configurable)."""

    async def test_react_06_daily_limit_enforced(self, db_session, test_user):
        """User cannot exceed daily reaction limit."""
        from bot.services.reaction import ReactionService
        from bot.database.models import UserReaction
        from datetime import datetime

        service = ReactionService(db_session, wallet_service=None)

        # Create max reactions
        for i in range(20):
            reaction = UserReaction(
                user_id=test_user.user_id,
                content_id=i,
                channel_id="-100123",
                emoji="‚ù§Ô∏è",
                created_at=datetime.utcnow()
            )
            db_session.add(reaction)
        await db_session.commit()

        # Try to exceed limit
        success, code, data = await service.add_reaction(
            user_id=test_user.user_id,
            content_id=999,
            channel_id="-100123",
            emoji="üî•"
        )

        assert success is False
        assert code == "daily_limit_reached"


class TestREACT07_AccessControl:
    """REACT-07: Only accessible content can be reacted to (VIP for VIP content)."""

    async def test_react_07_vip_content_blocked(self, db_session, test_user):
        """Non-VIP user cannot react to VIP content."""
        from bot.services.reaction import ReactionService
        from bot.database.enums import ContentCategory

        service = ReactionService(db_session, wallet_service=None)

        success, code, _ = await service.add_reaction(
            user_id=test_user.user_id,
            content_id=100,
            channel_id="-100123",
            emoji="‚ù§Ô∏è",
            content_category=ContentCategory.VIP_CONTENT
        )

        assert success is False
        assert code == "no_access"
```
  </action>
  <verify>pytest tests/requirements/test_react_requirements.py -v runs successfully</verify>
  <done>All 7 REACT requirements have explicit verification tests</done>
</task>

</tasks>

<verification>
- ChannelService.send_to_channel attaches reaction keyboards by default
- Admin content posting includes reaction buttons
- All 7 REACT requirements have passing tests
- Integration tests verify end-to-end flow
</verification>

<success_criteria>
1. REACT-01: Channel messages display inline reaction buttons
2. REACT-02: User can react via inline buttons
3. REACT-03: System deduplicates reactions
4. REACT-04: Rate limiting prevents spam (30s cooldown)
5. REACT-05: User earns besitos for valid reactions
6. REACT-06: Daily reaction limit enforced
7. REACT-07: VIP content access control works
8. All integration tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/20-reaction-system/20-04-SUMMARY.md`
</output>

---
phase: 15-health-check-railway-prep
plan: 15-05
type: execute
wave: 1
depends_on: [15-02]
files_modified:
  - main.py
autonomous: true
gap_closure: true
must_haves:
  truths:
    - "When you stop the bot (Ctrl+C), both the bot and health API stop cleanly without 'address already in use' errors or orphaned processes"
    - "Ctrl+C causes immediate bot shutdown (within 2-3 seconds, not 150 seconds)"
    - "Bot polling responds to cancellation signal quickly"
    - "No orphaned Python processes remain after shutdown"
  artifacts:
    - path: "main.py"
      provides: "Graceful shutdown for polling mode with proper aiohttp timeout handling"
      contains: ["AiohttpSession", "timeout", "start_polling", "close"]
  key_links:
    - from: "main.py"
      to: "aiohttp"
      via: "AiohttpSession timeout configuration"
      pattern: "AiohttpSession\\(timeout=\\d+\\)"
    - from: "main.py"
      to: "aiogram"
      via: "start_polling with proper timeout"
      pattern: "start_polling.*timeout"
    - from: "main.py"
      to: "signal handling"
      via: "KeyboardInterrupt exception handling"
      pattern: "except KeyboardInterrupt"
---

# Plan 15-05: Graceful Shutdown Fix - Bot Responds to Ctrl+C

**Wave:** 1
**Gap Closure Plan:** Addresses UAT Test #4 failure

---

## Overview

Fix the graceful shutdown issue where pressing Ctrl+C stops the FastAPI health server quickly but leaves the bot running indefinitely. The root cause is that `AiohttpSession(timeout=120)` combined with `start_polling(timeout=30)` creates a 150-second HTTP timeout for the getUpdates long-polling request. When Ctrl+C is pressed, the asyncio task is cancelled but the underlying aiohttp HTTP request does not respond immediately to cancellation - it must complete or timeout first.

**Solution:** Reduce the AiohttpSession timeout from 120s to 10s and set the polling timeout to 10s. This ensures the bot responds to Ctrl+C within ~10 seconds instead of ~150 seconds, while still providing sufficient time for handlers to process updates.

---

## Tasks

<task type="auto">
  <name>Task 1: Fix aiohttp session timeout for responsive shutdown</name>
  <files>main.py</files>
  <action>Modify the AiohttpSession timeout in main() function to enable responsive shutdown:

**Current code (line 281):**
```python
session = AiohttpSession(timeout=120)
```

**Change to:**
```python
# AiohttpSession timeout: 10s para shutdown responsivo
# NOTA: Este es el timeout para request HTTP, NO para handlers
# Los handlers pueden tardar m√°s tiempo, esto es solo para conexiones HTTP
# Un timeout m√°s corto permite que el bot responda a Ctrl+C r√°pidamente
session = AiohttpSession(timeout=10)
```

**Also update the polling timeout (line 350):**
```python
# Iniciar polling con timeout de 10s para shutdown responsivo
# Balance entre:
# - Shutdown r√°pido (Ctrl+C funciona en ~10s)
# - Conexiones inestables (timeout suficiente para redes lentas)
# - Eficiencia (no hacer requests muy frecuentes)
logger.info("üîÑ Iniciando polling...")
await dp.start_polling(
    bot,
    allowed_updates=dp.resolve_used_update_types(),
    timeout=10,  # 10s timeout para shutdown responsivo (era 30)
    drop_pending_updates=True,
    relax_timeout=True
)
```

**Rationale:**
- AiohttpSession timeout de 10s significa que si Ctrl+C se presiona durante un request HTTP, el request se cancela en m√°ximo 10s
- El polling timeout de 10s significa que cada request getUpdates espera m√°ximo 10s por nuevos mensajes
- Esto da un tiempo de respuesta total de ~10s para Ctrl+C (en lugar de 150s)
- 10 segundos es suficiente para redes lentas y mobile connections (Termux)
- Los handlers NO est√°n limitados por este timeout - pueden tardar lo que necesiten
</action>
  <verify>
1. Start bot: `python main.py`
2. Wait for "Bot iniciado correctamente" message
3. Press Ctrl+C
4. Verify bot stops within 10-15 seconds (should see "Bot detenido por el usuario" and "Finalizando...")
5. Run `ps aux | grep python` to confirm no orphaned processes
6. Start bot again immediately - should work without "address already in use" error
</verify>
  <done>
- AiohttpSession timeout changed from 120 to 10 seconds
- start_polling timeout changed from 30 to 10 seconds
- Ctrl+C causes bot shutdown within 10-15 seconds (not 150 seconds)
- No orphaned processes after shutdown
- Bot can be restarted immediately after shutdown
</done>
</task>

<task type="auto">
  <name>Task 2: Add shutdown logging for better debugging</name>
  <files>main.py</files>
  <action>Add detailed logging to track shutdown progress:

**Modify the KeyboardInterrupt handlers in both webhook and polling modes:**

For polling mode (around line 354):
```python
except KeyboardInterrupt:
    logger.info("‚å®Ô∏è Interrupci√≥n por teclado (Ctrl+C) - Deteniendo bot...")
    logger.info("‚è±Ô∏è Cerrando sesi√≥n HTTP (puede tomar hasta 10s)...")
```

For webhook mode (around line 325):
```python
except KeyboardInterrupt:
    logger.info("‚å®Ô∏è Interrupci√≥n por teclado (Ctrl+C) - Deteniendo webhook...")
```

**Add logging in the finally block to confirm cleanup:**
```python
finally:
    # Cleanup forceful
    logger.info("üßπ Iniciando limpieza de recursos...")
    try:
        await bot.session.close()
        logger.info("‚úÖ Sesi√≥n del bot cerrada correctamente")
    except Exception as e:
        logger.warning(f"‚ö†Ô∏è Error cerrando sesi√≥n: {e}")
    logger.info("üëã Bot detenido completamente")
```

**Also add a shutdown timeout message in the finally block:**
```python
finally:
    logger.info("‚è±Ô∏è Esperando shutdown limpio (m√°x 10s)...")
```

This provides clear feedback during shutdown so users know what's happening.
</action>
  <verify>
1. Start bot: `python main.py`
2. Press Ctrl+C
3. Verify shutdown log messages appear in order:
   - "‚å®Ô∏è Interrupci√≥n por teclado (Ctrl+C) - Deteniendo bot..."
   - "‚è±Ô∏è Cerrando sesi√≥n HTTP (puede tomar hasta 10s)..."
   - "üßπ Iniciando limpieza de recursos..."
   - "‚úÖ Sesi√≥n del bot cerrada correctamente"
   - "üëã Bot detenido completamente"
4. Confirm total shutdown time is 10-15 seconds
</verify>
  <done>
- Shutdown logging added to track progress
- Users see clear messages during shutdown
- Timeout expectation communicated (10s)
- Confirmation messages appear when cleanup completes
</done>
</task>

---

## Gap Analysis

### Gap Description
**Truth:** "When you stop the bot (Ctrl+C), both the bot and health API stop cleanly without 'address already in use' errors or orphaned processes"

**Current Status:** FAILED
- User reported: "al presionar el control+C s√≠ se detiene el servidor FastAPI, pero el bot no y no lo puedo detener ya, aunque le presione control C, no lo puedo detener, sigue corriendo"

**Root Cause:** `AiohttpSession(timeout=120)` + `start_polling(timeout=30)` creates 150-second HTTP timeout. When Ctrl+C is pressed, asyncio task cancellation doesn't immediately cancel the underlying HTTP request - aiohttp HTTP requests must complete or timeout first.

**Artifacts with Issues:**
- `main.py:281` - AiohttpSession(timeout=120) creates 120-second timeout
- `main.py:350` - timeout=30 in start_polling() combines to 150 seconds
- `main.py:333/362` - await bot.session.close() in finally block never executes because start_polling() never returns

**Missing Items:**
- Proper cancellation of aiohttp HTTP requests during shutdown
- Shorter timeouts that balance responsiveness with reliability
- Separation of concerns between handler timeout (for processing updates) and polling timeout (for fetching updates)

### Solution Approach
1. Reduce AiohttpSession timeout from 120s to 10s (HTTP request timeout)
2. Reduce polling timeout from 30s to 10s (long-polling timeout)
3. Add shutdown logging for better UX
4. Document that handlers are NOT limited by this timeout

---

## Verification Criteria

**Must-haves (goal-backward verification):**

1. ‚úÖ Bot responds to Ctrl+C within 10-15 seconds
   - Test: Start bot ‚Üí Press Ctrl+C ‚Üí Verify shutdown within 15s
   - Test: No need to force-kill the process

2. ‚úÖ No orphaned processes after shutdown
   - Test: `ps aux | grep python` shows no bot processes after shutdown
   - Test: Bot can be restarted immediately without "address already in use" error

3. ‚úÖ Health API and bot both stop cleanly
   - Test: Ctrl+C stops both services
   - Test: No "address already in use" errors on restart

4. ‚úÖ Shutdown logging shows progress
   - Test: Clear log messages appear during shutdown
   - Test: Users understand what's happening during shutdown

---

## Success Metrics

- ‚úÖ Ctrl+C causes bot shutdown within 10-15 seconds (not 150 seconds)
- ‚úÖ No orphaned Python processes remain after shutdown
- ‚úÖ Bot can be restarted immediately after shutdown
- ‚úÖ Shutdown is responsive even during active polling
- ‚úÖ 10-second timeout is sufficient for mobile/termux networks
- ‚úÖ Handlers can still process updates without timeout constraints

---

## Output

After completion, create `.planning/phases/15-health-check-railway-prep/15-05-SUMMARY.md`

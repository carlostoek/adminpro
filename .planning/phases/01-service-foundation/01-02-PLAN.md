---
phase: 01-service-foundation
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - bot/services/message/common.py
  - bot/services/message/__init__.py
  - bot/services/container.py
autonomous: true

must_haves:
  truths:
    - "LucienVoiceService integrates into ServiceContainer with lazy loading via @property"
    - "CommonMessages provider returns HTML-formatted error messages with Lucien's voice"
    - "CommonMessages provider returns HTML-formatted success messages with consistent emoji"
    - "Service uses formatters from bot/utils/formatters.py for dates and numbers"
    - "All messages use emoji consistently (ðŸŽ© for Lucien, never incorrect emojis)"
  artifacts:
    - path: "bot/services/message/common.py"
      provides: "Common messages provider (errors, success, greetings)"
      min_lines: 120
      contains: "class CommonMessages(BaseMessageProvider)"
      exports: ["error", "success", "generic_error"]
    - path: "bot/services/container.py"
      provides: "ServiceContainer with message property"
      contains: "@property\n    def message(self):"
      modifies: "Adds _lucien_voice_service private attribute"
  key_links:
    - from: "bot/services/container.py"
      to: "bot/services/message/common.py"
      via: "lazy import in message property"
      pattern: "from bot.services.message import LucienVoiceService"
    - from: "bot/services/message/common.py"
      to: "bot/utils/formatters.py"
      via: "import statements for formatter functions"
      pattern: "from bot.utils.formatters import"
---

<objective>
Create LucienVoiceService with CommonMessages provider and integrate into ServiceContainer with lazy loading.

**Purpose:** Deliver first working message provider with error/success messages demonstrating Lucien's voice, establish ServiceContainer integration pattern, validate formatter integration.

**Output:** Working LucienVoiceService that handlers can access via container.message.common.error(), container.message.common.success()
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/phases/01-service-foundation/01-RESEARCH.md
@.planning/REQUIREMENTS.md
@docs/guia-estilo.md
@bot/utils/formatters.py
@bot/services/container.py
</context>

<tasks>

<task type="auto">
  <name>Create CommonMessages provider</name>
  <files>bot/services/message/common.py</files>
  <action>
Create `bot/services/message/common.py` with:

1. **Import statements:**
   ```python
   from typing import Optional
   from bot.utils.formatters import format_datetime, escape_html
   from .base import BaseMessageProvider
   ```

2. **CommonMessages class:**
   ```python
   class CommonMessages(BaseMessageProvider):
       """
       Common messages provider for shared messages across all flows.

       Provides error messages, success messages, and generic responses
       that maintain Lucien's sophisticated voice consistently.

       Voice Characteristics (from docs/guia-estilo.md):
       - Mayordomo sofisticado y elegante
       - Nunca es directo, siempre sugiere e insinÃºa
       - Usa "usted", nunca tutea
       - Emplea pausas dramÃ¡ticas con "..."
       - Emoji ðŸŽ© siempre presente

       Anti-Patterns Validated:
       - NO: "Error, algo fallÃ³" (too direct, technical)
       - NO: "Oye, tienes un problema" (tutea, breaks voice)
       - NO: "âŒ Error" (wrong emoji for Lucien)

       Correct Pattern:
       - YES: "ðŸŽ© Hmm... algo inesperado ha ocurrido." (elegant, mysterious)
       ```
   ```

3. **error method:**
   ```python
   def error(
       self,
       context: str = "",
       suggestion: str = "",
       include_footer: bool = True
   ) -> str:
       """
       Generate error message in Lucien's voice.

       Args:
           context: What operation failed (e.g., "al generar el token")
           suggestion: Optional suggestion for resolution
           include_footer: Whether to include helpful footer

       Returns:
           HTML-formatted error message

       Voice Rationale:
           Errors are "inconvenientes" or "imprevistos" not system failures.
           Lucien maintains calm sophistication even when things go wrong.
           Consults "Diana" for serious issues (mysterious authority).

       Examples:
           >>> error("al procesar su solicitud")
           "ðŸŽ© <b>Lucien:</b>\\n\\n<i>Hmm... algo inesperado ha ocurrido al procesar su solicitud.\\nPermÃ­tame consultar con Diana sobre este inconveniente.</i>"

           >>> error("al configurar el canal", "Verifique que soy administrador")
           "ðŸŽ© <b>Lucien:</b>\\n\\n<i>Hmm... algo inesperado ha ocurrido al configurar el canal.\\nPermÃ­tame consultar con Diana sobre este inconveniente.</i>\\n\\nðŸ’¡ <i>Sugerencia:</i> Verifique que soy administrador"
       """
       # Header
       header = "ðŸŽ© <b>Lucien:</b>"

       # Body with context
       if context:
           body = f"<i>Hmm... algo inesperado ha ocurrido {context}.\nPermÃ­tame consultar con Diana sobre este inconveniente.</i>"
       else:
           body = "<i>Hmm... algo inesperado ha ocurrido.\nPermÃ­tame consultar con Diana sobre este inconveniente.</i>"

       # Optional suggestion
       if suggestion:
           body += f"\n\nðŸ’¡ <i>Sugerencia:</i> {suggestion}"

       # Optional footer
       footer = ""
       if include_footer:
           footer = "<i>Mientras tanto, Â¿hay algo mÃ¡s en lo que pueda asistirle?</i>"

       return self._compose(header, body, footer)
   ```

4. **success method:**
   ```python
   def success(
       self,
       action: str,
       detail: str = "",
       celebrate: bool = False
   ) -> str:
       """
       Generate success message in Lucien's voice.

       Args:
           action: What was accomplished (e.g., "canal configurado")
           detail: Optional additional detail
           celebrate: Whether to add celebratory tone

       Returns:
           HTML-formatted success message

       Voice Rationale:
           Success is "excelente elecciÃ³n" or "como se esperaba" (understated).
           Diana approves of successful actions (authority validation).
           Never overly enthusiastic - maintains sophistication.

       Examples:
           >>> success("token generado")
           "ðŸŽ© <b>Lucien:</b>\\n\\n<i>Excelente. El token ha sido generado como se esperaba.</i>"

           >>> success("canal VIP configurado", "Todo estÃ¡ listo para recibir visitantes", celebrate=True)
           "ðŸŽ© <b>Lucien:</b>\\n\\n<i>Excelente. El canal VIP ha sido configurado como se esperaba.\\nDiana aprobarÃ¡ este progreso...</i>\\n\\nTodo estÃ¡ listo para recibir visitantes"
       """
       # Header
       header = "ðŸŽ© <b>Lucien:</b>"

       # Body
       if celebrate:
           body = f"<i>Excelente. {action.capitalize()} ha sido completado como se esperaba.\nDiana aprobarÃ¡ este progreso...</i>"
       else:
           body = f"<i>Excelente. {action.capitalize()} ha sido completado como se esperaba.</i>"

       # Optional detail
       if detail:
           body += f"\n\n{detail}"

       return self._compose(header, body)
   ```

5. **generic_error method (for unexpected errors):**
   ```python
   def generic_error(self, error_type: str = "unknown") -> str:
       """
       Generate generic error message for unexpected failures.

       Args:
           error_type: Type of error (for logging, not shown to user)

       Returns:
           HTML-formatted generic error message

       Voice Rationale:
           When something truly unexpected happens, Lucien maintains composure.
           "PerturbaciÃ³n" conveys something disturbed the natural order.
           Still offers assistance without breaking character.
       """
       header = "ðŸŽ© <b>Lucien:</b>"
       body = "<i>Una perturbaciÃ³n inesperada ha interrumpido el flujo natural de las cosas...</i>\n\n<i>PermÃ­tame un momento para restablecer el orden. Diana prefiere que estos asuntos se manejen con discreciÃ³n.</i>"
       footer = "<i>Â¿Le gustarÃ­a intentar nuevamente?</i>"

       return self._compose(header, body, footer)
   ```

6. **not_found method:**
   ```python
   def not_found(self, item_type: str, identifier: str = "") -> str:
       """
       Generate 'not found' message in Lucien's voice.

       Args:
           item_type: What wasn't found (e.g., "token", "suscriptor")
           identifier: Optional identifier (e.g., token value, user ID)

       Returns:
           HTML-formatted not found message

       Voice Rationale:
           Not found is "parece que no puedo localizar" not "ERROR NOT FOUND".
           Lucien takes responsibility ("he buscado en todos los archivos").
           Maintains helpfulness without breaking character.
       """
       header = "ðŸŽ© <b>Lucien:</b>"

       if identifier:
           body = f"<i>He buscado en todos los archivos de Diana, pero parece que no puedo localizar este {item_type}.</i>\n\n<code>{escape_html(identifier)}</code>\n\n<i>Â¿PodrÃ­a verificar que la informaciÃ³n es correcta?</i>"
       else:
           body = f"<i>He buscado en todos los archivos de Diana, pero parece que no puedo localizar este {item_type}.</i>\n\n<i>Â¿PodrÃ­a proporcionarme mÃ¡s detalles?</i>"

       footer = "<i>Estoy a su disposiciÃ³n para continuar la bÃºsqueda...</i>"

       return self._compose(header, body, footer)
   ```

7. **Add voice rationale to all method docstrings** explaining why message is phrased this way

8. **Use escape_html()** for any user-provided content (identifiers, values)

9. **100% type hints** on all methods

10. **Validate no forbidden patterns:**
    - No direct "Error:" prefixes
    - No tutear ("tienes", "tu", "haz")
    - No technical jargon ("database", "API", "exception")
    - Always use ðŸŽ© emoji
  </action>
  <verify>
```bash
python3 -c "
from bot.services.message.common import CommonMessages

# Verify provider works
common = CommonMessages()

# Test error message
err_msg = common.error('al generar token')
assert 'ðŸŽ©' in err_msg, 'Must include Lucien emoji'
assert '<b>Lucien:</b>' in err_msg, 'Must have formatted name'
assert 'inconsultar con Diana' in err_msg.lower(), 'Must mention Diana'
assert 'al generar token' in err_msg, 'Must include context'
print('âœ… Error message validated')

# Test success message
success_msg = common.success('canal configurado')
assert 'ðŸŽ©' in success_msg, 'Must include Lucien emoji'
assert 'Excelente' in success_msg, 'Must be positive'
assert 'canal configurado' in success_msg, 'Must include action'
print('âœ… Success message validated')

# Test not_found message
not_found_msg = common.not_found('token', 'ABC123')
assert 'ðŸŽ©' in not_found_msg, 'Must include Lucien emoji'
assert 'ABC123' in not_found_msg, 'Must include identifier'
assert '<code>' in not_found_msg, 'Must escape HTML'
print('âœ… Not found message validated')

# Verify inherits from BaseMessageProvider
from bot.services.message.base import BaseMessageProvider
assert isinstance(common, BaseMessageProvider), 'Must inherit from BaseMessageProvider'

# Verify utility methods available
assert hasattr(common, '_compose'), '_compose must be available'
assert hasattr(common, '_choose_variant'), '_choose_variant must be available'

print('âœ… CommonMessages provider validation passed')
"
```
  </verify>
  <done>
- bot/services/message/common.py exists with CommonMessages class
- Inherits from BaseMessageProvider
- error() method generates HTML-formatted error messages
- success() method generates HTML-formatted success messages
- not_found() method handles missing items gracefully
- generic_error() handles unexpected failures
- All messages use ðŸŽ© emoji consistently
- All messages follow Lucien's voice (elegant, mysterious, no tutear)
- Docstrings include voice rationale for each message type
- Uses escape_html() for user content
- 100% type hints on all methods
  </done>
</task>

<task type="auto">
  <name>Create LucienVoiceService and integrate with ServiceContainer</name>
  <files>bot/services/message/__init__.py, bot/services/container.py</files>
  <action>
**Part 1: Update bot/services/message/__init__.py**

Add LucienVoiceService class and update exports:

```python
"""
Message Service Package

Provides centralized message generation with Lucien's voice consistency.

Architecture:
- BaseMessageProvider: Abstract base enforcing stateless interface
- CommonMessages: Shared messages (errors, success, greetings)
- LucienVoiceService: Main service container for all message providers

All providers are stateless: no session/bot stored as instance variables.
All messages use formatters from bot.utils.formatters for dates/numbers.

Usage in handlers:
    from bot.services.container import ServiceContainer

    # Lazy-loaded via ServiceContainer.message property
    msg = container.message.common.error('something failed')
    msg = container.message.common.success('action completed')
"""

from .base import BaseMessageProvider
from .common import CommonMessages

__all__ = ["BaseMessageProvider", "CommonMessages", "LucienVoiceService"]


class LucienVoiceService:
    """
    Main message service providing access to all message providers.

    This service is stateless and integrated into ServiceContainer with lazy loading.
    Organizes message providers by navigation flow (admin/, user/) for discoverability.

    Architecture:
        ServiceContainer
            â””â”€ LucienVoiceService (this class)
                â”œâ”€ common: CommonMessages
                â”œâ”€ admin: AdminMessages (Phase 2)
                â””â”€ user: UserMessages (Phase 3)

    Voice Consistency:
        All providers inherit from BaseMessageProvider which enforces Lucien's voice.
        See docs/guia-estilo.md for complete voice guidelines.

    Stateless Design:
        This service does NOT store session or bot as instance variables.
        All context passed to message methods via parameters.
        Prevents memory leaks and database session leaks.

    Usage:
        container = ServiceContainer(session, bot)

        # Lazy-loaded: CommonMessages loads on first access
        error_msg = container.message.common.error('context')

        # Reuses cached CommonMessages instance
        success_msg = container.message.common.success('action')
    """

    def __init__(self):
        """
        Initialize message service with lazy-loaded providers.

        Providers are created on first access to minimize memory footprint.
        """
        self._common = None

    @property
    def common(self) -> CommonMessages:
        """
        Common messages provider (errors, success, not_found).

        Lazy-loaded: creates CommonMessages instance on first access.

        Returns:
            CommonMessages: Provider for shared messages
        """
        if self._common is None:
            self._common = CommonMessages()
        return self._common
```

**Part 2: Update bot/services/container.py**

Add message property to ServiceContainer class:

1. **Add private attribute in __init__:**
   ```python
   # In __init__ method, after existing service attributes
   self._lucien_voice_service = None
   ```

2. **Add message property after all existing service properties:**
   ```python
   # ===== LUCIEN VOICE SERVICE =====

   @property
   def message(self):
       """
       Servicio de mensajes con la voz de Lucien.

       Se carga lazy (solo en primer acceso).

       Returns:
           LucienVoiceService: Instancia del servicio de mensajes

       Usage:
           # Generate error message
           error_msg = container.message.common.error('al generar token')

           # Generate success message
           success_msg = container.message.common.success('canal configurado')
       """
       if self._lucien_voice_service is None:
           from bot.services.message import LucienVoiceService
           logger.debug("ðŸ”„ Lazy loading: LucienVoiceService")
           self._lucien_voice_service = LucienVoiceService()

       return self._lucien_voice_service
   ```

3. **Update get_loaded_services() to include message:**
   ```python
   # In get_loaded_services() method, add:
   if self._lucien_voice_service is not None:
       loaded.append("message")
   ```

**Verification:**
- No circular imports (lazy import in property)
- Follows existing ServiceContainer pattern exactly
- Message service is stateless (no session/bot passed to __init__)
- Lazy loading confirmed (only loads on first access)
  </action>
  <verify>
```bash
python3 -c "
from bot.services.container import ServiceContainer
from bot.services.message import LucienVoiceService, CommonMessages

# Verify ServiceContainer integration
print('Testing ServiceContainer.message integration...')

# Mock session and bot (we're not testing actual functionality, just structure)
class MockSession:
    pass

class MockBot:
    pass

container = ServiceContainer(MockSession(), MockBot())

# Verify lazy loading (not loaded yet)
loaded = container.get_loaded_services()
assert 'message' not in loaded, 'Message service should not be loaded yet'
print('âœ… Message service not loaded initially (lazy loading works)')

# Trigger lazy load
msg_service = container.message
assert isinstance(msg_service, LucienVoiceService), 'Must return LucienVoiceService'
print('âœ… LucienVoiceService returned on first access')

# Verify it's cached
msg_service_2 = container.message
assert msg_service is msg_service_2, 'Must cache and reuse instance'
print('âœ… Message service cached correctly')

# Verify it's now in loaded services
loaded = container.get_loaded_services()
assert 'message' in loaded, 'Message service should be in loaded list'
print('âœ… Message service tracked in loaded services')

# Verify common provider works
common = container.message.common
assert isinstance(common, CommonMessages), 'Must return CommonMessages'
print('âœ… CommonMessages provider accessible')

# Test message generation
err = container.message.common.error('test context')
assert 'ðŸŽ©' in err, 'Must include Lucien emoji'
assert 'test context' in err, 'Must include context'
print('âœ… Error message generation works')

success = container.message.common.success('test action')
assert 'ðŸŽ©' in success, 'Must include Lucien emoji'
assert 'test action' in success, 'Must include action'
print('âœ… Success message generation works')

print('âœ… LucienVoiceService integration validated')
"
```
  </verify>
  <done>
- LucienVoiceService class exists in bot/services/message/__init__.py
- ServiceContainer has @property message that returns LucienVoiceService
- Lazy loading works (service not loaded until first access)
- Service is cached and reused on subsequent accesses
- get_loaded_services() tracks message service
- container.message.common returns CommonMessages provider
- container.message.common.error() generates error messages
- container.message.common.success() generates success messages
- No circular imports (lazy import in property)
- Follows existing ServiceContainer pattern exactly
- Message service is stateless (no session/bot in LucienVoiceService.__init__)
  </done>
</task>

</tasks>

<verification>
Overall phase checks after plan completion:
- [ ] LucienVoiceService class exists with lazy-loaded providers
- [ ] ServiceContainer.message property returns LucienVoiceService
- [ ] CommonMessages provider accessible via container.message.common
- [ ] error() method generates HTML-formatted messages with ðŸŽ© emoji
- [ ] success() method generates HTML-formatted messages with ðŸŽ© emoji
- [ ] not_found() method handles missing items gracefully
- [ ] All messages follow Lucien's voice (no tutear, elegant, mentions Diana)
- [ ] escape_html() used for user-provided content
- [ ] Docstrings include voice rationale
- [ ] Lazy loading confirmed (service loads on first access only)
- [ ] Service cached and reused (not recreated on each access)
- [ ] get_loaded_services() includes "message" after first access
</verification>

<success_criteria>
1. LucienVoiceService integrated into ServiceContainer with lazy loading
2. CommonMessages provider returns working error and success messages
3. All messages maintain Lucien's voice (elegant, mysterious, no tutear)
4. HTML formatting works correctly (<b>, <i>, <code> tags)
5. Emoji consistency enforced (ðŸŽ© for Lucien, never incorrect emojis)
6. Service is stateless (no session/bot stored as instance variables)
7. Handlers can call container.message.common.error() successfully
</success_criteria>

<output>
After completion, create `.planning/phases/01-service-foundation/01-02-SUMMARY.md` with:
- Frontmatter (phase, plan, wave, dependencies, files_modified, tech_added, patterns_established)
- Implementation summary describing LucienVoiceService and CommonMessages
- Example error/success messages demonstrating Lucien's voice
- ServiceContainer integration confirmation
- Stateless design validation
</output>

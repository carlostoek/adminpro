---
phase: 01-service-foundation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - bot/services/message/__init__.py
  - bot/services/message/base.py
autonomous: true

must_haves:
  truths:
    - "BaseMessageProvider abstract class enforces stateless interface (no session/bot instance variables)"
    - "All message provider methods accept parameters only (no database models)"
    - "Utility methods (_compose, _choose_variant) provide template composition without business logic"
    - "Docstrings include voice rationale for each message method"
  artifacts:
    - path: "bot/services/message/base.py"
      provides: "Abstract base class enforcing stateless message provider interface"
      min_lines: 80
      contains: "class BaseMessageProvider(ABC)"
      exports: ["_compose", "_choose_variant"]
    - path: "bot/services/message/__init__.py"
      provides: "Package exports for message service"
      contains: "from .base import BaseMessageProvider"
  key_links:
    - from: "Future message providers (admin, user, common)"
      to: "bot/services/message/base.py"
      via: "inheritance from BaseMessageProvider"
      pattern: "class.*Messages.*BaseMessageProvider"
---

<objective>
Create abstract BaseMessageProvider class that enforces stateless interface and provides utility methods for template composition.

**Purpose:** Foundation for all message providers - prevents critical pitfall #5 (Stateful Service) by enforcing no session/bot instance variables at the class level.

**Output:** Abstract base class with utility methods that all message providers inherit from.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/phases/01-service-foundation/01-RESEARCH.md
@.planning/REQUIREMENTS.md
@docs/guia-estilo.md
@bot/utils/formatters.py
</context>

<tasks>

<task type="auto">
  <name>Create BaseMessageProvider abstract class</name>
  <files>bot/services/message/base.py</files>
  <action>
Create `bot/services/message/` directory and `base.py` with:

1. **Import statements:**
   - `from abc import ABC, abstractmethod`
   - `from typing import Any, Optional`
   - `import random`

2. **BaseMessageProvider class:**
   ```python
   class BaseMessageProvider(ABC):
       """
       Base abstract class for all message providers.

       Enforces stateless interface: providers MUST NOT store session or bot
       as instance variables. All context must be passed as method parameters.

       Voice Rules (from docs/guia-estilo.md):
       - Siempre habla de "usted", nunca tutea
       - Usa lenguaje refinado pero natural
       - Emoji caracterÃ­stico: ðŸŽ© para Lucien
       - Referencias a Diana con ðŸŒ¸
       - Nunca usa jerga tÃ©cnica directa
       - Emplea pausas dramÃ¡ticas con "..."

       Anti-Patterns to Avoid:
       - NEVER: self.session, self.bot (causes memory leaks)
       - NEVER: Formatting logic in handlers (causes voice inconsistency)
       - NEVER: Hardcoded strings without voice rationale in docstring
       """
   ```

3. **Stateless enforcement (CRITICAL):**
   - Add comment in class docstring explicitly prohibiting session/bot as instance variables
   - No __init__ that stores session or bot
   - All message methods receive data via parameters

4. **Utility method: _compose**
   ```python
   def _compose(self, header: str, body: str, footer: str = "") -> str:
       """
       Compose message from header, body, and optional footer.

       Args:
           header: Message header (e.g., "ðŸŽ© Lucien:")
           body: Main message content
           footer: Optional footer text

       Returns:
           Composed HTML-formatted message

       Voice Rationale:
           Separating composition enables template reuse while maintaining
           consistent Lucien voice across all message types.
       """
       parts = [header, body]
       if footer:
           parts.append(footer)
       return "\n\n".join(parts)
   ```

5. **Utility method: _choose_variant**
   ```python
   def _choose_variant(self, variants: list[str], weights: Optional[list[float]] = None) -> str:
       """
       Choose a message variant randomly (with optional weights).

       Args:
           variants: List of message variations
           weights: Optional weights for each variant (must sum to 1.0)

       Returns:
           Selected message variant

       Voice Rationale:
           Prevents robotic repetition while maintaining Lucien's voice.
           Weighted choices enable "common vs rare" personality variations.

       Examples:
           Equal weights:
               variants = ["Hola", "Bienvenido"]
               -> 50/50 chance each

           Weighted (80% common, 20% rare):
               variants = ["Buen dÃ­a", "Saludos"]
               weights = [0.8, 0.2]
               -> "Buen dÃ­a" 80% of time
       """
       if not variants:
               raise ValueError("variants cannot be empty")

       if weights is None:
           return random.choice(variants)

       if len(weights) != len(variants):
           raise ValueError("weights and variants must have same length")

       return random.choices(variants, weights=weights, k=1)[0]
   ```

6. **Add docstring examples** for both utility methods showing usage

7. **Type hints:** 100% coverage on all method signatures
  </action>
  <verify>
```bash
python3 -c "
from bot.services.message.base import BaseMessageProvider
import inspect

# Verify class is abstract
from abc import ABC
assert issubclass(BaseMessageProvider, ABC), 'Must inherit from ABC'

# Verify methods exist
assert hasattr(BaseMessageProvider, '_compose'), '_compose missing'
assert hasattr(BaseMessageProvider, '_choose_variant'), '_choose_variant missing'

# Verify stateless enforcement in docstring
docstring = BaseMessageProvider.__doc__
assert 'stateless' in docstring.lower(), 'Must mention stateless in docstring'
assert 'session' in docstring.lower() and 'bot' in docstring.lower(), 'Must warn about session/bot'

# Verify _choose_variant works
provider = BaseMessageProvider()
result = provider._choose_variant(['a', 'b'], [0.7, 0.3])
assert result in ['a', 'b'], 'Must return valid variant'

print('âœ… BaseMessageProvider validation passed')
"
```
  </verify>
  <done>
- bot/services/message/base.py exists with BaseMessageProvider abstract class
- Class docstring explicitly enforces stateless pattern (no session/bot instance variables)
- _compose method builds messages from header/body/footer
- _choose_variant method selects random or weighted variants
- 100% type hints on all methods
- Docstrings include voice rationale and anti-pattern warnings
- All imports present (ABC, abstractmethod, typing, random)
  </done>
</task>

<task type="auto">
  <name>Create message service package exports</name>
  <files>bot/services/message/__init__.py</files>
  <action>
Create `bot/services/message/__init__.py` with:

1. **Export BaseMessageProvider:**
   ```python
   """
   Message Service Package

   Provides centralized message generation with Lucien's voice consistency.

   Architecture:
   - BaseMessageProvider: Abstract base enforcing stateless interface
   - CommonMessages: Shared messages (errors, success, greetings)
   - AdminMessages: Admin-specific messages (by navigation flow)
   - UserMessages: User-specific messages (by navigation flow)

   All providers are stateless: no session/bot stored as instance variables.
   All messages use formatters from bot.utils.formatters for dates/numbers.

   Usage in handlers:
       from bot.services.container import ServiceContainer

       # Lazy-loaded via ServiceContainer.message property
       msg = container.message.common.error('something failed')
   """

   from .base import BaseMessageProvider

   __all__ = ["BaseMessageProvider"]
   ```

2. **Add package docstring** explaining the architecture and stateless pattern

3. **Export BaseMessageProvider** in __all__ for explicit API
  </action>
  <verify>
```bash
python3 -c "
from bot.services.message import BaseMessageProvider

# Verify import works
assert BaseMessageProvider is not None

# Verify __all__ export
from bot.services.message import __all__
assert 'BaseMessageProvider' in __all__

print('âœ… Message package exports validated')
"
```
  </verify>
  <done>
- bot/services/message/__init__.py exists
- BaseMessageProvider exported in __all__
- Package docstring explains architecture and stateless pattern
- Import works without errors
  </done>
</task>

</tasks>

<verification>
Overall phase checks after plan completion:
- [ ] BaseMessageProvider is abstract (inherits from ABC)
- [ ] Class docstring explicitly prohibits session/bot as instance variables
- [ ] _compose method builds messages from components
- [ ] _choose_variant method supports equal and weighted selection
- [ ] All methods have 100% type hints
- [ ] Docstrings include voice rationale from docs/guia-estilo.md
- [ ] Package exports BaseMessageProvider via __all__
- [ ] No session or bot parameters in __init__ (stateless enforcement)
</verification>

<success_criteria>
1. BaseMessageProvider abstract class exists with stateless interface enforcement
2. Utility methods (_compose, _choose_variant) provide template composition foundation
3. Class docstring documents voice rules and anti-patterns from research
4. All future message providers can inherit from this base class
5. Package structure established for adding CommonMessages in next plan
</success_criteria>

<output>
After completion, create `.planning/phases/01-service-foundation/01-01-SUMMARY.md` with:
- Frontmatter (phase, plan, wave, dependencies, files_modified, tech_added, patterns_established)
- Implementation summary describing BaseMessageProvider and utility methods
- Voice rules encoded in docstrings
- Stateless enforcement pattern documented
</output>

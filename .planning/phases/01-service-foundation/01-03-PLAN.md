---
phase: 01-service-foundation
plan: 03
type: execute
wave: 2
depends_on: ["01-01", "01-02"]
files_modified:
  - tests/test_message_service.py
autonomous: true

must_haves:
  truths:
    - "All tests validate stateless interface (no session/bot instance variables)"
    - "Tests confirm voice consistency (no tutear, üé© emoji present)"
    - "Tests validate HTML formatting (<b>, <i>, <code> tags work)"
    - "Tests verify lazy loading in ServiceContainer"
    - "Tests confirm CommonMessages generates working error/success messages"
  artifacts:
    - path: "tests/test_message_service.py"
      provides: "Test suite for message service foundation"
      min_lines: 200
      contains: "def test_", "import pytest"
      exports: ["test_base_message_provider", "test_common_messages", "test_service_container_integration"]
  key_links:
    - from: "tests/test_message_service.py"
      to: "bot/services/message/base.py"
      via: "import and instantiation of BaseMessageProvider"
      pattern: "from bot.services.message.base import BaseMessageProvider"
    - from: "tests/test_message_service.py"
      to: "bot/services/message/common.py"
      via: "import and instantiation of CommonMessages"
      pattern: "from bot.services.message.common import CommonMessages"
    - from: "tests/test_message_service.py"
      to: "bot/services/container.py"
      via: "ServiceContainer instantiation and message property access"
      pattern: "from bot.services.container import ServiceContainer"
---

<objective>
Create comprehensive test suite validating message service foundation, voice consistency, and ServiceContainer integration.

**Purpose:** Ensure foundation works correctly before Phase 2 handler migration begins. Validate stateless pattern, voice consistency, HTML formatting, and lazy loading.

**Output:** Passing test suite confirming all Phase 1 success criteria met.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/phases/01-service-foundation/01-01-PLAN.md
@.planning/phases/01-service-foundation/01-02-PLAN.md
@bot/services/message/base.py
@bot/services/message/common.py
@bot/services/container.py
@docs/guia-estilo.md
</context>

<tasks>

<task type="auto">
  <name>Create test suite for message service foundation</name>
  <files>tests/test_message_service.py</files>
  <action>
Create `tests/test_message_service.py` with comprehensive tests:

**File structure:**

```python
"""
Test suite for LucienVoiceService foundation (Phase 1).

Tests validate:
- Stateless interface enforcement
- Voice consistency (Lucien's personality)
- HTML formatting
- ServiceContainer integration
- Lazy loading
- Utility methods (_compose, _choose_variant)
"""
import pytest
from bot.services.message.base import BaseMessageProvider
from bot.services.message.common import CommonMessages
from bot.services.message import LucienVoiceService
from bot.services.container import ServiceContainer


# ===== BASE MESSAGE PROVIDER TESTS =====

class TestBaseMessageProvider:
    """Test BaseMessageProvider abstract class and utility methods."""

    def test_base_is_abstract(self):
        """Verify BaseMessageProvider is abstract and cannot be instantiated directly."""
        from abc import ABC

        assert issubclass(BaseMessageProvider, ABC), \
            "BaseMessageProvider must inherit from ABC"

    def test_utility_methods_exist(self):
        """Verify _compose and _choose_variant methods exist."""
        # Create a concrete implementation for testing
        class TestProvider(BaseMessageProvider):
            pass

        provider = TestProvider()

        assert hasattr(provider, '_compose'), \
            "BaseMessageProvider must have _compose method"
        assert hasattr(provider, '_choose_variant'), \
            "BaseMessageProvider must have _choose_variant method"

    def test_compose_builds_message(self):
        """Test _compose combines header, body, and footer correctly."""
        class TestProvider(BaseMessageProvider):
            pass

        provider = TestProvider()

        # Test with header and body only
        result = provider._compose("Header", "Body")
        assert result == "Header\n\nBody", \
            "Should combine header and body with double newline"

        # Test with header, body, and footer
        result = provider._compose("Header", "Body", "Footer")
        assert result == "Header\n\nBody\n\nFooter", \
            "Should combine all three parts with double newlines"

    def test_choose_variant_equal_weights(self):
        """Test _choose_variant with equal weights (random.choice behavior)."""
        class TestProvider(BaseMessageProvider):
            pass

        provider = TestProvider()
        variants = ["a", "b", "c"]

        # Multiple calls should eventually return all variants
        results = set()
        for _ in range(50):
            result = provider._choose_variant(variants)
            assert result in variants, "Must return valid variant"
            results.add(result)

        # With 50 iterations, should have seen all variants at least once
        assert len(results) == 3, "Should eventually return all variants"

    def test_choose_variant_weighted(self):
        """Test _choose_variant with weighted selection."""
        class TestProvider(BaseMessageProvider):
            pass

        provider = TestProvider()
        variants = ["common", "rare"]
        weights = [0.9, 0.1]  # 90% common, 10% rare

        # With 100 iterations, "common" should appear much more often
        results = []
        for _ in range(100):
            result = provider._choose_variant(variants, weights)
            results.append(result)

        common_count = results.count("common")
        rare_count = results.count("rare")

        # "common" should appear significantly more often
        assert common_count > rare_count * 5, \
            f"Weighted selection failed: common={common_count}, rare={rare_count}"

    def test_choose_variant_empty_raises_error(self):
        """Test _choose_variant raises ValueError for empty list."""
        class TestProvider(BaseMessageProvider):
            pass

        provider = TestProvider()

        with pytest.raises(ValueError, match="variants cannot be empty"):
            provider._choose_variant([])

    def test_choose_variant_mismatched_weights_raises_error(self):
        """Test _choose_variant raises ValueError for mismatched weights."""
        class TestProvider(BaseMessageProvider):
            pass

        provider = TestProvider()

        with pytest.raises(ValueError, match="weights and variants must have same length"):
            provider._choose_variant(["a", "b"], [0.5])  # 2 variants, 1 weight


# ===== COMMON MESSAGES TESTS =====

class TestCommonMessages:
    """Test CommonMessages provider for voice consistency and formatting."""

    def test_inherits_from_base(self):
        """Verify CommonMessages inherits from BaseMessageProvider."""
        common = CommonMessages()
        assert isinstance(common, BaseMessageProvider), \
            "CommonMessages must inherit from BaseMessageProvider"

    def test_error_has_lucien_emoji(self):
        """Verify error messages include Lucien's characteristic emoji."""
        common = CommonMessages()
        error_msg = common.error("test context")

        assert "üé©" in error_msg, \
            "Error messages must include üé© emoji (Lucien's signature)"

    def test_error_mentions_diana(self):
        """Verify error messages mention Diana (authority figure)."""
        common = CommonMessages()
        error_msg = common.error("test context")

        # Check for "Diana" or "consultar" (Lucien defers to Diana)
        msg_lower = error_msg.lower()
        assert "diana" in msg_lower or "consultar" in msg_lower, \
            "Error messages should mention Diana or consulting with her"

    def test_error_no_tutear(self):
        """Verify error messages don't use 't√∫' form (tutear)."""
        common = CommonMessages()
        error_msg = common.error("test context")

        forbidden = ["tienes", "tu ", "tu.", "haz", "puedes"]
        msg_lower = error_msg.lower()

        for word in forbidden:
            assert word not in msg_lower, \
                f"Error messages must not tutear (found '{word}')"

    def test_error_no_technical_jargon(self):
        """Verify error messages avoid technical jargon."""
        common = CommonMessages()
        error_msg = common.error("test context")

        technical = ["database", "api", "exception", "null pointer", "500"]
        msg_lower = error_msg.lower()

        for term in technical:
            assert term not in msg_lower, \
                f"Error messages must avoid technical jargon (found '{term}')"

    def test_error_includes_context(self):
        """Verify error messages include provided context."""
        common = CommonMessages()

        error_msg = common.error("al generar el token")
        assert "al generar el token" in error_msg, \
            "Error messages must include provided context"

        error_msg = common.error("al configurar el canal")
        assert "al configurar el canal" in error_msg, \
            "Error messages must include provided context"

    def test_error_includes_suggestion(self):
        """Verify error messages can include optional suggestions."""
        common = CommonMessages()
        error_msg = common.error("context", suggestion="Verifique los permisos")

        assert "Verifique los permisos" in error_msg, \
            "Error messages must include suggestion when provided"

    def test_error_has_html_formatting(self):
        """Verify error messages use HTML formatting."""
        common = CommonMessages()
        error_msg = common.error("test context")

        # Should have bold tags for "Lucien:"
        assert "<b>" in error_msg and "</b>" in error_msg, \
            "Error messages must use HTML <b> tags"

        # Should have italic tags for message body
        assert "<i>" in error_msg and "</i>" in error_msg, \
            "Error messages must use HTML <i> tags"

    def test_success_has_lucien_emoji(self):
        """Verify success messages include Lucien's emoji."""
        common = CommonMessages()
        success_msg = common.success("action completed")

        assert "üé©" in success_msg, \
            "Success messages must include üé© emoji"

    def test_success_positive_tone(self):
        """Verify success messages have positive tone."""
        common = CommonMessages()
        success_msg = common.success("action completed")

        positive_words = ["excelente", "como se esperaba", "completado"]
        msg_lower = success_msg.lower()

        has_positive = any(word in msg_lower for word in positive_words)
        assert has_positive, \
            "Success messages must have positive tone"

    def test_success_includes_action(self):
        """Verify success messages include the action that was completed."""
        common = CommonMessages()

        success_msg = common.success("token generado")
        assert "token generado" in success_msg, \
            "Success messages must include the completed action"

        success_msg = common.success("canal configurado")
        assert "canal configurado" in success_msg, \
            "Success messages must include the completed action"

    def test_success_celebratory_tone(self):
        """Verify success messages can have celebratory tone."""
        common = CommonMessages()

        # Normal success
        normal_msg = common.success("action")
        assert "Diana" not in normal_msg or "aprob" not in normal_msg.lower(), \
            "Normal success should not mention Diana's approval"

        # Celebratory success
        celebrate_msg = common.success("action", celebrate=True)
        # Celebratory messages should mention Diana approving
        assert "Diana" in celebrate_msg or "aprob" in celebrate_msg.lower() or "progreso" in celebrate_msg.lower(), \
            "Celebratory success should mention Diana or progress"

    def test_not_found_escapes_html(self):
        """Verify not_found messages escape HTML in identifiers."""
        common = CommonMessages()
        not_found_msg = common.not_found("token", "<script>alert('xss')</script>")

        # Should escape < and >
        assert "&lt;" in not_found_msg and "&gt;" in not_found_msg, \
            "not_found must escape HTML in identifiers"

        # Should NOT contain raw script tags
        assert "<script>" not in not_found_msg, \
            "not_found must not include raw HTML tags"
        assert "</script>" not in not_found_msg, \
            "not_found must not include raw HTML tags"

    def test_not_found_has_lucien_voice(self):
        """Verify not_found messages maintain Lucien's voice."""
        common = CommonMessages()
        not_found_msg = common.not_found("token", "ABC123")

        # Should have emoji
        assert "üé©" in not_found_msg, \
            "not_found messages must include üé© emoji"

        # Should be polite and offer help
        assert "archiv" in not_found_msg.lower() or Diana" in not_found_msg.lower() or "ayud" in not_found_msg.lower(), \
            "not_found messages should reference files or offer help"

        # Should include identifier
        assert "ABC123" in not_found_msg, \
            "not_found messages must include the identifier"

    def test_generic_error_maintains_composure(self):
        """Verify generic_error maintains Lucien's sophisticated composure."""
        common = CommonMessages()
        generic_msg = common.generic_error()

        # Should have emoji
        assert "üé©" in generic_msg, \
            "generic_error must include üé© emoji"

        # Should be mysterious but calm (not panicking)
        panic_words = ["critical", "fatal", "panic", "crash"]
        msg_lower = generic_msg.lower()

        for word in panic_words:
            assert word not in msg_lower, \
                f"generic_error must not show panic (found '{word}')"

        # Should offer to help
        help_words = ["intente", "ayuda", "asist", "disposici√≥n"]
        has_help = any(word in msg_lower for word in help_words)
        assert has_help, \
            "generic_error should offer assistance"


# ===== SERVICE CONTAINER INTEGRATION TESTS =====

class TestServiceContainerIntegration:
    """Test LucienVoiceService integration with ServiceContainer."""

    def test_message_property_exists(self):
        """Verify ServiceContainer has message property."""
        # Create minimal mock objects
        class MockSession:
            pass

        class MockBot:
            pass

        container = ServiceContainer(MockSession(), MockBot())

        assert hasattr(container, 'message'), \
            "ServiceContainer must have 'message' property"

    def test_message_property_lazy_loading(self):
        """Verify message service is lazy-loaded (not loaded until accessed)."""
        class MockSession:
            pass

        class MockBot:
            pass

        container = ServiceContainer(MockSession(), MockBot())

        # Should not be loaded initially
        loaded = container.get_loaded_services()
        assert "message" not in loaded, \
            "Message service should not be loaded before first access"

        # Access the property
        _ = container.message

        # Now it should be loaded
        loaded = container.get_loaded_services()
        assert "message" in loaded, \
            "Message service should be loaded after first access"

    def test_message_returns_lucien_voice_service(self):
        """Verify message property returns LucienVoiceService instance."""
        class MockSession:
            pass

        class MockBot:
            pass

        container = ServiceContainer(MockSession(), MockBot())

        msg_service = container.message
        assert isinstance(msg_service, LucienVoiceService), \
            "message property must return LucienVoiceService instance"

    def test_message_service_caching(self):
        """Verify message service is cached and reused."""
        class MockSession:
            pass

        class MockBot:
            pass

        container = ServiceContainer(MockSession(), MockBot())

        # Access twice
        service1 = container.message
        service2 = container.message

        # Should be the same instance
        assert service1 is service2, \
            "Message service must be cached and reused"

    def test_common_provider_accessible(self):
        """Verify CommonMessages provider is accessible through service."""
        class MockSession:
            pass

        class MockBot:
            pass

        container = ServiceContainer(MockSession(), MockBot())

        # Access common provider
        common = container.message.common
        assert isinstance(common, CommonMessages), \
            "Common provider must be accessible via container.message.common"

    def test_end_to_end_message_generation(self):
        """Test complete flow: container -> service -> provider -> message."""
        class MockSession:
            pass

        class MockBot:
            pass

        container = ServiceContainer(MockSession(), MockBot())

        # Generate error message through complete chain
        error_msg = container.message.common.error("test context")

        # Verify it works
        assert "üé©" in error_msg, "Must include Lucien emoji"
        assert "test context" in error_msg, "Must include context"
        assert "<b>" in error_msg and "</b>" in error_msg, "Must have HTML formatting"

        # Generate success message
        success_msg = container.message.common.success("test action")

        # Verify it works
        assert "üé©" in success_msg, "Must include Lucien emoji"
        assert "test action" in success_msg, "Must include action"

    def test_service_is_stateless(self):
        """Verify message service does not store session or bot."""
        class MockSession:
            pass

        class MockBot:
            pass

        container = ServiceContainer(MockSession(), MockBot())

        msg_service = container.message

        # Should not have session or bot as instance variables
        assert not hasattr(msg_service, 'session'), \
            "LucienVoiceService must not store session"
        assert not hasattr(msg_service, 'bot'), \
            "LucienVoiceService must not store bot"

        # Common provider should also be stateless
        common = msg_service.common
        assert not hasattr(common, 'session'), \
            "CommonMessages must not store session"
        assert not hasattr(common, 'bot'), \
            "CommonMessages must not store bot"
```

**Key test categories:**
1. BaseMessageProvider tests (abstract class, utility methods)
2. CommonMessages tests (voice consistency, HTML formatting, no tutear)
3. ServiceContainer integration (lazy loading, caching, stateless design)
4. End-to-end tests (complete message generation flow)

**Voice consistency validation:**
- ‚úÖ No tutear (tienes, tu, haz, puedes)
- ‚úÖ No technical jargon (database, API, exception)
- ‚úÖ Always uses üé© emoji
- ‚úÖ Mentions Diana appropriately
- ‚úÖ Maintains elegant, mysterious tone

**HTML formatting validation:**
- ‚úÖ <b> tags for bold text
- ‚úÖ <i> tags for italic text
- ‚úÖ <code> tags for identifiers
- ‚úÖ escape_html() for user content
  </action>
  <verify>
```bash
# Run the test suite
cd /data/data/com.termux/files/home/repos/c1
pytest tests/test_message_service.py -v --tb=short

# Expected output:
# test_base_is_abstract PASSED
# test_utility_methods_exist PASSED
# test_compose_builds_message PASSED
# test_choose_variant_equal_weights PASSED
# test_choose_variant_weighted PASSED
# test_choose_variant_empty_raises_error PASSED
# test_choose_variant_mismatched_weights_raises_error PASSED
# test_inherits_from_base PASSED
# test_error_has_lucien_emoji PASSED
# test_error_mentions_diana PASSED
# test_error_no_tutear PASSED
# test_error_no_technical_jargon PASSED
# test_error_includes_context PASSED
# test_error_includes_suggestion PASSED
# test_error_has_html_formatting PASSED
# test_success_has_lucien_emoji PASSED
# test_success_positive_tone PASSED
# test_success_includes_action PASSED
# test_success_celebratory_tone PASSED
# test_not_found_escapes_html PASSED
# test_not_found_has_lucien_voice PASSED
# test_generic_error_maintains_composure PASSED
# test_message_property_exists PASSED
# test_message_property_lazy_loading PASSED
# test_message_returns_lucien_voice_service PASSED
# test_message_service_caching PASSED
# test_common_provider_accessible PASSED
# test_end_to_end_message_generation PASSED
# test_service_is_stateless PASSED
#
# =========================== 27 passed in 0.XXs ===========================

# Verify all tests passed
if [ $? -eq 0 ]; then
    echo "‚úÖ All 27 tests passed"
    exit 0
else
    echo "‚ùå Some tests failed"
    exit 1
fi
```
  </verify>
  <done>
- tests/test_message_service.py exists with 27+ tests
- Tests validate BaseMessageProvider abstract class
- Tests validate _compose and _choose_variant utility methods
- Tests validate CommonMessages voice consistency (no tutear, no jargon, üé© emoji)
- Tests validate HTML formatting (<b>, <i>, <code> tags)
- Tests validate escape_html() for user content
- Tests validate ServiceContainer lazy loading
- Tests validate message service caching
- Tests validate stateless design (no session/bot in service)
- Tests validate end-to-end message generation flow
- All 27 tests pass successfully
  </done>
</task>

</tasks>

<verification>
Overall phase checks after plan completion:
- [ ] All 27 tests pass (BaseMessageProvider, CommonMessages, ServiceContainer integration)
- [ ] Voice consistency tests validate no tutear, no jargon, üé© emoji present
- [ ] HTML formatting tests validate <b>, <i>, <code> tags work correctly
- [ ] Stateless design tests confirm no session/bot stored in service
- [ ] Lazy loading tests confirm service loads on first access only
- [ ] Caching tests confirm service reused on subsequent accesses
- [ ] End-to-end tests validate complete message generation flow
- [ ] Utility method tests validate _compose and _choose_variant work correctly
</verification>

<success_criteria>
1. All 27 tests pass successfully
2. Voice consistency validated (no tutear, no jargon, üé© emoji always present)
3. HTML formatting validated (bold, italic, code tags work)
4. Stateless design validated (no session/bot in service or providers)
5. Lazy loading validated (service loads on first access)
6. Caching validated (service reused, not recreated)
7. End-to-end flow validated (container -> service -> provider -> message)
8. Foundation ready for Phase 2 handler migration
</success_criteria>

<output>
After completion, create `.planning/phases/01-service-foundation/01-03-SUMMARY.md` with:
- Frontmatter (phase, plan, wave, dependencies, files_modified, tests_created)
- Test summary: 27 tests covering BaseMessageProvider, CommonMessages, ServiceContainer integration
- Voice consistency validation results
- HTML formatting validation results
- Stateless design validation results
- Confirmation that Phase 1 foundation is complete and ready for Phase 2
</output>

---
phase: 22-shop-system
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - bot/database/models.py
  - bot/database/enums.py
autonomous: true

must_haves:
  truths:
    - ContentSet model stores file_ids array for Telegram content delivery
    - ShopProduct model has besitos_price and vip_discount_percentage
    - UserContentAccess tracks purchased content with context (shop_purchase, reward_claim)
    - ContentType enum supports photo_set, video, audio, mixed
    - ContentTier enum supports free, vip, premium, gift
  artifacts:
    - path: bot/database/models.py
      provides: ContentSet, ShopProduct, UserContentAccess models
      contains: ["class ContentSet", "class ShopProduct", "class UserContentAccess"]
    - path: bot/database/enums.py
      provides: ContentType, ContentTier enums
      contains: ["class ContentType", "class ContentTier"]
  key_links:
    - from: ShopProduct
      to: ContentSet
      via: content_set_id ForeignKey
    - from: UserContentAccess
      to: ContentSet
      via: content_set_id ForeignKey
    - from: UserContentAccess
      to: User
      via: user_id ForeignKey
---

<objective>
Create database foundation for shop system with ContentSet centralized content storage, ShopProduct catalog items, and UserContentAccess purchase tracking.

Purpose: Enable the shop system to store products, track purchases, and deliver content via Telegram file_ids.
Output: Three new models (ContentSet, ShopProduct, UserContentAccess) and two new enums (ContentType, ContentTier).
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md
@.planning/phases/22-shop-system/22-CONTEXT.md
@bot/database/models.py
@bot/database/enums.py

# Phase 21 established patterns for gamification models (UserStreak, Transaction)
# Phase 19 established WalletService pattern for atomic transactions
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add ContentType and ContentTier enums</name>
  <files>bot/database/enums.py</files>
  <action>
    Add two new enums to bot/database/enums.py following existing patterns:

    1. ContentType enum (for ContentSet.content_type):
       - PHOTO_SET = "photo_set"
       - VIDEO = "video"
       - AUDIO = "audio"
       - MIXED = "mixed"
       Include display_name property with Spanish translations ("Set de Fotos", "Video", "Audio", "Mixto")

    2. ContentTier enum (for ContentSet.tier and ShopProduct.tier):
       - FREE = "free"
       - VIP = "vip"
       - PREMIUM = "premium"
       - GIFT = "gift"
       Include display_name property with Spanish translations ("Gratis", "VIP", "Premium", "Regalo")
       Include emoji property (üå∏, ‚≠ê, üíé, üéÅ)

    Place after StreakType enum, before TransactionType enum.
    Follow exact same pattern as existing enums with __str__, display_name, and emoji properties.
  </action>
  <verify>grep -A 20 "class ContentType" bot/database/enums.py && grep -A 25 "class ContentTier" bot/database/enums.py</verify>
  <done>ContentType and ContentTier enums exist with all values, display_name, and emoji properties</done>
</task>

<task type="auto">
  <name>Task 2: Create ContentSet model</name>
  <files>bot/database/models.py</files>
  <action>
    Add ContentSet model to bot/database/models.py after UserStreak model.

    Fields:
    - id: Integer, primary_key, autoincrement
    - name: String(200), nullable=False (e.g., "Pack Especial Febrero")
    - description: String(1000), nullable=True (longer for detailed descriptions)
    - file_ids: JSON, nullable=False, default=list (array of Telegram file_ids)
    - content_type: Enum(ContentType), nullable=False, default=ContentType.PHOTO_SET
    - tier: Enum(ContentTier), nullable=False, default=ContentTier.FREE
    - category: String(50), nullable=True (teaser, welcome, milestone, gift - optional categorization)
    - is_active: Boolean, nullable=False, default=True, index=True
    - created_at: DateTime, nullable=False, default=datetime.utcnow
    - updated_at: DateTime, nullable=False, default=datetime.utcnow, onupdate=datetime.utcnow

    Relationships:
    - shop_products: relationship to ShopProduct (back_populates="content_set")
    - user_accesses: relationship to UserContentAccess (back_populates="content_set")

    Indexes:
    - idx_content_set_tier_active: composite index on (tier, is_active)
    - idx_content_set_type_active: composite index on (content_type, is_active)

    Methods:
    - file_count property: returns len(self.file_ids)
    - __repr__: returns f"<ContentSet(id={self.id}, name='{self.name}', tier={self.tier}, files={self.file_count})>"

    Import ContentType and ContentTier at top of file.
  </action>
  <verify>grep -A 50 "class ContentSet" bot/database/models.py</verify>
  <done>ContentSet model exists with all fields, relationships, indexes, and methods</done>
</task>

<task type="auto">
  <name>Task 3: Create ShopProduct model</name>
  <files>bot/database/models.py</files>
  <action>
    Add ShopProduct model to bot/database/models.py after ContentSet model.

    Fields:
    - id: Integer, primary_key, autoincrement
    - name: String(200), nullable=False (display name in shop)
    - description: String(1000), nullable=True (marketing description)
    - content_set_id: Integer, ForeignKey("content_sets.id"), nullable=False
    - besitos_price: Integer, nullable=False (price in besitos for FREE users)
    - vip_discount_percentage: Integer, nullable=False, default=0 (0-100, e.g., 20 for 20% off)
    - vip_besitos_price: Integer, nullable=True (calculated price for VIP, or null to auto-calculate)
    - tier: Enum(ContentTier), nullable=False, default=ContentTier.FREE (who can buy this)
    - is_active: Boolean, nullable=False, default=True, index=True
    - sort_order: Integer, nullable=False, default=0 (for catalog ordering)
    - purchase_count: Integer, nullable=False, default=0 (analytics)
    - created_at: DateTime, nullable=False, default=datetime.utcnow
    - updated_at: DateTime, nullable=False, default=datetime.utcnow, onupdate=datetime.utcnow

    Relationships:
    - content_set: relationship to ContentSet (back_populates="shop_products")
    - purchase_records: relationship to UserContentAccess (back_populates="shop_product")

    Indexes:
    - idx_shop_product_active_tier: composite index on (is_active, tier)
    - idx_shop_product_price: index on besitos_price (for sorting)
    - idx_shop_product_sort: index on sort_order

    Properties:
    - vip_price: returns vip_besitos_price if set, otherwise calculates besitos_price * (100 - vip_discount_percentage) // 100
    - has_vip_discount: returns vip_discount_percentage > 0

    Methods:
    - __repr__: returns f"<ShopProduct(id={self.id}, name='{self.name}', price={self.besitos_price}, vip_price={self.vip_price})>"
  </action>
  <verify>grep -A 60 "class ShopProduct" bot/database/models.py</verify>
  <done>ShopProduct model exists with all fields, relationships, vip_price property, and indexes</done>
</task>

<task type="auto">
  <name>Task 4: Create UserContentAccess model</name>
  <files>bot/database/models.py</files>
  <action>
    Add UserContentAccess model to bot/database/models.py after ShopProduct model.

    This model tracks what content each user has received and how they got it.

    Fields:
    - id: Integer, primary_key, autoincrement
    - user_id: BigInteger, ForeignKey("users.user_id", ondelete="CASCADE"), nullable=False, index=True
    - content_set_id: Integer, ForeignKey("content_sets.id"), nullable=False, index=True
    - shop_product_id: Integer, ForeignKey("shop_products.id"), nullable=True (null if received via reward/gift)
    - access_type: String(50), nullable=False (shop_purchase, reward_claim, gift, narrative)
    - besitos_paid: Integer, nullable=True (how much they paid, null for free rewards)
    - is_active: Boolean, nullable=False, default=True (can they re-download?)
    - accessed_at: DateTime, nullable=False, default=datetime.utcnow (when first received)
    - expires_at: DateTime, nullable=True (optional expiration)
    - access_metadata: JSON, nullable=True (extra data: reward_id, gift_from_user_id, etc.)

    Relationships:
    - user: relationship to User (lazy="selectin")
    - content_set: relationship to ContentSet (back_populates="user_accesses", lazy="selectin")
    - shop_product: relationship to ShopProduct (back_populates="purchase_records", lazy="selectin")

    Indexes:
    - idx_user_content_access_user_content: unique index on (user_id, content_set_id) - one access record per user/content
    - idx_user_content_access_type: composite index on (user_id, access_type)
    - idx_user_content_access_date: composite index on (user_id, accessed_at)

    Properties:
    - is_purchased: returns access_type == "shop_purchase"
    - is_reward: returns access_type == "reward_claim"
    - is_expired: returns expires_at is not None and expires_at < datetime.utcnow()

    Methods:
    - __repr__: returns f"<UserContentAccess(id={self.id}, user={self.user_id}, content={self.content_set_id}, type={self.access_type})>"
  </action>
  <verify>grep -A 55 "class UserContentAccess" bot/database/models.py</verify>
  <done>UserContentAccess model exists with all fields, relationships, unique constraint on user+content, and helper properties</done>
</task>

</tasks>

<verification>
After all tasks complete:
1. Run: python -c "from bot.database.models import ContentSet, ShopProduct, UserContentAccess; print('Models OK')"
2. Run: python -c "from bot.database.enums import ContentType, ContentTier; print('Enums OK')"
3. Verify no circular imports: python -c "from bot.database import models; print('No circular imports')"
4. Check model relationships are bidirectional: ContentSet.shop_products, ShopProduct.content_set, etc.
</verification>

<success_criteria>
- ContentSet model stores file_ids as JSON array for Telegram file delivery
- ShopProduct has besitos_price, vip_discount_percentage, and vip_price property
- UserContentAccess has unique constraint on (user_id, content_set_id) preventing duplicate purchases
- ContentType enum supports photo_set, video, audio, mixed
- ContentTier enum supports free, vip, premium, gift
- All models have proper indexes for query performance
- Relationships allow: content_set.shop_products, product.content_set, user_access.content_set
</success_criteria>

<output>
After completion, create `.planning/phases/22-shop-system/22-01-SUMMARY.md`
</output>

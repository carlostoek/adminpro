---
phase: 22-shop-system
plan: 03
type: execute
wave: 3
depends_on: [22-02]
files_modified:
  - bot/services/container.py
  - bot/handlers/user/shop.py
autonomous: true

must_haves:
  truths:
    - ServiceContainer exposes shop property with lazy loading
    - Shop catalog handler shows vertical list with product names only
    - Shop product detail shows VIP/Free price differentiation with Lucien's voice
    - Purchase confirmation flow validates balance before charging
    - Insufficient balance redirects to "how to earn besitos" guidance
    - Content delivery sends file_ids to user chat after purchase
  artifacts:
    - path: bot/services/container.py
      provides: container.shop property
      contains: ["def shop(self)", "ShopService"]
    - path: bot/handlers/user/shop.py
      provides: Shop handlers (catalog, detail, purchase, history)
      min_lines: 350
      contains: ["async def shop_catalog_handler", "async def shop_product_detail_handler", "async def shop_purchase_handler"]
  key_links:
    - from: container.shop
      to: ShopService
      via: lazy loading property
    - from: shop handlers
      to: container.shop
      via: ServiceContainer injection
    - from: shop_purchase_handler
      to: WalletService
      via: container.wallet for balance checks
---

<objective>
Integrate ShopService into ServiceContainer and create user-facing shop handlers with VIP pricing display, purchase flow, and content delivery.

Purpose: Enable users to browse shop, view products with VIP/Free pricing, purchase with besitos, and receive content.
Output: container.shop property and bot/handlers/user/shop.py with catalog, detail, purchase, and history handlers.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md
@.planning/phases/22-shop-system/22-CONTEXT.md
@bot/services/container.py
@bot/services/shop.py

# Phase 19-21 established handler patterns with ServiceContainer injection
# Phase 6 user menu handlers show VIP/Free differentiation patterns
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add shop property to ServiceContainer</name>
  <files>bot/services/container.py</files>
  <action>
    Add ShopService lazy loading to ServiceContainer.

    1. In __init__, add:
       ```python
       self._shop_service = None
       ```

    2. Add shop property after streak property:
       ```python
       @property
       def shop(self):
           """
           Service de tienda (shop) para compra de contenido.

           Se carga lazy (solo en primer acceso).

           Returns:
               ShopService: Instancia del service

           Usage:
               # Browse catalog
               products, total = await container.shop.browse_catalog(user_role="VIP")

               # Purchase product
               success, code, result = await container.shop.purchase_product(
                   user_id=123, product_id=456, user_role="VIP"
               )

               # Get purchase history
               history, total = await container.shop.get_purchase_history(user_id=123)
           """
           if self._shop_service is None:
               from bot.services.shop import ShopService
               logger.debug("üîÑ Lazy loading: ShopService")
               # Inject wallet service for payments
               self._shop_service = ShopService(
                   self._session,
                   wallet_service=self.wallet
               )

           return self._shop_service
       ```

    3. In get_loaded_services(), add:
       ```python
       if self._shop_service is not None:
           loaded.append("shop")
       ```

    Follow exact same pattern as streak property (which also has wallet_service injection).
  </action>
  <verify>grep -A 30 "def shop(self)" bot/services/container.py && grep "shop" bot/services/container.py | grep -c "shop"</verify>
  <done>ServiceContainer has shop property with lazy loading and wallet service injection</done>
</task>

<task type="auto">
  <name>Task 2: Create shop handlers with catalog and detail views</name>
  <files>bot/handlers/user/shop.py</files>
  <action>
    Create bot/handlers/user/shop.py with shop handlers.

    Imports:
    - logging
    - aiogram (Router, F, types)
    - AsyncSession from sqlalchemy.ext.asyncio
    - ServiceContainer from bot.services.container
    - ContentTier from bot.database.enums
    - get_session from bot.database.engine

    Router setup:
    ```python
    logger = logging.getLogger(__name__)
    router = Router()
    ```

    Handler 1: shop_catalog_handler
    ```python
    @router.callback_query(F.data == "shop_catalog")
    @router.message(F.text == "üõçÔ∏è Tienda")
    async def shop_catalog_handler(
        event: types.Message | types.CallbackQuery,
        session: AsyncSession
    ):
        """
        Show shop catalog with product list (vertical layout).

        Display: Only product names, minimalistic
        Navigation: Prev/Next pagination
        Ordering: By price ascending
        """
    ```
    - Get user role from event.from_user.id via role_detection service
    - Get page from callback data or default to 1
    - Call container.shop.browse_catalog(user_role=role, page=page, per_page=5)
    - Build inline keyboard with product buttons (just names)
    - Add Prev/Next navigation if applicable
    - Show "Your balance: X besitos" in footer
    - Use Lucien's voice (üé©) for shop messages

    Handler 2: shop_product_detail_handler
    ```python
    @router.callback_query(F.data.startswith("shop_product:"))
    async def shop_product_detail_handler(
        callback: types.CallbackQuery,
        session: AsyncSession
    ):
        """
        Show product detail with VIP/Free price differentiation.

        VIP view: Strikethrough regular price, prominent VIP price with üíé
        Free view: Regular price prominent, VIP price attenuated
        """
    ```
    - Extract product_id from callback data
    - Get user role
    - Call container.shop.get_product_details(product_id, user_id)
    - Format message with Lucien's voice:
      * Title with emoji (üéÅ for content, üóùÔ∏è for VIP access)
      * Description
      * Price display based on role:
        - VIP: "~~100 besitos~~\nüíé 80 besitos" + "Privilegio aplicado a su membres√≠a VIP"
        - Free: "100 besitos\nüíé Precio VIP: 80 besitos" + "Este beneficio se aplica √∫nicamente a membres√≠as VIP"
      * File count
    - Buttons: "Comprar ahora" (if sufficient balance), "Volver al cat√°logo"
    - If insufficient balance: show "Saldo insuficiente" + "C√≥mo ganar besitos" button

    Include helper function build_price_display(product, user_role) for consistent formatting.
  </action>
  <verify>head -100 bot/handlers/user/shop.py && grep -c "async def" bot/handlers/user/shop.py</verify>
  <done>shop.py exists with shop_catalog_handler and shop_product_detail_handler using Lucien's voice</done>
</task>

<task type="auto">
  <name>Task 3: Implement purchase flow and content delivery handlers</name>
  <files>bot/handlers/user/shop.py</files>
  <action>
    Add purchase and content delivery handlers to shop.py.

    Handler 3: shop_purchase_handler
    ```python
    @router.callback_query(F.data.startswith("shop_buy:"))
    async def shop_purchase_handler(
        callback: types.CallbackQuery,
        session: AsyncSession
    ):
        """
        Handle purchase button click.

        Flow:
        1. Show confirmation with price summary
        2. On confirm: execute purchase
        3. Deliver content immediately
        4. Show success message with file count
        """
    ```
    - Extract product_id from callback data
    - Get user role and balance
    - Call container.shop.validate_purchase()
    - If already owned: show confirmation "Ya posee este contenido. ¬øDesea adquirirlo nuevamente?"
    - If insufficient funds: redirect to "C√≥mo ganar besitos" with daily gift button
    - If VIP-only and FREE user: show elegant exclusivity message with return button
    - On confirmation: call container.shop.purchase_product()
    - On success: deliver content via deliver_purchased_content()

    Handler 4: shop_confirm_purchase_handler
    ```python
    @router.callback_query(F.data.startswith("shop_confirm:"))
    async def shop_confirm_purchase_handler(
        callback: types.CallbackQuery,
        session: AsyncSession
    ):
        """Execute confirmed purchase."""
    ```
    - Call container.shop.purchase_product(force_repurchase=True if applicable)
    - If success: deliver content and show success message
    - If failure: show error with reason

    Helper function: deliver_purchased_content
    ```python
    async def deliver_purchased_content(
        bot,
        user_id: int,
        file_ids: List[str],
        content_type: str
    ):
        """
        Send content files to user chat.

        Uses bot.send_photo/video/audio for each file_id.
        Groups photos into media group if multiple photos.
        """
    ```
    - Send each file_id using appropriate method based on content_type
    - For photo_set with multiple files: use send_media_group
    - Add caption to first item: "üé© Aqu√≠ est√° su contenido adquirido."

    Handler 5: shop_history_handler
    ```python
    @router.callback_query(F.data == "shop_history")
    @router.message(F.text == "üìú Historial")
    async def shop_history_handler(
        event: types.Message | types.CallbackQuery,
        session: AsyncSession
    ):
        """Show purchase history with pagination."""
    ```
    - Call container.shop.get_purchase_history(user_id, page)
    - Format list with: product name, date, price paid, status
    - Use Lucien's voice: "üé© Su historial de adquisiciones..."
    - Show "No hay compras" message if empty

    Handler 6: shop_earn_besitos_handler
    ```python
    @router.callback_query(F.data == "shop_earn_besitos")
    async def shop_earn_besitos_handler(
        callback: types.CallbackQuery,
        session: AsyncSession
    ):
        """Redirect to besitos earning options when balance insufficient."""
    ```
    - Show options: "üéÅ Reclamar regalo diario", "üî• Reaccionar a contenido"
    - Link to existing handlers

    Add router to bot/handlers/user/__init__.py exports.
  </action>
  <verify>grep -A 20 "async def shop_purchase_handler" bot/handlers/user/shop.py && grep -A 15 "async def deliver_purchased_content" bot/handlers/user/shop.py</verify>
  <done>shop.py has purchase flow with confirmation, content delivery, history, and insufficient balance redirect</done>
</task>

</tasks>

<verification>
After all tasks complete:
1. Run: python -c "from bot.services.container import ServiceContainer; c = ServiceContainer.__dict__; print('shop' in [k for k in c if not k.startswith('_')])"
2. Run: python -c "from bot.handlers.user.shop import router; print('Shop router imports OK')"
3. Verify no syntax errors: python -m py_compile bot/handlers/user/shop.py
4. Check balance insufficient flow links to daily gift handler
</verification>

<success_criteria>
- ServiceContainer.shop property lazy-loads ShopService with wallet injection
- shop_catalog_handler shows vertical product list with Prev/Next pagination
- shop_product_detail_handler shows VIP prices with üíé and strikethrough formatting
- shop_purchase_handler validates balance and shows confirmation before charging
- Insufficient balance shows "C√≥mo ganar besitos" with daily gift button
- Content delivery sends actual Telegram files using file_ids
- Purchase history shows product names, dates, and prices paid
- All messages use Lucien's voice (üé©) with mayordomo tone
</success_criteria>

<output>
After completion, create `.planning/phases/22-shop-system/22-03-SUMMARY.md`
</output>

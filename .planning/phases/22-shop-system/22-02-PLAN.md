---
phase: 22-shop-system
plan: 02
type: execute
wave: 2
depends_on: [22-01]
files_modified:
  - bot/services/shop.py
autonomous: true

must_haves:
  truths:
    - ShopService can browse catalog with pagination (price ascending)
    - ShopService validates sufficient balance before purchase
    - ShopService performs atomic purchase (deduct besitos + create UserContentAccess)
    - ShopService delivers content by returning file_ids for Telegram delivery
    - ShopService tracks purchase history per user
    - ShopService detects already-owned content for repurchase confirmation
  artifacts:
    - path: bot/services/shop.py
      provides: ShopService with browse, purchase, deliver, history methods
      min_lines: 400
      contains: ["class ShopService", "async def browse_catalog", "async def purchase_product", "async def deliver_content", "async def get_purchase_history"]
  key_links:
    - from: ShopService
      to: WalletService
      via: spend_besitos() for atomic deduction
    - from: ShopService
      to: ContentSet
      via: file_ids for content delivery
    - from: ShopService
      to: UserContentAccess
      via: create access record on purchase
---

<objective>
Create ShopService with business logic for browsing catalog, purchasing products with atomic transactions, delivering content, and tracking purchase history.

Purpose: Enable users to browse and buy content with besitos, with VIP pricing and automatic content delivery.
Output: ShopService class with browse_catalog, purchase_product, deliver_content, get_purchase_history, and ownership checking methods.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md
@.planning/phases/22-shop-system/22-CONTEXT.md
@bot/services/wallet.py
@bot/database/models.py

# Phase 19 WalletService provides atomic spend_besitos() for purchases
# Phase 21 StreakService provides pattern for service initialization
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create ShopService foundation and catalog browsing</name>
  <files>bot/services/shop.py</files>
  <action>
    Create bot/services/shop.py with ShopService class.

    Imports:
    - logging, datetime, typing (List, Optional, Tuple, Dict, Any)
    - sqlalchemy (select, func)
    - AsyncSession from sqlalchemy.ext.asyncio
    - ContentSet, ShopProduct, UserContentAccess from bot.database.models
    - ContentType, ContentTier from bot.database.enums
    - TransactionType from bot.database.enums

    Class initialization:
    ```python
    def __init__(self, session: AsyncSession, wallet_service=None):
        self.session = session
        self.wallet_service = wallet_service
        self.logger = logging.getLogger(__name__)
    ```

    Method 1: browse_catalog
    ```python
    async def browse_catalog(
        self,
        user_role: str = "FREE",  # "FREE" or "VIP"
        page: int = 1,
        per_page: int = 5,
        tier: Optional[ContentTier] = None
    ) -> Tuple[List[ShopProduct], int]:
        """
        Browse shop catalog with pagination, ordered by price ascending.

        Args:
            user_role: "FREE" or "VIP" for price display context
            page: Page number (1-indexed)
            per_page: Items per page
            tier: Optional filter by content tier

        Returns:
            Tuple of (products list, total count)
        """
    ```
    - Query active products (is_active=True)
    - Order by besitos_price ASC (cheapest first)
    - Apply tier filter if provided
    - Apply pagination with offset/limit
    - Return products and total count

    Method 2: get_product_details
    ```python
    async def get_product_details(
        self,
        product_id: int,
        user_id: int
    ) -> Tuple[Optional[Dict[str, Any]], str]:
        """
        Get full product details with user-specific pricing.

        Returns:
            Tuple of (product dict or None, status message)
            Product dict includes:
            - product: ShopProduct object
            - content_set: ContentSet object
            - regular_price: int
            - vip_price: int
            - user_price: int (based on user's role)
            - is_owned: bool
            - file_count: int
        """
    ```
    - Get product by ID with content_set relationship
    - Check if user already owns this content via UserContentAccess
    - Calculate prices (regular, VIP, user-specific)
    - Return detailed dict or None if not found

    Include docstrings following Google Style pattern from WalletService.
  </action>
  <verify>grep -A 80 "class ShopService" bot/services/shop.py | head -100</verify>
  <done>ShopService class exists with __init__, browse_catalog, and get_product_details methods</done>
</task>

<task type="auto">
  <name>Task 2: Implement purchase validation and atomic transaction</name>
  <files>bot/services/shop.py</files>
  <action>
    Add purchase validation and atomic purchase methods to ShopService.

    Method 3: validate_purchase
    ```python
    async def validate_purchase(
        self,
        user_id: int,
        product_id: int,
        user_role: str = "FREE"
    ) -> Tuple[bool, str, Optional[Dict[str, Any]]]:
        """
        Validate if user can purchase product.

        Checks:
        1. Product exists and is active
        2. User has sufficient balance
        3. Product tier allows purchase (VIP-only check)

        Returns:
            Tuple of (can_purchase, reason_code, details_dict)
            reason_code: "ok", "product_not_found", "product_inactive",
                        "insufficient_funds", "vip_only", "already_owned"
            details_dict: includes product, price_to_pay, user_balance, is_owned
        """
    ```
    - Get product and verify active
    - Check tier restrictions (VIP-only products for FREE users)
    - Get user balance from wallet_service
    - Calculate price based on user role
    - Check if already owned
    - Return validation result with details

    Method 4: purchase_product
    ```python
    async def purchase_product(
        self,
        user_id: int,
        product_id: int,
        user_role: str = "FREE",
        force_repurchase: bool = False
    ) -> Tuple[bool, str, Optional[Dict[str, Any]]]:
        """
        Execute purchase: validate, deduct besitos, create access record.

        Args:
            user_id: User making purchase
            product_id: Product to buy
            user_role: "FREE" or "VIP"
            force_repurchase: If True, allow buying already-owned content

        Returns:
            Tuple of (success, status_code, result_dict)
            status_code: "success", "validation_failed", "payment_failed",
                        "already_owned", "vip_only"
            result_dict on success:
            - product: ShopProduct
            - content_set: ContentSet
            - price_paid: int
            - file_ids: List[str]
            - access_record: UserContentAccess
            - is_repurchase: bool
        """
    ```
    - Call validate_purchase
    - If already owned and not force_repurchase, return "already_owned"
    - Call wallet_service.spend_besitos() with TransactionType.SPEND_SHOP
    - If payment succeeds, create UserContentAccess record
    - Update product.purchase_count
    - Return success with all details for content delivery

    Method 5: check_ownership
    ```python
    async def check_ownership(
        self,
        user_id: int,
        content_set_id: int
    ) -> bool:
        """Check if user already owns specific content."""
    ```
    - Query UserContentAccess for user_id + content_set_id
    - Return True if active record exists

    Follow atomic transaction pattern from WalletService.spend_besitos().
    Log all operations with appropriate levels (info for success, warning for validation failures).
  </action>
  <verify>grep -A 50 "async def purchase_product" bot/services/shop.py</verify>
  <done>purchase_product method validates, deducts besitos atomically, creates UserContentAccess, and handles repurchase logic</done>
</task>

<task type="auto">
  <name>Task 3: Implement content delivery and purchase history</name>
  <files>bot/services/shop.py</files>
  <action>
    Add content delivery and purchase history methods to ShopService.

    Method 6: deliver_content
    ```python
    async def deliver_content(
        self,
        user_id: int,
        content_set_id: int
    ) -> Tuple[bool, str, Optional[List[str]]]:
        """
        Get file_ids for content delivery to user.

        Used by handlers to send actual Telegram files to user.
        Also updates last_accessed_at timestamp.

        Args:
            user_id: User requesting content
            content_set_id: Content to deliver

        Returns:
            Tuple of (success, message, file_ids list)
            file_ids: List of Telegram file_ids to send
        """
    ```
    - Verify user has access via UserContentAccess
    - Get ContentSet by ID
    - Return file_ids list for handler to send via bot
    - Log content delivery

    Method 7: get_purchase_history
    ```python
    async def get_purchase_history(
        self,
        user_id: int,
        page: int = 1,
        per_page: int = 10
    ) -> Tuple[List[Dict[str, Any]], int]:
        """
        Get paginated purchase history for user.

        Returns:
            Tuple of (purchases list, total count)
            Each purchase dict includes:
            - id: access record ID
            - product_name: str
            - content_set_name: str
            - besitos_paid: int
            - accessed_at: datetime
            - is_active: bool
            - file_count: int
        """
    ```
    - Query UserContentAccess for user_id where access_type="shop_purchase"
    - Join with ShopProduct and ContentSet for names
    - Order by accessed_at DESC (newest first)
    - Apply pagination
    - Return formatted list with all details

    Method 8: get_user_shop_stats
    ```python
    async def get_user_shop_stats(
        self,
        user_id: int
    ) -> Dict[str, Any]:
        """
        Get shop-related statistics for user.

        Returns:
            Dict with:
            - total_purchases: int
            - total_besitos_spent: int
            - unique_content_owned: int
            - last_purchase_at: Optional[datetime]
        """
    ```
    - Aggregate data from UserContentAccess
    - Return summary statistics

    Add module-level docstring explaining ShopService responsibilities.
    Follow patterns from WalletService for error handling and logging.
  </action>
  <verify>grep -A 40 "async def deliver_content" bot/services/shop.py && grep -A 30 "async def get_purchase_history" bot/services/shop.py</verify>
  <done>deliver_content returns file_ids for Telegram delivery, get_purchase_history returns formatted purchase history with pagination</done>
</task>

</tasks>

<verification>
After all tasks complete:
1. Run: python -c "from bot.services.shop import ShopService; print('ShopService imports OK')"
2. Verify no syntax errors: python -m py_compile bot/services/shop.py
3. Check method signatures match expected usage in handlers
</verification>

<success_criteria>
- ShopService.browse_catalog returns products ordered by price ascending with pagination
- ShopService.purchase_product validates balance, deducts besitos atomically, creates UserContentAccess
- ShopService.deliver_content returns file_ids for Telegram bot to send
- ShopService.get_purchase_history returns formatted history with product names and prices paid
- ShopService.check_ownership prevents duplicate purchases without force_repurchase
- All methods have proper error handling and logging
- Service follows same patterns as WalletService and StreakService
</success_criteria>

<output>
After completion, create `.planning/phases/22-shop-system/22-02-SUMMARY.md`
</output>

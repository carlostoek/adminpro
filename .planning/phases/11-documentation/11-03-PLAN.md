---
phase: 11-documentation
plan: 03
type: execute
wave: 1
depends_on: []
files_modified:
  - docs/INTEGRATION_GUIDE.md
autonomous: true

must_haves:
  truths:
    - "INTEGRATION_GUIDE.md exists with step-by-step guide for adding menu options"
    - "Guide covers creating message providers, adding keyboard buttons, and handling callbacks"
    - "Code examples are complete and runnable"
    - "Common pitfalls are documented with solutions"
    - "Testing strategies are explained"
  artifacts:
    - path: "docs/INTEGRATION_GUIDE.md"
      provides: "Integration guide for menu system"
      min_lines: 250
      contains: ["Creating Message Provider", "Adding Menu Option", "Handling Callbacks", "Testing", "Pitfalls"]
  key_links:
    - from: "docs/INTEGRATION_GUIDE.md"
      to: "bot/services/message/base.py"
      via: "BaseMessageProvider reference"
      pattern: "Extend BaseMessageProvider"
    - from: "docs/INTEGRATION_GUIDE.md"
      to: "bot/handlers/**/*.py"
      via: "Handler implementation examples"
      pattern: "Callback handler examples"
---

<objective>
Create practical integration guide for adding new menu options to the menu system.

Purpose: Provide developers with step-by-step instructions for extending the menu system with new options, including message providers, keyboard buttons, and callback handlers.
Output: 250+ line guide with complete code examples and common pitfalls.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@docs/MENU_SYSTEM.md
@docs/guia-estilo.md

# Existing integration examples
@bot/services/message/admin_content.py
@bot/handlers/admin/content.py
@bot/services/message/user_menu.py
@bot/handlers/vip/menu.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create INTEGRATION_GUIDE.md with Step-by-Step Process</name>
  <files>
    docs/INTEGRATION_GUIDE.md
  </files>
  <action>
    Create comprehensive integration guide for adding menu options:

    **File structure:**
    ```markdown
    # Gu√≠a de Integraci√≥n - Sistema de Men√∫s

    ## Overview
    - Purpose of this guide
    - What you'll learn
    - Prerequisites

    ## Quick Start Checklist
    - Step-by-step summary
    - Estimated time per step

    ## Step 1: Define Your Menu Option
    - What should it do?
    - Which role(s) can access it?
    - What data does it need?

    ## Step 2: Create Message Provider
    - Extend BaseMessageProvider
    - Implement message methods
    - Follow Lucien's voice
    - Add keyboard generation

    ## Step 3: Register in ServiceContainer
    - Add lazy-loaded property
    - Update __init__.py exports

    ## Step 4: Create Handler
    - Register router
    - Add command/message handler
    - Add callback handlers
    - Apply middlewares

    ## Step 5: Wire It Up
    - Add to main menu keyboard
    - Test the flow
    - Handle edge cases

    ## Complete Example
    - Full working example from start to finish
    - All code files included
    - Copy-paste runnable

    ## Common Pitfalls
    - Pitfall 1: FSM state leaks
    - Pitfall 2: Missing callback.answer()
    - Pitfall 3: Non-async operations
    - Pitfall 4: Forgotten imports
    - Solutions for each

    ## Testing Strategies
    - Unit testing message providers
    - Testing keyboard interactions
    - Mocking services
    - End-to-end testing

    ## Best Practices
    - Voice consistency
    - Keyboard organization
    - Error handling
    - Logging
    ```

    **Content requirements:**
    - Write in Spanish (consistent with project)
    - Include complete code examples (not snippets)
    - Show actual file paths and locations
    - Provide copy-paste runnable examples
    - Link to MENU_SYSTEM.md for architecture details
    - Include common mistakes and how to avoid them

    **Complete Example section should include:**
    - Full message provider class
    - Full handler implementation
    - ServiceContainer registration
    - Router registration
    - Testing code

    **Write in Spanish**
  </action>
  <verify>
    wc -l docs/INTEGRATION_GUIDE.md
    grep -c "##" docs/INTEGRATION_GUIDE.md
  </verify>
  <done>
    INTEGRATION_GUIDE.md exists with:
    - 250+ lines of documentation
    - Step-by-step process for adding menu options
    - Complete code examples
    - Common pitfalls documented
    - Testing strategies explained
  </done>
</task>

<task type="auto">
  <name>Task 2: Document Message Provider Creation Process</name>
  <files>
    docs/INTEGRATION_GUIDE.md
  </files>
  <action>
    Add detailed message provider creation documentation to INTEGRATION_GUIDE.md:

    **Section: Paso 2 - Crear Message Provider**
    ```markdown
    ## Paso 2: Crear Message Provider

    ### File Location
    Create file in: `bot/services/message/`

    Naming convention:
    - Admin menus: `admin_{feature}.py`
    - User menus: `user_{feature}.py`
    - Shared: `common_{feature}.py`

    ### Basic Structure
    ```python
    # bot/services/message/admin_myfeature.py
    from typing import Tuple
    from aiogram.types import InlineKeyboardMarkup
    from bot.services.message.base import BaseMessageProvider
    from bot.services.message.common import CommonMessages

    class AdminMyFeatureMessages(BaseMessageProvider):
        """Mensajes para gesti√≥n de MyFeature.

        Voice Pattern:
            - Collaborative with admin
            - Uses "custodio" terminology
            - System status updates

        Example:
            >>> provider = AdminMyFeatureMessages()
            >>> text, keyboard = provider.list_view(items=[...])
        """

        def __init__(self):
            super().__init__()
            self.common = CommonMessages()

        def list_view(self, items: list, page: int = 1) -> Tuple[str, InlineKeyboardMarkup]:
            """Generate list view message.

            Args:
                items: List of items to display
                page: Current page number

            Returns:
                Tuple of (message_text, keyboard_markup)
            """
            # Generate text with Lucien's voice
            if not items:
                return self.common.empty_list(), self._empty_keyboard()

            text = self._format_items(items, page)
            keyboard = self._list_keyboard(items, page)

            return text, keyboard

        def _format_items(self, items: list, page: int) -> str:
            """Format items list with Lucien's voice."""
            variations = [
                f"Custodio, aqu√≠ tienes los elementos disponibles (p√°gina {page}):",
                f"Lista actualizada, custodio. P√°gina {page} de tu inventario.",
            ]
            # Use weighted selection
            # ... (implementation)
    ```
    ```

    **Section: Keyboard Generation**
    ```markdown
    ### Generaci√≥n de Keyboards

    Usar InlineKeyboardBuilder de aiogram:

    ```python
    from aiogram.utils.keyboard import InlineKeyboardBuilder
    from aiogram.types import InlineKeyboardButton

    def _list_keyboard(self, items: list, page: int) -> InlineKeyboardMarkup:
        builder = InlineKeyboardBuilder()

        # Action buttons per item
        for item in items:
            builder.button(
                text=f"üì¶ {item['name']}",
                callback_data=f"admin:myfeature:view:{item['id']}"
            )

        # Navigation buttons
        builder.row(
            InlineKeyboardButton(text="‚¨ÖÔ∏è", callback_data=f"admin:myfeature:page:{page-1}"),
            InlineKeyboardButton(text="‚û°Ô∏è", callback_data=f"admin:myfeature:page:{page+1}"),
        )
        builder.row(
            InlineKeyboardButton(text="üîô Volver", callback_data="admin:menu:back"),
            InlineKeyboardButton(text="‚ùå Salir", callback_data="admin:menu:exit"),
        )

        return builder.as_markup()
    ```
    ```

    **Add to existing INTEGRATION_GUIDE.md file**
  </action>
  <verify>
    grep -c "Message Provider" docs/INTEGRATION_GUIDE.md
    grep -c "Keyboard Generation" docs/INTEGRATION_GUIDE.md
  </verify>
  <done>
    Message provider section includes:
    - File location and naming conventions
    - Basic class structure
    - Complete code example
    - Keyboard generation pattern
    - Voice integration guidelines
  </done>
</task>

<task type="auto">
  <name>Task 3: Document Handler Creation and Callback Routing</name>
  <files>
    docs/INTEGRATION_GUIDE.md
  </files>
  <action>
    Add handler creation and callback routing documentation to INTEGRATION_GUIDE.md:

    **Section: Paso 4 - Crear Handler**
    ```markdown
    ## Paso 4: Crear Handler

    ### File Location
    Create file in: `bot/handlers/admin/` (or user/, vip/, free/)

    ### Basic Structure
    ```python
    # bot/handlers/admin/myfeature.py
    from aiogram import Router, F, types
    from aiogram.filters import Command
    from aiogram.fsm.context import FSMContext

    from bot.database.models import UserRole
    from bot.services import ServiceContainer
    from bot.middlewares.database import DatabaseMiddleware
    from bot.services.message.admin_myfeature import AdminMyFeatureMessages

    # Create router
    myfeature_router = Router()

    # Apply middlewares
    myfeature_router.message.middleware(DatabaseMiddleware())
    myfeature_router.callback_query.middleware(DatabaseMiddleware())

    @myfeature_router.message(Command("myfeature"))
    async def cmd_myfeature(
        message: types.Message,
        session: AsyncSession,
        user_role: UserRole
    ):
        """Handle /myfeature command."""
        # Only admin can access
        if user_role != UserRole.ADMIN:
            await message.answer("‚ùå Solo administradores.")
            return

        # Get services
        container = ServiceContainer(session, message.bot)
        messages = AdminMyFeatureMessages()

        # Get data and show menu
        items = await container.myfeature.get_all()
        text, keyboard = messages.list_view(items)

        await message.answer(text, reply_markup=keyboard)

    @myfeature_router.callback_query(F.data.startswith("admin:myfeature:view:"))
    async def callback_view_item(
        callback: types.CallbackQuery,
        session: AsyncSession
    ):
        """Handle view item callback."""
        await callback.answer()

        # Parse callback data
        parts = callback.data.split(":")
        item_id = int(parts[3])

        # Get services and data
        container = ServiceContainer(session, callback.bot)
        messages = AdminMyFeatureMessages()

        item = await container.myfeature.get_by_id(item_id)
        if not item:
            await callback.message.edit_text("‚ùå Elemento no encontrado")
            return

        text, keyboard = messages.detail_view(item)
        await callback.message.edit_text(text, reply_markup=keyboard)
    ```
    ```

    **Section: Registrar Router en main.py**
    ```markdown
    ### Registro del Router

    Agregar a `main.py`:

    ```python
    from bot.handlers.admin.myfeature import myfeature_router

    # Registrar router
    dp.include_router(myfeature_router)
    ```

    **Importante:** El orden de registro importa.
    Los routers m√°s espec√≠ficos deben registrarse antes
    de los routers generales.
    ```

    **Section: Callback Data Patterns**
    ```markdown
    ### Patrones de Callback Data

    Format: `{scope}:{feature}:{action}:{id}`

    Examples:
    - `admin:myfeature:list` - List items
    - `admin:myfeature:view:123` - View item 123
    - `admin:myfeature:edit:123:name` - Edit name of item 123
    - `admin:myfeature:delete:123` - Delete item 123

    Parsing:
    ```python
    parts = callback.data.split(":")
    # parts[0] = "admin" (scope)
    # parts[1] = "myfeature" (feature)
    # parts[2] = "view" (action)
    # parts[3] = "123" (id)
    ```
    ```

    **Add to existing INTEGRATION_GUIDE.md file**
  </action>
  <verify>
    grep -c "Handler" docs/INTEGRATION_GUIDE.md
    grep -c "Callback" docs/INTEGRATION_GUIDE.md
  </verify>
  <done>
    Handler section includes:
    - File location and structure
    - Complete handler code example
    - Router registration instructions
    - Callback data patterns
    - Middleware application
  </done>
</task>

</tasks>

<verification>
After completion, verify:
1. INTEGRATION_GUIDE.md exists and is 250+ lines
2. All steps documented (Define, Create Provider, Register, Create Handler, Wire Up)
3. Complete example is copy-paste runnable
4. Common pitfalls section includes solutions
5. Testing strategies explained
6. Written in Spanish
</verification>

<success_criteria>
1. File exists with 250+ lines
2. grep -c "##" returns 8+ section headers
3. Code examples are complete (not snippets)
4. Developer can add menu option following guide
5. All file paths and locations specified
</success_criteria>

<output>
After completion, create `.planning/phases/11-documentation/11-03-SUMMARY.md`
</output>

---
phase: 09-user-management
plan: 01
type: execute
wave: 1
depends_on: [08-04]
files_modified: [bot/services/user_management.py, bot/services/__init__.py, bot/services/container.py]
autonomous: true

must_haves:
  truths:
    - "UserManagementService existe con m√©todos para gestionar usuarios"
    - "UserManagementService tiene m√©todo para cambiar rol de usuario con auditor√≠a"
    - "UserManagementService tiene m√©todo para bloquear/desbloquear usuario"
    - "UserManagementService tiene m√©todo para expulsar usuario de canales"
    - "UserManagementService tiene m√©todo para obtener informaci√≥n detallada de usuario"
    - "UserManagementService tiene validaci√≥n de permisos (super admin, self-action prevention)"
    - "UserManagementService integrado en ServiceContainer con lazy loading"
  artifacts:
    - path: "bot/services/user_management.py"
      provides: "UserManagementService with user info, role change, block, expel operations with permission validation"
      min_lines: 400
      exports: ["get_user_info", "change_user_role", "block_user", "unblock_user", "expel_user_from_channels", "get_user_list", "is_super_admin", "_can_modify_user"]
  key_links:
    - from: "bot/handlers/admin/users.py"
      to: "bot/services/user_management.py"
      via: "ServiceContainer.user_management"
      pattern: "await container\\.user_management\\."
    - from: "ServiceContainer"
      to: "UserManagementService"
      via: "lazy loading property"
      pattern: "@property\\s+def user_management"
---

<objective>
Create UserManagementService with user info retrieval, role changes, block/unblock, expel from channels, permission validation (super admin only for admin-on-admin, self-action prevention), and user list functionality following established service pattern (SubscriptionService, InterestService).

Purpose: Provide centralized service layer for user management operations with permission boundaries, audit logging via RoleChangeService, and channel operations via ChannelService. Enable admin interface for viewing detailed user profiles and taking administrative actions.
Output: UserManagementService class with 10+ async methods, registered in ServiceContainer for lazy loading.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/09-user-management/09-CONTEXT.md

@bot/services/subscription.py
@bot/services/interest.py
@bot/services/channel.py
@bot/services/role_change.py
@bot/services/container.py
@bot/database/models.py (User, VIPSubscriber, UserRoleChangeLog models)
@config.py (Config.ADMIN_USER_IDS)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create UserManagementService class with core methods</name>
  <files>bot/services/user_management.py</files>
  <action>
Create bot/services/user_management.py with UserManagementService class:

1. File structure:
```python
"""
User Management Service - Gesti√≥n de usuarios y acciones administrativas.

Servicio para gestionar usuarios del sistema: ver informaci√≥n, cambiar roles,
bloquear/desbloquear, expulsar de canales, con validaci√≥n de permisos y
auditor√≠a de cambios.
"""
import logging
from datetime import datetime
from typing import List, Optional, Tuple, Dict, Any
from sqlalchemy import select, and_, or_, desc
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy.orm import selectinload

from bot.database.models import User, VIPSubscriber, UserRoleChangeLog
from bot.database.enums import UserRole, RoleChangeReason
from bot.services.role_change import RoleChangeService

logger = logging.getLogger(__name__)


class UserManagementService:
    """
    Servicio para gesti√≥n de usuarios y acciones administrativas.

    Responsabilidades:
    - Obtener informaci√≥n detallada de usuario (rol, suscripci√≥n, historial)
    - Cambiar rol de usuario con auditor√≠a
    - Bloquear/desbloquear usuario
    - Expulsar usuario de canales (VIP/Free)
    - Listar usuarios con filtros y paginaci√≥n
    - Validar permisos (super admin, self-action prevention)

    Permisos:
    - Super admin: Primer admin en Config.ADMIN_USER_IDS
    - Admin-on-admin: Solo super admin puede modificar otros admins
    - Self-actions: Admins no pueden bloquearse/expulsarse a s√≠ mismos

    Patr√≥n de auditor√≠a:
    - Todos los cambios de rol se registran en UserRoleChangeLog
    - Cambios por admin incluyen changed_by (user_id del admin)
    - Cambios autom√°ticos usan changed_by=0 (SYSTEM)
    """

    def __init__(self, session: AsyncSession, bot):
        """
        Inicializar UserManagementService.

        Args:
            session: Sesi√≥n de base de datos SQLAlchemy async
            bot: Instancia del bot de Telegram
        """
        self.session = session
        self.bot = bot
        logger.debug("‚úÖ UserManagementService inicializado")
```

2. Required methods:

**a. get_user_info(user_id) -> Dict[str, Any]:**
```python
async def get_user_info(self, user_id: int) -> Optional[Dict[str, Any]]:
    """
    Obtiene informaci√≥n detallada de un usuario.

    Args:
        user_id: ID del usuario de Telegram

    Returns:
        Diccionario con informaci√≥n del usuario o None si no existe:
        - user_id: ID del usuario
        - username: Username (puede ser None)
        - first_name: Nombre
        - last_name: Apellido (puede ser None)
        - role: Rol actual (UserRole enum)
        - created_at: Fecha de registro
        - updated_at: √öltima actualizaci√≥n
        - vip_subscription: Dict con info de suscripci√≥n VIP si existe
        - interests_count: N√∫mero de intereses registrados
        - role_changes: Lista de cambios de rol (√∫ltimos 5)
    """
    try:
        # Get user with relationships
        stmt = select(User).where(User.user_id == user_id)
        result = await self.session.execute(stmt)
        user = result.scalar_one_or_none()

        if not user:
            return None

        # Get VIP subscription if exists
        vip_sub = None
        if user.role == UserRole.VIP:
            vip_stmt = select(VIPSubscriber).where(
                VIPSubscriber.user_id == user_id
            ).order_by(desc(VIPSubscriber.created_at)).first()
            vip_result = await self.session.execute(vip_stmt)
            vip_sub = vip_result.scalar_one_or_none()

        # Get interests count
        from bot.database.models import UserInterest
        interest_stmt = select(UserInterest).where(
            UserInterest.user_id == user_id
        )
        interest_result = await self.session.execute(interest_stmt)
        interests_count = len(interest_result.scalars().all())

        # Get role changes (last 5)
        changes_stmt = select(UserRoleChangeLog).where(
            UserRoleChangeLog.user_id == user_id
        ).order_by(desc(UserRoleChangeLog.changed_at)).limit(5)
        changes_result = await self.session.execute(changes_stmt)
        role_changes = changes_result.scalars().all()

        return {
            "user_id": user.user_id,
            "username": user.username,
            "first_name": user.first_name,
            "last_name": user.last_name,
            "role": user.role,
            "created_at": user.created_at,
            "updated_at": user.updated_at,
            "vip_subscription": {
                "expires_at": vip_sub.expires_at,
                "is_active": vip_sub.expires_at > datetime.utcnow() if vip_sub else False,
                "token_used": vip_sub.token_used if vip_sub else None
            } if vip_sub else None,
            "interests_count": interests_count,
            "role_changes": [
                {
                    "from_role": change.from_role,
                    "to_role": change.to_role,
                    "reason": change.reason,
                    "changed_by": change.changed_by,
                    "changed_at": change.changed_at
                }
                for change in role_changes
            ]
        }

    except Exception as e:
        logger.error(f"Error getting user info for {user_id}: {e}", exc_info=True)
        return None
```

**b. change_user_role(user_id, new_role, changed_by) -> Tuple[bool, str]:**
```python
async def change_user_role(
    self,
    user_id: int,
    new_role: UserRole,
    changed_by: int
) -> Tuple[bool, str]:
    """
    Cambia el rol de un usuario con auditor√≠a.

    Args:
        user_id: ID del usuario a modificar
        new_role: Nuevo rol (UserRole enum)
        changed_by: ID del admin que realiza el cambio

    Returns:
        Tupla (success, message):
        - success: True si se cambi√≥ correctamente
        - message: Mensaje de √©xito o error
    """
    try:
        # Validate permissions first
        can_modify, error_msg = await self._can_modify_user(
            target_user_id=user_id,
            admin_user_id=changed_by
        )

        if not can_modify:
            return (False, error_msg)

        # Get user
        stmt = select(User).where(User.user_id == user_id)
        result = await self.session.execute(stmt)
        user = result.scalar_one_or_none()

        if not user:
            return (False, "Usuario no encontrado")

        # Store old role
        old_role = user.role

        # Check if same role
        if old_role == new_role:
            return (True, f"El usuario ya tiene el rol {new_role.value}")

        # Update role
        user.role = new_role
        user.updated_at = datetime.utcnow()

        # Log change via RoleChangeService
        role_change_service = RoleChangeService(self.session)
        await role_change_service.log_role_change(
            user_id=user_id,
            from_role=old_role,
            to_role=new_role,
            reason=RoleChangeReason.ADMIN_ACTION,
            changed_by=changed_by
        )

        logger.info(
            f"Role changed: user {user_id} {old_role.value} -> {new_role.value} "
            f"by admin {changed_by}"
        )

        return (True, f"Rol cambiado de {old_role.value} a {new_role.value}")

    except Exception as e:
        logger.error(
            f"Error changing role for user {user_id} to {new_role.value}: {e}",
            exc_info=True
        )
        return (False, f"Error al cambiar rol: {str(e)}")
```

**c. block_user(user_id, blocked_by, reason) -> Tuple[bool, str]:**
```python
async def block_user(
    self,
    user_id: int,
    blocked_by: int,
    reason: Optional[str] = None
) -> Tuple[bool, str]:
    """
    Bloquea a un usuario (impide usar el bot).

    Nota: Implementaci√≥n futura requerir√° agregar campo 'is_blocked' a User model.
    Por ahora, esta funci√≥n es un placeholder que retorna error.

    Args:
        user_id: ID del usuario a bloquear
        blocked_by: ID del admin que bloquea
        reason: Raz√≥n del bloqueo (opcional)

    Returns:
        Tupla (success, message)
    """
    # Validate permissions
    can_modify, error_msg = await self._can_modify_user(
        target_user_id=user_id,
        admin_user_id=blocked_by
    )

    if not can_modify:
        return (False, error_msg)

    # TODO: Implement when User.is_blocked field is added
    # For now, return placeholder message
    logger.warning(f"Block user called for {user_id} by {blocked_by} - not yet implemented")
    return (False, "Funci√≥n de bloqueo ser√° implementada en pr√≥xima versi√≥n (requiere migraci√≥n de BD)")
```

**d. unblock_user(user_id, unblocked_by) -> Tuple[bool, str]:**
```python
async def unblock_user(
    self,
    user_id: int,
    unblocked_by: int
) -> Tuple[bool, str]:
    """
    Desbloquea a un usuario.

    Nota: Implementaci√≥n futura requerir√° agregar campo 'is_blocked' a User model.
    Por ahora, esta funci√≥n es un placeholder que retorna error.

    Args:
        user_id: ID del usuario a desbloquear
        unblocked_by: ID del admin que desbloquea

    Returns:
        Tupla (success, message)
    """
    # Validate permissions
    can_modify, error_msg = await self._can_modify_user(
        target_user_id=user_id,
        admin_user_id=unblocked_by
    )

    if not can_modify:
        return (False, error_msg)

    # TODO: Implement when User.is_blocked field is added
    logger.warning(f"Unblock user called for {user_id} by {unblocked_by} - not yet implemented")
    return (False, "Funci√≥n de desbloqueo ser√° implementada en pr√≥xima versi√≥n (requiere migraci√≥n de BD)")
```

**e. expel_user_from_channels(user_id, expelled_by) -> Tuple[bool, str]:**
```python
async def expel_user_from_channels(
    self,
    user_id: int,
    expelled_by: int
) -> Tuple[bool, str]:
    """
    Expulsa a un usuario de los canales VIP y Free.

    Args:
        user_id: ID del usuario a expulsar
        expelled_by: ID del admin que expulsa

    Returns:
        Tupla (success, message):
        - success: True si se expuls√≥ correctamente
        - message: Mensaje con resultado (canales de los que se expuls√≥)
    """
    try:
        # Validate permissions
        can_modify, error_msg = await self._can_modify_user(
            target_user_id=user_id,
            admin_user_id=expelled_by
        )

        if not can_modify:
            return (False, error_msg)

        from bot.services.channel import ChannelService
        channel_service = ChannelService(self.session, self.bot)

        expelled_from = []

        # Try to expel from VIP channel
        vip_channel_id = await channel_service.get_vip_channel_id()
        if vip_channel_id:
            try:
                await self.bot.ban_chat_member(
                    chat_id=vip_channel_id,
                    user_id=user_id
                )
                expelled_from.append("VIP")
                logger.info(f"User {user_id} expelled from VIP channel by admin {expelled_by}")
            except Exception as e:
                logger.warning(f"Could not expel user {user_id} from VIP channel: {e}")

        # Try to expel from Free channel
        free_channel_id = await channel_service.get_free_channel_id()
        if free_channel_id:
            try:
                await self.bot.ban_chat_member(
                    chat_id=free_channel_id,
                    user_id=user_id
                )
                expelled_from.append("Free")
                logger.info(f"User {user_id} expelled from Free channel by admin {expelled_by}")
            except Exception as e:
                logger.warning(f"Could not expel user {user_id} from Free channel: {e}")

        if not expelled_from:
            return (False, "No se pudo expulsar al usuario de ning√∫n canal (puede que no sea miembro)")

        channels_str = ", ".join(expelled_from)
        return (True, f"Usuario expulsado de canales: {channels_str}")

    except Exception as e:
        logger.error(f"Error expelling user {user_id}: {e}", exc_info=True)
        return (False, f"Error al expulsar usuario: {str(e)}")
```

**f. get_user_list(role, limit, offset) -> Tuple[List[User], int]:**
```python
async def get_user_list(
    self,
    role: Optional[UserRole] = None,
    limit: int = 20,
    offset: int = 0,
    sort_newest_first: bool = True
) -> Tuple[List[User], int]:
    """
    Obtiene lista de usuarios con filtros y paginaci√≥n.

    Args:
        role: Filtrar por rol (None = todos)
        limit: M√°ximo de registros a retornar
        offset: Registro inicial (para paginaci√≥n)
        sort_newest_first: True para m√°s recientes primero

    Returns:
        Tupla (users, total_count):
        - users: Lista de objetos User
        - total_count: Total de registros (sin paginar)
    """
    try:
        # Build base query
        stmt = select(User)

        # Apply filter
        if role is not None:
            stmt = stmt.where(User.role == role)

        # Count total
        count_stmt = select(User.__table__.c.user_id)
        if role is not None:
            count_stmt = count_stmt.where(User.role == role)
        count_result = await self.session.execute(count_stmt)
        total_count = len(count_result.all())

        # Apply sorting
        if sort_newest_first:
            stmt = stmt.order_by(desc(User.created_at))
        else:
            stmt = stmt.order_by(User.created_at)

        # Apply pagination
        stmt = stmt.limit(limit).offset(offset)

        # Execute
        result = await self.session.execute(stmt)
        users = result.scalars().all()

        logger.debug(
            f"Retrieved {len(users)} users (total: {total_count}, role: {role})"
        )

        return (users, total_count)

    except Exception as e:
        logger.error(f"Error getting user list: {e}", exc_info=True)
        return ([], 0)
```

**g. search_users(query, limit) -> List[User]:**
```python
async def search_users(
    self,
    query: str,
    limit: int = 10
) -> List[User]:
    """
    Busca usuarios por username o user_id.

    Args:
        query: Query de b√∫squeda (username o user_id como string)
        limit: M√°ximo de resultados

    Returns:
        Lista de usuarios coincidentes
    """
    try:
        # Try to parse as user_id
        try:
            user_id = int(query)
            id_stmt = select(User).where(User.user_id == user_id)
            id_result = await self.session.execute(id_stmt)
            user = id_result.scalar_one_or_none()
            if user:
                return [user]
        except ValueError:
            pass  # Not a number, search by username

        # Search by username
        username_query = f"%{query}%"
        stmt = select(User).where(
            User.username.ilike(username_query)
        ).limit(limit)

        result = await self.session.execute(stmt)
        return result.scalars().all()

    except Exception as e:
        logger.error(f"Error searching users with query '{query}': {e}", exc_info=True)
        return []
```

**h. is_super_admin(user_id) -> bool:**
```python
def is_super_admin(self, user_id: int) -> bool:
    """
    Verifica si un usuario es el super admin.

    El super admin es el primer admin en Config.ADMIN_USER_IDS.

    Args:
        user_id: ID del usuario a verificar

    Returns:
        True si es el super admin
    """
    from config import Config

    if not Config.ADMIN_USER_IDS:
        return False

    return user_id == Config.ADMIN_USER_IDS[0]
```

**i. _can_modify_user(target_user_id, admin_user_id) -> Tuple[bool, Optional[str]]:**
```python
async def _can_modify_user(
    self,
    target_user_id: int,
    admin_user_id: int
) -> Tuple[bool, Optional[str]]:
    """
    Valida si un admin puede modificar a un usuario.

    Reglas:
    1. Admin no puede modificarse a s√≠ mismo
    2. Solo super admin puede modificar otros admins

    Args:
        target_user_id: ID del usuario a modificar
        admin_user_id: ID del admin que intenta modificar

    Returns:
        Tupla (can_modify, error_message):
        - can_modify: True si tiene permiso
        - error_message: Mensaje de error si no tiene permiso
    """
    # Self-action prevention
    if target_user_id == admin_user_id:
        return (False, "No puedes realizar esta acci√≥n sobre ti mismo")

    # Get target user
    stmt = select(User).where(User.user_id == target_user_id)
    result = await self.session.execute(stmt)
    target_user = result.scalar_one_or_none()

    if not target_user:
        return (False, "Usuario no encontrado")

    # Admin-on-admin: only super admin can modify other admins
    if target_user.role == UserRole.ADMIN:
        if not self.is_super_admin(admin_user_id):
            return (False, "Solo el super admin puede modificar otros administradores")

    return (True, None)
```

**j. get_user_role(user_id) -> Optional[UserRole]:**
```python
async def get_user_role(self, user_id: int) -> Optional[UserRole]:
    """
    Obtiene el rol de un usuario.

    Args:
        user_id: ID del usuario

    Returns:
        UserRole o None si no existe
    """
    try:
        stmt = select(User).where(User.user_id == user_id)
        result = await self.session.execute(stmt)
        user = result.scalar_one_or_none()
        return user.role if user else None
    except Exception as e:
        logger.error(f"Error getting role for user {user_id}: {e}", exc_info=True)
        return None
```

3. Add docstrings to class with full examples and patterns reference.

DO NOT:
- Send Telegram messages (service layer is business logic only)
- Create FSM states (handlers manage state)
- Use InlineKeyboardBuilder (message providers handle keyboards)
- Call session.commit() (SessionContextManager handles it)
- Implement full block/unblock without User.is_blocked field (placeholder for now)
  </action>
  <verify>
1. File created: bot/services/user_management.py
2. UserManagementService class exists with __init__(session, bot)
3. Has 10+ methods: get_user_info, change_user_role, block_user, unblock_user, expel_user_from_channels, get_user_list, search_users, is_super_admin, _can_modify_user, get_user_role
4. All methods are async (except is_super_admin, _can_modify_user)
5. get_user_info returns dict with user, subscription, interests, role_changes
6. change_user_role uses RoleChangeService for audit logging
7. block_user/unblock_user are placeholders (return error about future implementation)
8. expel_user_from_channels uses ChannelService and bot.ban_chat_member
9. get_user_list supports filtering by role and pagination
10. search_users searches by username and user_id
11. is_super_admin checks Config.ADMIN_USER_IDS[0]
12. _can_modify_user validates self-action and admin-on-admin permissions
13. No session.commit() calls
14. No Telegram message sending
15. Proper error handling with try/except
16. Logging at appropriate levels
  </verify>
  <done>
UserManagementService created with user info, role change, placeholder block/unblock, expel from channels, user list, search, permission validation methods, following established service pattern.
  </done>
</task>

<task type="auto">
  <name>Task 2: Register UserManagementService in ServiceContainer</name>
  <files>bot/services/__init__.py, bot/services/container.py</files>
  <action>
Update bot/services/__init__.py and bot/services/container.py to register UserManagementService:

1. In bot/services/__init__.py:
   - Add import: from bot.services.user_management import UserManagementService
   - Add to __all__: "UserManagementService"

2. In bot/services/container.py:
   - Add import at top: from bot.services.user_management import UserManagementService
   - Add private attribute in __init__: self._user_management_service = None

3. In ServiceContainer class, add lazy loading property:
```python
@property
def user_management(self) -> UserManagementService:
    """
    Service de gesti√≥n de usuarios y acciones administrativas.

    Se carga lazy (solo en primer acceso).

    Returns:
        UserManagementService: Instancia del service

    Usage:
        # Get user info
        info = await container.user_management.get_user_info(user_id=123)

        # Change role
        success, msg = await container.user_management.change_user_role(
            user_id=123, new_role=UserRole.VIP, changed_by=456
        )

        # Expel from channels
        success, msg = await container.user_management.expel_user_from_channels(
            user_id=123, expelled_by=456
        )
    """
    if self._user_management_service is None:
        from bot.services.user_management import UserManagementService
        logger.debug("üîÑ Lazy loading: UserManagementService")
        self._user_management_service = UserManagementService(self.session, self.bot)

    return self._user_management_service
```

4. Update get_loaded_services() to include "user_management" in the list if loaded:
```python
if self._user_management_service is not None:
    loaded.append("user_management")
```

Pattern reference: Follow existing pattern for interest, content, stats services.

DO NOT:
- Modify other service properties
- Change ServiceContainer constructor signature
- Add eager loading (use lazy loading pattern)
  </action>
  <verify>
1. UserManagementService imported in __init__.py
2. UserManagementService in __all__ list
3. ServiceContainer has @property user_management method
4. Uses lazy loading pattern (if self._user_management_service is None)
5. Logs when service is loaded
6. get_loaded_services() includes "user_management" when loaded
7. Follows existing service pattern (interest, content)
8. _user_management_service initialized in __init__
  </verify>
  <done>
UserManagementService registered in ServiceContainer with lazy loading, accessible via container.user_management.
  </done>
</task>

</tasks>

<verification>
Overall phase verification:
1. bot/services/user_management.py exists with UserManagementService class
2. UserManagementService has 10+ methods for user management
3. get_user_info returns dict with user, subscription, interests, role_changes
4. change_user_role uses RoleChangeService for audit logging
5. block_user/unblock_user are placeholders (return error about future implementation)
6. expel_user_from_channels uses bot.ban_chat_member for VIP and Free channels
7. get_user_list supports filtering by role and pagination
8. search_users searches by username and user_id
9. is_super_admin checks Config.ADMIN_USER_IDS[0]
10. _can_modify_user validates self-action and admin-on-admin permissions
11. ServiceContainer.user_management property exists with lazy loading
12. UserManagementService exported in __init__.py
13. No session.commit() calls or Telegram message sending
14. All methods return tuples or appropriate types
</verification>

<success_criteria>
1. UserManagementService can be imported: from bot.services.user_management import UserManagementService
2. ServiceContainer can access: container.user_management.get_user_info(user_id)
3. get_user_info returns dict with all user fields including vip_subscription and role_changes
4. change_user_role returns (True, message) and logs to UserRoleChangeLog via RoleChangeService
5. expel_user_from_channels returns (True, message) with list of channels
6. get_user_list(role=UserRole.VIP) returns only VIP users with pagination
7. search_users("username") finds users by username
8. search_users("123") finds user by ID if exists
9. is_super_admin returns True only for Config.ADMIN_USER_IDS[0]
10. _can_modify_user returns (False, error) when admin tries to modify themselves
11. _can_modify_user returns (False, error) when non-super-admin tries to modify admin
12. ServiceContainer lazy loads UserManagementService only when accessed
</success_criteria>

<output>
After completion, create `.planning/phases/09-user-management/09-01-SUMMARY.md`
</output>

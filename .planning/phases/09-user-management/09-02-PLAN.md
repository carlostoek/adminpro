---
phase: 09-user-management
plan: 02
type: execute
wave: 2
depends_on: [09-01]
files_modified: [bot/services/message/admin_user.py, bot/services/message/__init__.py]
autonomous: true

must_haves:
  truths:
    - "AdminUserMessages provider existe con mensajes para gestiÃ³n de usuarios"
    - "AdminUserMessages tiene mÃ©todo para menÃº principal de gestiÃ³n de usuarios"
    - "AdminUserMessages tiene mÃ©todo para lista de usuarios con badges de rol"
    - "AdminUserMessages tiene mÃ©todo para vista detallada de usuario con tabs"
    - "AdminUserMessages tiene mÃ©todo para confirmaciÃ³n de acciones (cambio de rol, expulsar)"
    - "AdminUserMessages usa voz de Lucien con terminologÃ­a apropiada"
    - "AdminUserMessages sigue patrÃ³n de BaseMessageProvider (stateless)"
  artifacts:
    - path: "bot/services/message/admin_user.py"
      provides: "AdminUserMessages provider with Lucien's voice for user management UI"
      min_lines: 300
      exports: ["users_menu", "users_list", "user_detail_overview", "user_detail_subscription", "user_detail_activity", "user_detail_interests", "change_role_confirm", "expel_confirm", "action_success"]
  key_links:
    - from: "bot/handlers/admin/users.py"
      to: "bot/services/message/admin_user.py"
      via: "ServiceContainer.message.admin.user"
      pattern: "container\\.message\\.admin\\.user\\."
    - from: "AdminUserMessages"
      to: "BaseMessageProvider"
      via: "inheritance"
      pattern: "class AdminUserMessages\\(BaseMessageProvider\\)"
---

<objective>
Create AdminUserMessages message provider with Lucien's voice for user management interface, including menu, user list with role badges, tabbed user detail view (Overview, Subscription, Activity, Interests), action confirmation dialogs, and success messages.

Purpose: Provide consistent Lucien-voiced messages for all user management UI following established message provider pattern (AdminContentMessages, AdminInterestMessages) with tabbed interface for detailed user profiles and clear confirmation flows for administrative actions.
Output: AdminUserMessages class with 10+ message methods, registered in LucienVoiceService.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/09-user-management/09-CONTEXT.md

@bot/services/message/admin_content.py
@bot/services/message/admin_interest.py
@bot/services/message/base.py
@bot/services/message/lucien_voice.py
@bot/utils/keyboards.py
@bot/database/enums.py (UserRole enum)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create AdminUserMessages provider class</name>
  <files>bot/services/message/admin_user.py</files>
  <action>
Create bot/services/message/admin_user.py with AdminUserMessages class:

1. File structure:
```python
"""
Admin User Management Messages - Lucien's voice for user management interface.

Mensajes para gestiÃ³n de usuarios: menÃº, listas, vista detallada, confirmaciones.
"""
import logging
from typing import Dict, Any, List, Tuple, Optional
from aiogram.types import InlineKeyboardBuilder, InlineKeyboardButton
from aiogram.utils.keyboard import InlineKeyboardMarkup

from bot.services.message.base import BaseMessageProvider
from bot.database.enums import UserRole

logger = logging.getLogger(__name__)


class AdminUserMessages(BaseMessageProvider):
    """
    Proveedor de mensajes para gestiÃ³n de usuarios.

    Responsabilidades:
    - Mensajes para menÃº de gestiÃ³n de usuarios
    - Listas de usuarios con badges de rol (ğŸ‘‘ Admin, ğŸ’ VIP, ğŸ‘¤ Free)
    - Vista detallada de usuario con tabs (Overview, Subscription, Activity, Interests)
    - Confirmaciones para acciones administrativas
    - Mensajes de Ã©xito/error

    TerminologÃ­a de Lucien:
    - "GestiÃ³n de Usuarios" - User management
    - "custodios" - Admins
    - "miembros del cÃ­rculo" - VIP users
    - "visitantes del jardÃ­n" - Free users
    - "sancionar" - Block
    - "expulsar" - Expel
    """

    ROLE_EMOJIS = {
        UserRole.ADMIN: "ğŸ‘‘",
        UserRole.VIP: "ğŸ’",
        UserRole.FREE: "ğŸ‘¤"
    }

    ROLE_NAMES = {
        UserRole.ADMIN: "Administrador",
        UserRole.VIP: "VIP",
        UserRole.FREE: "Free"
    }
```

2. Required message methods:

**a. users_menu(total_users, vip_count, free_count, admin_count):**
```python
def users_menu(
    self,
    total_users: int,
    vip_count: int,
    free_count: int,
    admin_count: int
) -> Tuple[str, InlineKeyboardMarkup]:
    """
    Mensaje del menÃº principal de gestiÃ³n de usuarios.

    Args:
        total_users: Total de usuarios
        vip_count: Cantidad de VIP
        free_count: Cantidad de Free
        admin_count: Cantidad de admins

    Returns:
        Tupla (text, keyboard)
    """
    text = (
        "ğŸ“‹ <b>GestiÃ³n de Usuarios</b>\n\n"
        f"<i>Bienvenido, custodio. AquÃ­ puede supervisar y administrar "
        f"a los habitantes del jardÃ­n.</i>\n\n"
        f"ğŸ‘¥ <b>Total:</b> {total_users} usuarios\n"
        f"ğŸ’ <b>VIP:</b> {vip_count} miembros del cÃ­rculo\n"
        f"ğŸ‘¤ <b>Free:</b> {free_count} visitantes\n"
        f"ğŸ‘‘ <b>Admins:</b> {admin_count} custodios\n\n"
        "<i>Seleccione una acciÃ³n para comenzar.</i>"
    )

    keyboard = InlineKeyboardBuilder()
    keyboard.row(
        InlineKeyboardButton(text="ğŸ” Buscar Usuario", callback_data="admin:users:search"),
        InlineKeyboardButton(text="ğŸ‘¥ Ver Todos", callback_data="admin:users:list:all")
    )
    keyboard.row(
        InlineKeyboardButton(text="ğŸ’ Solo VIP", callback_data="admin:users:list:vip"),
        InlineKeyboardButton(text="ğŸ‘¤ Solo Free", callback_data="admin:users:list:free")
    )
    keyboard.row(
        InlineKeyboardButton(text="ğŸ”™ Volver", callback_data="admin:menu")
    )

    return (text, keyboard.as_markup())
```

**b. users_list(users, page, total_pages, filter_type, total_count):**
```python
def users_list(
    self,
    users: List[Any],
    page: int,
    total_pages: int,
    filter_type: str,
    total_count: int
) -> Tuple[str, InlineKeyboardMarkup]:
    """
    Mensaje de lista de usuarios con paginaciÃ³n.

    Args:
        users: Lista de usuarios (con atributos user_id, username, first_name, role)
        page: PÃ¡gina actual
        total_pages: Total de pÃ¡ginas
        filter_type: Tipo de filtro (all, vip, free)
        total_count: Total de usuarios con este filtro

    Returns:
        Tupla (text, keyboard)
    """
    filter_names = {
        "all": "Todos",
        "vip": "VIP",
        "free": "Free"
    }

    header = (
        f"ğŸ‘¥ <b>Usuarios: {filter_names.get(filter_type, 'Todos')}</b>\n\n"
        f"<i>PÃ¡gina {page}/{total_pages} â€¢ {total_count} encontrados</i>\n\n"
    )

    # Build user list
    lines = []
    for user in users:
        role_emoji = self.ROLE_EMOJIS.get(user.role, "â“")
        username_display = user.username if user.username else f"id{user.user_id}"
        name_display = user.first_name or "Sin nombre"
        lines.append(
            f"{role_emoji} <a href='tg://user?id={user.user_id}'>{name_display}</a> "
            f"(@{username_display})"
        )

    text = header + "\n".join(lines) if lines else header + "<i>No hay usuarios para mostrar.</i>"

    # Build keyboard
    keyboard = InlineKeyboardBuilder()

    # Pagination buttons
    nav_buttons = []
    if page > 1:
        nav_buttons.append(InlineKeyboardButton(text="â¬…ï¸ Anterior", callback_data=f"admin:users:page:{page-1}:{filter_type}"))
    nav_buttons.append(InlineKeyboardButton(text=f"{page}/{total_pages}", callback_data="admin:users:noop"))
    if page < total_pages:
        nav_buttons.append(InlineKeyboardButton(text="â¡ï¸ Siguiente", callback_data=f"admin:users:page:{page+1}:{filter_type}"))

    if nav_buttons:
        keyboard.row(*nav_buttons)

    # Filter buttons
    keyboard.row(
        InlineKeyboardButton(text="ğŸ” Filtros", callback_data=f"admin:users:filters:{filter_type}"),
        InlineKeyboardButton(text="ğŸ”™ Volver", callback_data="admin:users:menu")
    )

    return (text, keyboard.as_markup())
```

**c. user_detail_overview(user_info):**
```python
def user_detail_overview(
    self,
    user_info: Dict[str, Any]
) -> Tuple[str, InlineKeyboardMarkup]:
    """
    PestaÃ±a de resumen del perfil de usuario.

    Args:
        user_info: Diccionario con informaciÃ³n del usuario

    Returns:
        Tupla (text, keyboard)
    """
    user_id = user_info["user_id"]
    username = user_info.get("username") or f"id{user_id}"
    first_name = user_info.get("first_name", "N/A")
    last_name = user_info.get("last_name", "")
    role = user_info["role"]
    created_at = user_info["created_at"]

    role_emoji = self.ROLE_EMOJIS.get(role, "â“")
    role_name = self.ROLE_NAMES.get(role, "Desconocido")

    name_display = f"{first_name} {last_name}".strip() or first_name

    text = (
        f"ğŸ‘¤ <b>Perfil de Usuario</b>\n\n"
        f"{role_emoji} <b>Rol:</b> {role_name}\n"
        f"ğŸ†” <b>ID:</b> {user_id}\n"
        f"ğŸ‘¤ <b>Nombre:</b> {name_display}\n"
        f"ğŸ“ <b>Username:</b> @{username}\n"
        f"ğŸ“… <b>Miembro desde:</b> {created_at.strftime('%d/%m/%Y %H:%M')}\n\n"
        f"<i>Use las pestaÃ±as para ver mÃ¡s detalles.</i>"
    )

    keyboard = InlineKeyboardBuilder()
    keyboard.row(
        InlineKeyboardButton(text="ğŸ“Š Resumen", callback_data=f"admin:user:view:{user_id}:overview"),
        InlineKeyboardButton(text="ğŸ’ SuscripciÃ³n", callback_data=f"admin:user:view:{user_id}:subscription")
    )
    keyboard.row(
        InlineKeyboardButton(text="ğŸ“ Actividad", callback_data=f"admin:user:view:{user_id}:activity"),
        InlineKeyboardButton(text="â­ Intereses", callback_data=f"admin:user:view:{user_id}:interests")
    )
    keyboard.row(
        InlineKeyboardButton(text="ğŸ”„ Cambiar Rol", callback_data=f"admin:user:role:{user_id}"),
        InlineKeyboardButton(text="ğŸš« Expulsar", callback_data=f"admin:user:expel:{user_id}")
    )
    keyboard.row(
        InlineKeyboardButton(text="ğŸ”™ Volver", callback_data=f"admin:users:list:all")
    )

    return (text, keyboard.as_markup())
```

**d. user_detail_subscription(user_info):**
```python
def user_detail_subscription(
    self,
    user_info: Dict[str, Any]
) -> Tuple[str, InlineKeyboardMarkup]:
    """
    PestaÃ±a de suscripciÃ³n del perfil de usuario.

    Args:
        user_info: Diccionario con informaciÃ³n del usuario

    Returns:
        Tupla (text, keyboard)
    """
    user_id = user_info["user_id"]
    role = user_info["role"]
    vip_sub = user_info.get("vip_subscription")

    if role == UserRole.VIP and vip_sub:
        expires_at = vip_sub["expires_at"]
        is_active = vip_sub["is_active"]
        token_used = vip_sub.get("token_used")

        status = "âœ… Activa" if is_active else "â³ Expirada"
        status_emoji = "âœ…" if is_active else "â³"

        text = (
            f"ğŸ’ <b>SuscripciÃ³n VIP</b>\n\n"
            f"{status_emoji} <b>Estado:</b> {status}\n"
            f"ğŸ“… <b>Expira:</b> {expires_at.strftime('%d/%m/%Y %H:%M')}\n"
            f"ğŸ« <b>Token usado:</b> {token_used if token_used else 'N/A'}\n\n"
        )
    else:
        text = (
            f"ğŸ’ <b>SuscripciÃ³n VIP</b>\n\n"
            f"<i>Este usuario no tiene suscripciÃ³n VIP activa.</i>\n\n"
        )

    text += "<i>Use las pestaÃ±as para ver mÃ¡s detalles.</i>"

    # Same keyboard as overview
    keyboard = InlineKeyboardBuilder()
    keyboard.row(
        InlineKeyboardButton(text="ğŸ“Š Resumen", callback_data=f"admin:user:view:{user_id}:overview"),
        InlineKeyboardButton(text="ğŸ’ SuscripciÃ³n", callback_data=f"admin:user:view:{user_id}:subscription")
    )
    keyboard.row(
        InlineKeyboardButton(text="ğŸ“ Actividad", callback_data=f"admin:user:view:{user_id}:activity"),
        InlineKeyboardButton(text="â­ Intereses", callback_data=f"admin:user:view:{user_id}:interests")
    )
    keyboard.row(
        InlineKeyboardButton(text="ğŸ”„ Cambiar Rol", callback_data=f"admin:user:role:{user_id}"),
        InlineKeyboardButton(text="ğŸš« Expulsar", callback_data=f"admin:user:expel:{user_id}")
    )
    keyboard.row(
        InlineKeyboardButton(text="ğŸ”™ Volver", callback_data=f"admin:users:list:all")
    )

    return (text, keyboard.as_markup())
```

**e. user_detail_activity(user_info):**
```python
def user_detail_activity(
    self,
    user_info: Dict[str, Any]
) -> Tuple[str, InlineKeyboardMarkup]:
    """
    PestaÃ±a de actividad del perfil de usuario.

    Args:
        user_info: Diccionario con informaciÃ³n del usuario

    Returns:
        Tupla (text, keyboard)
    """
    user_id = user_info["user_id"]
    role_changes = user_info.get("role_changes", [])
    updated_at = user_info.get("updated_at")

    text = (
        f"ğŸ“ <b>Actividad del Usuario</b>\n\n"
        f"ğŸ•’ <b>Ãšltima actualizaciÃ³n:</b> {updated_at.strftime('%d/%m/%Y %H:%M')}\n\n"
    )

    if role_changes:
        text += "<b>Cambios de rol recientes:</b>\n\n"
        for change in role_changes:
            from_role = change["from_role"].value if change["from_role"] else "N/A"
            to_role = change["to_role"].value
            reason = change["reason"].value.replace("_", " ").title()
            changed_at = change["changed_at"].strftime('%d/%m/%Y %H:%M')

            text += f"â€¢ {from_role} â†’ {to_role}\n"
            text += f"  <i>RazÃ³n: {reason}</i>\n"
            text += f"  <i>{changed_at}</i>\n\n"
    else:
        text += "<i>Sin cambios de rol registrados.</i>\n\n"

    text += "<i>Use las pestaÃ±as para ver mÃ¡s detalles.</i>"

    # Same keyboard
    keyboard = InlineKeyboardBuilder()
    keyboard.row(
        InlineKeyboardButton(text="ğŸ“Š Resumen", callback_data=f"admin:user:view:{user_id}:overview"),
        InlineKeyboardButton(text="ğŸ’ SuscripciÃ³n", callback_data=f"admin:user:view:{user_id}:subscription")
    )
    keyboard.row(
        InlineKeyboardButton(text="ğŸ“ Actividad", callback_data=f"admin:user:view:{user_id}:activity"),
        InlineKeyboardButton(text="â­ Intereses", callback_data=f"admin:user:view:{user_id}:interests")
    )
    keyboard.row(
        InlineKeyboardButton(text="ğŸ”„ Cambiar Rol", callback_data=f"admin:user:role:{user_id}"),
        InlineKeyboardButton(text="ğŸš« Expulsar", callback_data=f"admin:user:expel:{user_id}")
    )
    keyboard.row(
        InlineKeyboardButton(text="ğŸ”™ Volver", callback_data=f"admin:users:list:all")
    )

    return (text, keyboard.as_markup())
```

**f. user_detail_interests(user_info, interests):**
```python
def user_detail_interests(
    self,
    user_info: Dict[str, Any],
    interests: List[Any]
) -> Tuple[str, InlineKeyboardMarkup]:
    """
    PestaÃ±a de intereses del perfil de usuario.

    Args:
        user_info: Diccionario con informaciÃ³n del usuario
        interests: Lista de intereses del usuario

    Returns:
        Tupla (text, keyboard)
    """
    user_id = user_info["user_id"]
    interests_count = user_info.get("interests_count", 0)

    text = (
        f"â­ <b>Intereses del Usuario</b>\n\n"
        f"ğŸ“Š <b>Total:</b> {interests_count} interÃ©s(es)\n\n"
    )

    if interests:
        text += "<b>Intereses recientes:</b>\n\n"
        for interest in interests[:10]:  # Show last 10
            package = interest.package
            package_name = package.name if package else "Paquete eliminado"
            created_at = interest.created_at.strftime('%d/%m/%Y %H:%M')
            status = "âœ… Atendido" if interest.is_attended else "â³ Pendiente"

            text += f"â€¢ {package_name}\n"
            text += f"  <i>{status} â€¢ {created_at}</i>\n\n"
    else:
        text += "<i>Sin intereses registrados.</i>\n\n"

    text += "<i>Use las pestaÃ±as para ver mÃ¡s detalles.</i>"

    # Same keyboard
    keyboard = InlineKeyboardBuilder()
    keyboard.row(
        InlineKeyboardButton(text="ğŸ“Š Resumen", callback_data=f"admin:user:view:{user_id}:overview"),
        InlineKeyboardButton(text="ğŸ’ SuscripciÃ³n", callback_data=f"admin:user:view:{user_id}:subscription")
    )
    keyboard.row(
        InlineKeyboardButton(text="ğŸ“ Actividad", callback_data=f"admin:user:view:{user_id}:activity"),
        InlineKeyboardButton(text="â­ Intereses", callback_data=f"admin:user:view:{user_id}:interests")
    )
    keyboard.row(
        InlineKeyboardButton(text="ğŸ”„ Cambiar Rol", callback_data=f"admin:user:role:{user_id}"),
        InlineKeyboardButton(text="ğŸš« Expulsar", callback_data=f"admin:user:expel:{user_id}")
    )
    keyboard.row(
        InlineKeyboardButton(text="ğŸ”™ Volver", callback_data=f"admin:users:list:all")
    )

    return (text, keyboard.as_markup())
```

**g. change_role_confirm(user_info, new_role):**
```python
def change_role_confirm(
    self,
    user_info: Dict[str, Any],
    new_role: UserRole
) -> Tuple[str, InlineKeyboardMarkup]:
    """
    Mensaje de confirmaciÃ³n para cambio de rol.

    Args:
        user_info: Diccionario con informaciÃ³n del usuario
        new_role: Nuevo rol a asignar

    Returns:
        Tupla (text, keyboard)
    """
    user_id = user_info["user_id"]
    username = user_info.get("username") or f"id{user_id}"
    first_name = user_info.get("first_name", "Usuario")
    current_role = user_info["role"]

    role_emoji_current = self.ROLE_EMOJIS.get(current_role, "â“")
    role_emoji_new = self.ROLE_EMOJIS.get(new_role, "â“")
    role_name_new = self.ROLE_NAMES.get(new_role, "Desconocido")

    text = (
        f"ğŸ”„ <b>Cambiar Rol de Usuario</b>\n\n"
        f"ğŸ‘¤ <b>Usuario:</b> {first_name} (@{username})\n"
        f"ğŸ†” <b>ID:</b> {user_id}\n\n"
        f"{role_emoji_current} <b>Rol actual:</b> {current_role.value}\n"
        f"{role_emoji_new} <b>Nuevo rol:</b> {role_name_new}\n\n"
        f"<i>Â¿Confirmar este cambio? La acciÃ³n quedarÃ¡ registrada en el historial.</i>"
    )

    keyboard = InlineKeyboardBuilder()
    keyboard.row(
        InlineKeyboardButton(text="âœ… Confirmar", callback_data=f"admin:user:role:confirm:{user_id}:{new_role.value}"),
        InlineKeyboardButton(text="âŒ Cancelar", callback_data=f"admin:user:view:{user_id}:overview")
    )

    return (text, keyboard.as_markup())
```

**h. role_change_success(user_info, old_role, new_role):**
```python
def role_change_success(
    self,
    user_info: Dict[str, Any],
    old_role: UserRole,
    new_role: UserRole
) -> Tuple[str, InlineKeyboardMarkup]:
    """
    Mensaje de Ã©xito para cambio de rol.

    Args:
        user_info: Diccionario con informaciÃ³n del usuario
        old_role: Rol anterior
        new_role: Nuevo rol asignado

    Returns:
        Tupla (text, keyboard)
    """
    user_id = user_info["user_id"]
    username = user_info.get("username") or f"id{user_id}"
    first_name = user_info.get("first_name", "Usuario")

    role_emoji = self.ROLE_EMOJIS.get(new_role, "âœ…")
    role_name = self.ROLE_NAMES.get(new_role, new_role.value)

    text = (
        f"âœ… <b>Rol Cambiado Exitosamente</b>\n\n"
        f"{role_emoji} <b>{first_name}</b> (@{username}) ahora es <b>{role_name}</b>.\n\n"
        f"<i>El usuario ha sido notificado del cambio.</i>"
    )

    keyboard = InlineKeyboardBuilder()
    keyboard.row(
        InlineKeyboardButton(text="ğŸ”™ Volver al Perfil", callback_data=f"admin:user:view:{user_id}:overview"),
        InlineKeyboardButton(text="ğŸ‘¥ Volver a Lista", callback_data="admin:users:list:all")
    )

    return (text, keyboard.as_markup())
```

**i. expel_confirm(user_info):**
```python
def expel_confirm(
    self,
    user_info: Dict[str, Any]
) -> Tuple[str, InlineKeyboardMarkup]:
    """
    Mensaje de confirmaciÃ³n para expulsar usuario.

    Args:
        user_info: Diccionario con informaciÃ³n del usuario

    Returns:
        Tupla (text, keyboard)
    """
    user_id = user_info["user_id"]
    username = user_info.get("username") or f"id{user_id}"
    first_name = user_info.get("first_name", "Usuario")
    role = user_info["role"]

    role_emoji = self.ROLE_EMOJIS.get(role, "â“")
    role_name = self.ROLE_NAMES.get(role, "Desconocido")

    text = (
        f"ğŸš« <b>Expulsar Usuario</b>\n\n"
        f"ğŸ‘¤ <b>Usuario:</b> {first_name} (@{username})\n"
        f"ğŸ†” <b>ID:</b> {user_id}\n"
        f"{role_emoji} <b>Rol:</b> {role_name}\n\n"
        f"<i>Esta acciÃ³n removerÃ¡ al usuario de todos los canales (VIP y Free). "
        f"El usuario aÃºn podrÃ¡ usar el bot, pero no tendrÃ¡ acceso a los canales.</i>\n\n"
        f"<i>Â¿Confirmar esta acciÃ³n?</i>"
    )

    keyboard = InlineKeyboardBuilder()
    keyboard.row(
        InlineKeyboardButton(text="âœ… Expulsar", callback_data=f"admin:user:expel:confirm:{user_id}"),
        InlineKeyboardButton(text="âŒ Cancelar", callback_data=f"admin:user:view:{user_id}:overview")
    )

    return (text, keyboard.as_markup())
```

**j. expel_success(user_info, expelled_from):**
```python
def expel_success(
    self,
    user_info: Dict[str, Any],
    expelled_from: List[str]
) -> Tuple[str, InlineKeyboardMarkup]:
    """
    Mensaje de Ã©xito para expulsiÃ³n.

    Args:
        user_info: Diccionario con informaciÃ³n del usuario
        expelled_from: Lista de canales de los que fue expulsado

    Returns:
        Tupla (text, keyboard)
    """
    user_id = user_info["user_id"]
    username = user_info.get("username") or f"id{user_id}"
    first_name = user_info.get("first_name", "Usuario")

    channels_str = ", ".join(expelled_from)

    text = (
        f"âœ… <b>Usuario Expulsado</b>\n\n"
        f"<b>{first_name}</b> (@{username}) ha sido removido de: {channels_str}.\n\n"
        f"<i>El usuario ha sido notificado de la acciÃ³n.</i>"
    )

    keyboard = InlineKeyboardBuilder()
    keyboard.row(
        InlineKeyboardButton(text="ğŸ‘¥ Volver a Lista", callback_data="admin:users:list:all")
    )

    return (text, keyboard.as_markup())
```

**k. user_search_prompt():**
```python
def user_search_prompt(self) -> Tuple[str, InlineKeyboardMarkup]:
    """
    Mensaje de prompt para bÃºsqueda de usuario.

    Returns:
        Tupla (text, keyboard)
    """
    text = (
        f"ğŸ” <b>Buscar Usuario</b>\n\n"
        f"<i>Por favor, ingrese el username o ID del usuario que desea buscar.</i>\n\n"
        f"Ejemplos:\n"
        f"â€¢ @username\n"
        f"â€¢ username\n"
        f"â€¢ 123456789\n\n"
        f"<i>Escriba /cancel para cancelar la bÃºsqueda.</i>"
    )

    keyboard = InlineKeyboardBuilder()
    keyboard.row(
        InlineKeyboardButton(text="âŒ Cancelar", callback_data="admin:users:menu")
    )

    return (text, keyboard.as_markup())
```

**l. user_search_results(users, query):**
```python
def user_search_results(
    self,
    users: List[Any],
    query: str
) -> Tuple[str, InlineKeyboardMarkup]:
    """
    Mensaje de resultados de bÃºsqueda.

    Args:
        users: Lista de usuarios encontrados
        query: Query de bÃºsqueda

    Returns:
        Tupla (text, keyboard)
    """
    text = (
        f"ğŸ” <b>Resultados: "{query}"</b>\n\n"
        f"<i>{len(users)} encontrado(s)</i>\n\n"
    )

    # Build user list
    lines = []
    for user in users:
        role_emoji = self.ROLE_EMOJIS.get(user.role, "â“")
        username_display = user.username if user.username else f"id{user.user_id}"
        name_display = user.first_name or "Sin nombre"
        lines.append(
            f"{role_emoji} <a href='tg://user?id={user.user_id}'>{name_display}</a> "
            f"(@{username_display})"
        )

    text += "\n".join(lines) if lines else "<i>No se encontraron usuarios.</i>"

    # Build keyboard
    keyboard = InlineKeyboardBuilder()
    if users:
        # Add view buttons for each user
        for user in users[:5]:  # Max 5 results
            name_display = user.first_name or f"id{user.user_id}"
            keyboard.row(
                InlineKeyboardButton(
                    text=f"ğŸ‘¤ Ver {name_display}",
                    callback_data=f"admin:user:view:{user.user_id}:overview"
                )
            )

    keyboard.row(
        InlineKeyboardButton(text="ğŸ” Nueva BÃºsqueda", callback_data="admin:users:search"),
        InlineKeyboardButton(text="ğŸ”™ Volver", callback_data="admin:users:menu")
    )

    return (text, keyboard.as_markup())
```

**m. action_error(message):**
```python
def action_error(
    self,
    message: str
) -> Tuple[str, InlineKeyboardMarkup]:
    """
    Mensaje de error para acciÃ³n administrativa.

    Args:
        message: Mensaje de error

    Returns:
        Tupla (text, keyboard)
    """
    text = (
        f"âŒ <b>Error</b>\n\n"
        f"{message}\n\n"
        f"<i>Por favor, intÃ©ntelo de nuevo o contacte al super admin si el problema persiste.</i>"
    )

    keyboard = InlineKeyboardBuilder()
    keyboard.row(
        InlineKeyboardButton(text="ğŸ”™ Volver al MenÃº", callback_data="admin:users:menu")
    )

    return (text, keyboard.as_markup())
```

3. Add class docstring with examples.

DO NOT:
- Store session/bot in __init__ (stateless pattern)
- Call database queries (message providers are stateless)
- Use hardcoded strings without Lucien's voice
- Create FSM states (handlers manage state)
  </action>
  <verify>
1. File created: bot/services/message/admin_user.py
2. AdminUserMessages extends BaseMessageProvider
3. Has ROLE_EMOJIS and ROLE_NAMES constants
4. Has 13+ methods: users_menu, users_list, user_detail_overview, user_detail_subscription, user_detail_activity, user_detail_interests, change_role_confirm, role_change_success, expel_confirm, expel_success, user_search_prompt, user_search_results, action_error
5. All methods return Tuple[str, InlineKeyboardMarkup]
6. Uses Lucien's voice (custodio, miembros del cÃ­rculo, visitantes del jardÃ­n)
7. Uses role badges (ğŸ‘‘ Admin, ğŸ’ VIP, ğŸ‘¤ Free)
8. Tabbed interface for user detail (Overview, Subscription, Activity, Interests)
9. Confirmation dialogs for role change and expel
10. All keyboards have back/navigation buttons
11. Stateless pattern (no session/bot in __init__)
  </verify>
  <done>
AdminUserMessages provider created with Lucien's voice for user management UI, including menu, user list with role badges, tabbed user detail view, action confirmations, and success/error messages.
  </done>
</task>

<task type="auto">
  <name>Task 2: Register AdminUserMessages in LucienVoiceService</name>
  <files>bot/services/message/__init__.py, bot/services/message/lucien_voice.py</files>
  <action>
Update bot/services/message/__init__.py and bot/services/message/lucien_voice.py to register AdminUserMessages:

1. In bot/services/message/__init__.py:
   - Add import: from bot.services.message.admin_user import AdminUserMessages
   - Add to __all__: "AdminUserMessages"

2. In bot/services/message/lucien_voice.py:
   - Add import at top: from bot.services.message.admin_user import AdminUserMessages

3. In LucienVoiceService class, add admin user messages property:
```python
@property
def _admin_user(self) -> AdminUserMessages:
    """Admin user management messages."""
    if self._admin_user_messages is None:
        from bot.services.message.admin_user import AdminUserMessages
        self._admin_user_messages = AdminUserMessages(self._session_history)
    return self._admin_user_messages
```

4. In the nested AdminMessages class, add user property:
```python
@property
def user(self) -> AdminUserMessages:
    """
    Admin user management messages.

    Access user profile, lists, and action messages.

    Returns:
        AdminUserMessages: Provider instance
    """
    return self._parent._admin_user
```

5. Initialize _admin_user_messages in LucienVoiceService.__init__:
```python
self._admin_user_messages = None
```

Pattern reference: Follow existing pattern for admin_content, admin_interest.

DO NOT:
- Modify other message providers
- Change LucienVoiceService constructor signature
- Add eager loading (use lazy loading pattern)
  </action>
  <verify>
1. AdminUserMessages imported in __init__.py
2. AdminUserMessages in __all__ list
3. LucienVoiceService has _admin_user_messages property with lazy loading
4. AdminMessages class has user property returning AdminUserMessages
5. _admin_user_messages initialized in __init__
6. Accessible via container.message.admin.user
7. Follows existing message provider pattern (admin_content, admin_interest)
  </verify>
  <done>
AdminUserMessages registered in LucienVoiceService with lazy loading, accessible via container.message.admin.user.
  </done>
</task>

</tasks>

<verification>
Overall phase verification:
1. bot/services/message/admin_user.py exists with AdminUserMessages class
2. AdminUserMessages extends BaseMessageProvider
3. Has ROLE_EMOJIS and ROLE_NAMES constants
4. Has 13+ message methods for user management UI
5. users_menu shows total users, VIP count, Free count, admin count
6. users_list displays users with role badges and pagination
7. user_detail_* methods provide tabbed interface (Overview, Subscription, Activity, Interests)
8. change_role_confirm shows current role and new role
9. expel_confirm explains what expelling means
10. user_search_prompt explains how to search
11. user_search_results displays found users
12. action_error displays error messages
13. All methods use Lucien's voice (custodio, cÃ­rculo, jardÃ­n)
14. LucienVoiceService has _admin_user property
15. AdminMessages has user property
16. Accessible via container.message.admin.user
17. All messages are stateless (no session/bot storage)
</verification>

<success_criteria>
1. AdminUserMessages can be imported: from bot.services.message.admin_user import AdminUserMessages
2. LucienVoiceService can access: container.message.admin.user.users_menu(...)
3. users_menu returns text with counts and keyboard with navigation buttons
4. users_list returns text with user list (role badges, links) and pagination
5. user_detail_overview returns text with user info and tabbed keyboard
6. user_detail_subscription returns text with VIP subscription info
7. user_detail_activity returns text with role change history
8. user_detail_interests returns text with interests list
9. change_role_confirm shows before/after roles and confirmation buttons
10. expel_confirm explains action and has confirmation buttons
11. LucienVoiceService lazy loads AdminUserMessages
12. All messages use HTML formatting and InlineKeyboardMarkup
</success_criteria>

<output>
After completion, create `.planning/phases/09-user-management/09-02-SUMMARY.md`
</output>

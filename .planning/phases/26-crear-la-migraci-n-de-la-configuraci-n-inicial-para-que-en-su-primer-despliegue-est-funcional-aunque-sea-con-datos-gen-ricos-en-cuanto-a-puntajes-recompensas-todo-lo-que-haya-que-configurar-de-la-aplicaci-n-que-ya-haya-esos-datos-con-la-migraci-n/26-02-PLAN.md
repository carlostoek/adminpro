---
phase: 26-initial-data-migration
plan: 02
type: execute
wave: 2
depends_on: ["26-01"]
files_modified:
  - bot/database/seeders/__init__.py
  - bot/database/seeders/base.py
  - bot/database/seeders/rewards.py
autonomous: true

must_haves:
  truths:
    - "Seeder module exists at bot/database/seeders/ with __init__.py"
    - "Reward seeder creates conditions for each reward"
    - "Seeder is idempotent - checks for existing data before creating"
    - "Seeder uses proper RewardType and RewardConditionType enums"
    - "Default rewards have associated conditions in reward_conditions table"
  artifacts:
    - path: "bot/database/seeders/__init__.py"
      provides: "Seeder module exports"
      exports: ["seed_default_rewards", "RewardSeeder"]
    - path: "bot/database/seeders/base.py"
      provides: "Base seeder class"
      contains: ["class BaseSeeder"]
    - path: "bot/database/seeders/rewards.py"
      provides: "Reward seeding logic"
      contains:
        - "DEFAULT_REWARDS"
        - "async def seed_default_rewards"
        - "RewardConditionType"
  key_links:
    - from: "bot/database/seeders/rewards.py"
      to: "bot/database/models.py (Reward, RewardCondition)"
      via: "SQLAlchemy ORM imports"
    - from: "bot/database/seeders/rewards.py"
      to: "bot/database/enums.py (RewardType, RewardConditionType)"
      via: "Enum imports for type safety"
---

<objective>
Create Python seeder modules for complex relational data (rewards with conditions) that can be called from the Alembic migration or application startup.

Purpose: Handle complex data seeding that requires ORM relationships and validation logic, which is difficult to do in raw SQL.

Output: `bot/database/seeders/` module with base class and rewards seeder
</objective>

<execution_context>
@/data/data/com.termux/files/home/.claude/get-shit-done/workflows/execute-plan.md
@/data/data/com.termux/files/home/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/phases/26-crear-la-migraci-n-de-la-configuraci-n-inicial-para-que-en-su-primer-despliegue-est-funcional-aunque-sea-con-datos-gen-ricos-en-cuanto-a-puntajes-recompensas-todo-lo-que-haya-que-configurar-de-la-aplicaci-n-que-ya-haya-esos-datos-con-la-migraci-n/26-RESEARCH.md
@bot/database/models.py
@bot/database/enums.py

## Reference: Reward and RewardCondition Models

From `bot/database/models.py`:

```python
class Reward(Base):
    __tablename__ = "rewards"
    id = Column(Integer, primary_key=True, autoincrement=True)
    name = Column(String(200), nullable=False)
    description = Column(String(1000), nullable=True)
    reward_type = Column(Enum(RewardType), nullable=False)
    reward_value = Column(JSON, nullable=False, default=dict)
    is_repeatable = Column(Boolean, nullable=False, default=False)
    is_secret = Column(Boolean, nullable=False, default=False)
    claim_window_hours = Column(Integer, nullable=False, default=168)
    is_active = Column(Boolean, nullable=False, default=True, index=True)
    sort_order = Column(Integer, nullable=False, default=0)
    created_at = Column(DateTime, nullable=False, default=datetime.utcnow)
    updated_at = Column(DateTime, nullable=False, default=datetime.utcnow, onupdate=datetime.utcnow)
    conditions = relationship("RewardCondition", back_populates="reward", cascade="all, delete-orphan")

class RewardCondition(Base):
    __tablename__ = "reward_conditions"
    id = Column(Integer, primary_key=True, autoincrement=True)
    reward_id = Column(Integer, ForeignKey("rewards.id", ondelete="CASCADE"), nullable=False, index=True)
    condition_type = Column(Enum(RewardConditionType), nullable=False)
    condition_value = Column(Integer, nullable=True)
    condition_group = Column(Integer, nullable=False, default=0)
    sort_order = Column(Integer, nullable=False, default=0)
    created_at = Column(DateTime, nullable=False, default=datetime.utcnow)
    reward = relationship("Reward", back_populates="conditions")
```

## Reference: Enums

From `bot/database/enums.py`:

```python
class RewardType(str, Enum):
    BESITOS = "BESITOS"
    CONTENT = "CONTENT"
    BADGE = "BADGE"
    VIP_EXTENSION = "VIP_EXTENSION"

class RewardConditionType(str, Enum):
    STREAK_LENGTH = "STREAK_LENGTH"
    TOTAL_POINTS = "TOTAL_POINTS"
    LEVEL_REACHED = "LEVEL_REACHED"
    BESITOS_SPENT = "BESITOS_SPENT"
    FIRST_PURCHASE = "FIRST_PURCHASE"
    FIRST_DAILY_GIFT = "FIRST_DAILY_GIFT"
    FIRST_REACTION = "FIRST_REACTION"
    NOT_VIP = "NOT_VIP"
    NOT_CLAIMED_BEFORE = "NOT_CLAIMED_BEFORE"
```

## Default Rewards with Conditions

1. **Primeros Pasos**
   - Type: BESITOS
   - Value: {"amount": 10}
   - Conditions: FIRST_REACTION

2. **Ahorrador Principiante**
   - Type: BADGE
   - Value: {"badge_name": "ahorrador", "emoji": "ðŸ’°"}
   - Conditions: TOTAL_POINTS >= 100

3. **Racha de 7 Dias**
   - Type: BESITOS
   - Value: {"amount": 50}
   - Conditions: STREAK_LENGTH >= 7

## Pattern from Research

From `26-RESEARCH.md` lines 397-475:
- Use async functions with AsyncSession
- Check for existing data before creating (idempotency)
- Use `await session.flush()` to get IDs after creating parent
- Create conditions after reward to have reward_id available
</context>

<tasks>

<task type="auto">
  <name>Create seeders module structure</name>
  <files>
    bot/database/seeders/__init__.py
    bot/database/seeders/base.py
  </files>
  <action>
Create the seeders module structure:

1. **Create directory** `bot/database/seeders/` (if not exists)

2. **Create `bot/database/seeders/__init__.py`:**
   ```python
   """Database seeders for default data initialization."""
   from bot.database.seeders.rewards import seed_default_rewards

   __all__ = ["seed_default_rewards"]
   ```

3. **Create `bot/database/seeders/base.py`:**
   ```python
   """Base class for database seeders."""
   import logging
   from abc import ABC, abstractmethod
   from typing import Optional

   from sqlalchemy.ext.asyncio import AsyncSession

   logger = logging.getLogger(__name__)


   class BaseSeeder(ABC):
       """Base class for all database seeders."""

       def __init__(self, session: AsyncSession):
           self.session = session
           self.logger = logging.getLogger(self.__class__.__name__)

       @abstractmethod
       async def seed(self) -> None:
           """Execute the seeding logic."""
           pass

       async def check_exists(self, model_class, **filters) -> bool:
           """Check if a record already exists."""
           from sqlalchemy import select
           result = await self.session.execute(
               select(model_class).filter_by(**filters)
           )
           return result.scalar_one_or_none() is not None
   ```
  </action>
  <verify>
    - Directory `bot/database/seeders/` exists
    - `__init__.py` exports seed_default_rewards
    - `base.py` contains BaseSeeder class with abstract seed() method
  </verify>
  <done>
    - Seeder module structure created
    - Base class available for future seeders
    - Module is importable
  </done>
</task>

<task type="auto">
  <name>Create rewards seeder</name>
  <files>bot/database/seeders/rewards.py</files>
  <action>
Create `bot/database/seeders/rewards.py` with the following content:

```python
"""Default rewards seeder for the gamification system."""
import logging
from typing import List, Dict, Any

from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select

from bot.database.models import Reward, RewardCondition
from bot.database.enums import RewardType, RewardConditionType

logger = logging.getLogger(__name__)

# Default rewards configuration
DEFAULT_REWARDS: List[Dict[str, Any]] = [
    {
        "name": "Primeros Pasos",
        "description": "Da tu primera reacciÃ³n al contenido",
        "reward_type": RewardType.BESITOS,
        "reward_value": {"amount": 10},
        "is_repeatable": False,
        "is_secret": False,
        "claim_window_hours": 168,  # 7 days
        "sort_order": 0,
        "conditions": [
            {"condition_type": RewardConditionType.FIRST_REACTION}
        ]
    },
    {
        "name": "Ahorrador Principiante",
        "description": "Acumula 100 besitos en tu cuenta",
        "reward_type": RewardType.BADGE,
        "reward_value": {"badge_name": "ahorrador", "emoji": "ðŸ’°"},
        "is_repeatable": False,
        "is_secret": False,
        "claim_window_hours": 168,
        "sort_order": 1,
        "conditions": [
            {"condition_type": RewardConditionType.TOTAL_POINTS, "condition_value": 100}
        ]
    },
    {
        "name": "Racha de 7 DÃ­as",
        "description": "MantÃ©n una racha de 7 dÃ­as reclamando el regalo diario",
        "reward_type": RewardType.BESITOS,
        "reward_value": {"amount": 50},
        "is_repeatable": False,
        "is_secret": False,
        "claim_window_hours": 168,
        "sort_order": 2,
        "conditions": [
            {"condition_type": RewardConditionType.STREAK_LENGTH, "condition_value": 7}
        ]
    }
]


async def seed_default_rewards(session: AsyncSession) -> None:
    """
    Seed default rewards if they don't exist.

    This function is idempotent - running it multiple times will not
    create duplicate rewards. It checks for existing rewards by name.

    Args:
        session: Async database session

    Returns:
        None
    """
    logger.info("Starting default rewards seeding...")
    created_count = 0
    skipped_count = 0

    for reward_data in DEFAULT_REWARDS:
        # Check if reward exists by name
        result = await session.execute(
            select(Reward).where(Reward.name == reward_data["name"])
        )
        existing_reward = result.scalar_one_or_none()

        if existing_reward:
            logger.debug(f"Reward '{reward_data['name']}' already exists, skipping")
            skipped_count += 1
            continue

        # Extract conditions before creating reward
        conditions_data = reward_data.pop("conditions", [])

        # Create reward
        reward = Reward(
            name=reward_data["name"],
            description=reward_data["description"],
            reward_type=reward_data["reward_type"],
            reward_value=reward_data["reward_value"],
            is_repeatable=reward_data["is_repeatable"],
            is_secret=reward_data["is_secret"],
            claim_window_hours=reward_data["claim_window_hours"],
            is_active=True,
            sort_order=reward_data["sort_order"]
        )
        session.add(reward)
        await session.flush()  # Get reward.id

        # Create conditions for this reward
        for cond_data in conditions_data:
            condition = RewardCondition(
                reward_id=reward.id,
                condition_type=cond_data["condition_type"],
                condition_value=cond_data.get("condition_value"),
                condition_group=cond_data.get("condition_group", 0),
                sort_order=cond_data.get("sort_order", 0)
            )
            session.add(condition)

        logger.info(f"Created reward: {reward_data['name']} (ID: {reward.id})")
        created_count += 1

    await session.commit()
    logger.info(
        f"Rewards seeding complete. Created: {created_count}, "
        f"Skipped: {skipped_count}"
    )
```

Key implementation details:
1. Use `select(Reward).where(Reward.name == ...)` to check existence
2. Use `await session.flush()` after adding reward to get its ID
3. Create conditions after reward has ID
4. Use proper enum values (RewardType.BESITOS, etc.)
5. Log creation/skip counts for visibility
6. Commit at the end
  </action>
  <verify>
    - File `bot/database/seeders/rewards.py` exists
    - Contains DEFAULT_REWARDS list with 3 rewards
    - Contains `async def seed_default_rewards(session)` function
    - Uses proper imports from bot.database.models and bot.database.enums
    - Checks for existing rewards before creating (idempotent)
    - Creates conditions after reward to have reward_id available
  </verify>
  <done>
    - Rewards seeder created with 3 default rewards
    - Each reward has associated conditions
    - Seeder is idempotent and logs progress
    - Function can be called from migration or application startup
  </done>
</task>

</tasks>

<verification>
After completing this plan:

1. **Module Structure:**
   - `bot/database/seeders/__init__.py` exists and exports seed_default_rewards
   - `bot/database/seeders/base.py` exists with BaseSeeder class
   - `bot/database/seeders/rewards.py` exists with seeding logic

2. **Functionality:**
   - seed_default_rewards is importable: `from bot.database.seeders import seed_default_rewards`
   - Function accepts AsyncSession parameter
   - Function creates rewards with their conditions
   - Function is idempotent (checks existence before creating)

3. **Data Integrity:**
   - Uses proper RewardType enum values
   - Uses proper RewardConditionType enum values
   - Creates conditions with correct reward_id foreign key
   - Proper JSON formatting for reward_value
</verification>

<success_criteria>
- Seeder module created at bot/database/seeders/
- seed_default_rewards function is importable and functional
- Seeder creates 3 default rewards with their conditions
- Seeder is idempotent (safe to run multiple times)
</success_criteria>

<output>
After completion, create `.planning/phases/26-crear-la-migraci-n-de-la-configuraci-n-inicial-para-que-en-su-primer-despliegue-est-funcional-aunque-sea-con-datos-gen-ricos-en-cuanto-a-puntajes-recompensas-todo-lo-que-haya-que-configurar-de-la-aplicaci-n-que-ya-haya-esos-datos-con-la-migraci-n/26-02-SUMMARY.md`
</output>

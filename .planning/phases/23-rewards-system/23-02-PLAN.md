---
phase: 23-rewards-system
plan: 02
type: execute
wave: 1
depends_on: ["23-01"]
files_modified:
  - bot/services/reward.py
autonomous: true

must_haves:
  truths:
    - RewardService can evaluate all condition types
    - Event-driven checking triggers on relevant actions
    - Grouped notifications combine multiple achievements
    - Reward claiming updates user state correctly
    - Reward values are capped at configured maximums (REWARD-06)
  artifacts:
    - path: "bot/services/reward.py"
      provides: "RewardService with condition evaluation"
      min_lines: 400
      exports: ["RewardService"]
  key_links:
    - from: "RewardService"
      to: "WalletService"
      via: "earn_besitos for BESITOS rewards"
    - from: "RewardService"
      to: "Reward/RewardCondition/UserReward models"
      via: "SQLAlchemy queries"
---

<objective>
Implement RewardService with condition evaluation engine and event-driven checking.

Purpose: Core service that checks reward eligibility, evaluates conditions, and handles reward claiming with grouped notifications.
Output: RewardService with condition evaluation, event handlers, and claim processing.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/STATE.md
@.planning/ROADMAP.md
@.planning/phases/23-rewards-system/23-CONTEXT.md
@bot/services/wallet.py
@bot/services/streak.py
@bot/database/models.py
@bot/database/enums.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create RewardService Core Structure</name>
  <files>bot/services/reward.py</files>
  <action>
Create bot/services/reward.py with the RewardService class structure:

**Imports:**
- logging, datetime, typing
- sqlalchemy select, func
- Reward, RewardCondition, UserReward models
- RewardType, RewardConditionType, RewardStatus, StreakType enums
- TransactionType from bot.database.enums

**Class RewardService:**
```python
class RewardService:
    """
    Service for managing rewards and achievement system.

    Responsibilities:
    - Evaluate reward conditions for users
    - Check eligibility on events (event-driven)
    - Handle reward claiming
    - Track user progress toward rewards
    - Deliver grouped notifications

    Patterns:
    - Event-driven checking: conditions verified when relevant events occur
    - AND/OR logic: default AND, groups use OR
    - Grouped notifications: single message with multiple achievements
    """
```

**__init__ method:**
- session: AsyncSession
- wallet_service: Optional[WalletService] = None
- streak_service: Optional[StreakService] = None

**Logger setup** with __name__
  </action>
  <verify>test -f bot/services/reward.py && grep -q "class RewardService" bot/services/reward.py</verify>
  <done>RewardService class exists with proper imports and __init__</done>
</task>

<task type="auto">
  <name>Task 2: Implement Condition Evaluation Methods</name>
  <files>bot/services/reward.py</files>
  <action>
Add condition evaluation methods to RewardService:

**_evaluate_numeric_condition(profile, condition_type, threshold):**
- Check condition_type against UserGamificationProfile
- STREAK_LENGTH: use streak_service to get current streak
- TOTAL_POINTS: profile.total_earned >= threshold
- LEVEL_REACHED: profile.level >= threshold
- BESITOS_SPENT: profile.total_spent >= threshold
- Return True/False

**_evaluate_event_condition(user_id, condition_type):**
- FIRST_PURCHASE: check if UserContentAccess exists for user
- FIRST_DAILY_GIFT: check if any EARN_DAILY transaction exists
- FIRST_REACTION: check if UserReaction exists for user
- Return True/False

**_evaluate_exclusion_condition(user_id, condition_type, reward_id):**
- NOT_VIP: check user role != VIP
- NOT_CLAIMED_BEFORE: check UserReward claim_count == 0
- Return True/False

**evaluate_single_condition(user_id, condition):**
- Route to appropriate evaluation method based on condition_type
- Return (passed: bool, details: dict)

**evaluate_reward_conditions(user_id, reward):**
- Get all conditions for reward
- Group by condition_group
- Group 0 (AND): all must pass
- Groups 1+ (OR): at least one in each group must pass
- Return (eligible: bool, passed_conditions: list, failed_conditions: list)
  </action>
  <verify>grep -q "_evaluate_numeric_condition" bot/services/reward.py && grep -q "evaluate_reward_conditions" bot/services/reward.py</verify>
  <done>All condition evaluation methods implemented</done>
</task>

<task type="auto">
  <name>Task 3: Implement Event-Driven Checking</name>
  <files>bot/services/reward.py</files>
  <action>
Add event-driven checking methods to RewardService:

**check_rewards_on_event(user_id, event_type, event_data=None):**
- Find all active rewards that could be affected by this event
- For each reward, evaluate conditions for user
- Return list of newly unlocked rewards

**Event types to handle:**
- "daily_gift_claimed": Check STREAK_LENGTH, FIRST_DAILY_GIFT conditions
- "reaction_added": Check FIRST_REACTION conditions
- "purchase_completed": Check FIRST_PURCHASE, BESITOS_SPENT conditions
- "level_up": Check LEVEL_REACHED conditions
- "streak_updated": Check STREAK_LENGTH conditions

**_get_rewards_for_event(event_type):**
- Query rewards that have conditions matching the event type
- Return list of Reward objects

**_update_user_reward_status(user_id, reward, is_eligible):**
- Get or create UserReward record
- If newly eligible (was LOCKED, now meets conditions):
  - Set status to UNLOCKED
  - Set unlocked_at to now
  - Set expires_at based on reward.claim_window_hours
  - Return "newly_unlocked"
- If already UNLOCKED/CLAIMED and repeatable:
  - Check if can claim again (conditions met again after last claim)
  - Return "repeatable_available" or "no_change"
- Return appropriate status
  </action>
  <verify>grep -q "check_rewards_on_event" bot/services/reward.py && grep -q "_get_rewards_for_event" bot/services/reward.py</verify>
  <done>Event-driven checking methods implemented</done>
</task>

<task type="auto">
  <name>Task 4: Implement Reward Claiming</name>
  <files>bot/services/reward.py</files>
  <action>
Add reward claiming methods to RewardService:

**claim_reward(user_id, reward_id):**
- Validate reward exists and is active
- Get UserReward record
- Check status is UNLOCKED (not LOCKED, CLAIMED, or EXPIRED)
- Check not expired (if expires_at < now, set EXPIRED and return error)
- Process reward based on type:
  - BESITOS: call wallet_service.earn_besitos with EARN_REWARD type
  - CONTENT: create UserContentAccess record with reward_claim type
  - BADGE: update UserReward with badge info in metadata
  - VIP_EXTENSION: extend VIP subscription (call subscription service if available)
- Update UserReward:
  - Set status to CLAIMED (or back to LOCKED if repeatable and conditions still met)
  - Increment claim_count
  - Set claimed_at to now
  - Set last_claimed_at to now
- Return (success: bool, message: str, details: dict)

**get_available_rewards(user_id, include_secret=False):**
- Query all active rewards
- For each, get UserReward status
- Filter based on visibility:
  - Non-secret: always show
  - Secret: only show if status != LOCKED (unlocked or claimed)
- Return list of (reward, status, progress_info) tuples

**get_reward_progress(user_id, reward_id):**
- Get reward and its conditions
- For each condition, evaluate current state
- Return progress info: {condition_id: {current: X, required: Y, passed: bool}}
  </action>
  <verify>grep -q "claim_reward" bot/services/reward.py && grep -q "get_available_rewards" bot/services/reward.py</verify>
  <done>Reward claiming and listing methods implemented</done>
</task>

<task type="auto">
  <name>Task 5: Implement Grouped Notification Builder</name>
  <files>bot/services/reward.py</files>
  <action>
Add notification building methods to RewardService:

**build_reward_notification(unlocked_rewards, event_context):**
- Build a single message combining multiple achievements
- Format depends on context (daily gift, purchase, level up, etc.)
- Return dict with:
  - text: Formatted message with Lucien's voice (ðŸŽ©)
  - rewards: List of unlocked reward details
  - primary_action: "claim" or "view"

**Message format (Lucien's voice):**
- Single reward: "ðŸŽ© <b>Excelente, {name}</b>\n\nHa desbloqueado una recompensa..."
- Multiple rewards: "ðŸŽ© <b>Â¡QuÃ© jornada, {name}!</b>\n\nHa desbloqueado {count} recompensas..."

**format_reward_summary(reward, status):**
- Format a single reward for display
- Include emoji based on reward_type
- Show claim status

**get_user_reward_stats(user_id):**
- Return stats: total unlocked, total claimed, total expired, by type breakdown
  </action>
  <verify>grep -q "build_reward_notification" bot/services/reward.py && grep -q "format_reward_summary" bot/services/reward.py</verify>
  <done>Notification builder methods implemented with Lucien's voice</done>
</task>

<task type="auto">
  <name>Task 6: Implement Reward Value Capping (REWARD-06)</name>
  <files>bot/services/reward.py, bot/services/config.py</files>
  <action>
Add reward value capping to enforce maximum limits per reward (REWARD-06):

**In bot/services/config.py:**
Add economy configuration for reward caps:
- max_reward_besitos: Integer (default=100) - maximum besitos per reward
- max_reward_vip_days: Integer (default=30) - maximum VIP extension days

**In bot/services/reward.py:**
Add reward capping methods:

**_apply_reward_cap(reward_type, reward_value):**
- Read max values from config
- For BESITOS: return min(reward_value, max_reward_besitos)
- For VIP_EXTENSION: return min(reward_value, max_reward_vip_days)
- For CONTENT/BADGE: no cap (return original)
- Return capped value

**Update claim_reward method:**
- Before processing reward, call _apply_reward_cap
- Log when capping occurs: "Reward value capped from X to Y"
- Use capped value for actual reward delivery

**Example:**
- Reward configured for 500 besitos
- max_reward_besitos = 100
- User receives: 100 besitos (capped)
- Notification shows actual received amount

This implements REWARD-06 requirement: "Reward has maximum cap (e.g., max 100 besitos per reward)"
  </action>
  <verify>grep -q "_apply_reward_cap" bot/services/reward.py && grep -q "max_reward_besitos" bot/services/config.py</verify>
  <done>Reward value capping implemented with config-based limits</done>
</task>

</tasks>

<verification>
- RewardService exists with all required methods
- Condition evaluation handles all RewardConditionType values
- Event-driven checking methods implemented
- Reward claiming updates UserReward correctly
- Grouped notification builder uses Lucien's voice (ðŸŽ©)
</verification>

<success_criteria>
- RewardService with condition evaluation for all types
- Event-driven checking on daily gift, purchase, reaction, level up
- Reward claiming with proper state updates
- Grouped notification builder
- Integration with WalletService for BESITOS rewards
- Reward value capping implemented (REWARD-06)
</success_criteria>

<output>
After completion, create `.planning/phases/23-rewards-system/23-02-SUMMARY.md`
</output>
